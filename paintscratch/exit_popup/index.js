(function(){"use strict";try{if(typeof document<"u"){var i=document.createElement("style");i.appendChild(document.createTextNode('@font-face{font-family:swiper-icons;src:url(data:application/font-woff;charset=utf-8;base64,\\ d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA);font-weight:400;font-style:normal}:root{--swiper-theme-color: #007aff}:host{position:relative;display:block;margin-left:auto;margin-right:auto;z-index:1}.swiper{margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1;display:block}.swiper-vertical>.swiper-wrapper{flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:flex;transition-property:transform;transition-timing-function:var(--swiper-wrapper-transition-timing-function, initial);box-sizing:content-box}.swiper-android .swiper-slide,.swiper-ios .swiper-slide,.swiper-wrapper{transform:translateZ(0)}.swiper-horizontal{touch-action:pan-y}.swiper-vertical{touch-action:pan-x}.swiper-slide{flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform;display:block}.swiper-slide-invisible-blank{visibility:hidden}.swiper-autoheight,.swiper-autoheight .swiper-slide{height:auto}.swiper-autoheight .swiper-wrapper{align-items:flex-start;transition-property:transform,height}.swiper-backface-hidden .swiper-slide{transform:translateZ(0);backface-visibility:hidden}.swiper-3d.swiper-css-mode .swiper-wrapper{perspective:1200px}.swiper-3d .swiper-wrapper{transform-style:preserve-3d}.swiper-3d{perspective:1200px}.swiper-3d .swiper-slide,.swiper-3d .swiper-cube-shadow{transform-style:preserve-3d}.swiper-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-css-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:start start}.swiper-css-mode.swiper-horizontal>.swiper-wrapper{scroll-snap-type:x mandatory}.swiper-css-mode.swiper-vertical>.swiper-wrapper{scroll-snap-type:y mandatory}.swiper-css-mode.swiper-free-mode>.swiper-wrapper{scroll-snap-type:none}.swiper-css-mode.swiper-free-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:none}.swiper-css-mode.swiper-centered>.swiper-wrapper:before{content:"";flex-shrink:0;order:9999}.swiper-css-mode.swiper-centered>.swiper-wrapper>.swiper-slide{scroll-snap-align:center center;scroll-snap-stop:always}.swiper-css-mode.swiper-centered.swiper-horizontal>.swiper-wrapper>.swiper-slide:first-child{margin-inline-start:var(--swiper-centered-offset-before)}.swiper-css-mode.swiper-centered.swiper-horizontal>.swiper-wrapper:before{height:100%;min-height:1px;width:var(--swiper-centered-offset-after)}.swiper-css-mode.swiper-centered.swiper-vertical>.swiper-wrapper>.swiper-slide:first-child{margin-block-start:var(--swiper-centered-offset-before)}.swiper-css-mode.swiper-centered.swiper-vertical>.swiper-wrapper:before{width:100%;min-width:1px;height:var(--swiper-centered-offset-after)}.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top,.swiper-3d .swiper-slide-shadow-bottom{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-3d .swiper-slide-shadow{background:#00000026}.swiper-3d .swiper-slide-shadow-left{background-image:linear-gradient(to left,#00000080,#0000)}.swiper-3d .swiper-slide-shadow-right{background-image:linear-gradient(to right,#00000080,#0000)}.swiper-3d .swiper-slide-shadow-top{background-image:linear-gradient(to top,#00000080,#0000)}.swiper-3d .swiper-slide-shadow-bottom{background-image:linear-gradient(to bottom,#00000080,#0000)}.swiper-lazy-preloader{width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;transform-origin:50%;box-sizing:border-box;border:4px solid var(--swiper-preloader-color, var(--swiper-theme-color));border-radius:50%;border-top-color:transparent}.swiper:not(.swiper-watch-progress) .swiper-lazy-preloader,.swiper-watch-progress .swiper-slide-visible .swiper-lazy-preloader{animation:swiper-preloader-spin 1s infinite linear}.swiper-lazy-preloader-white{--swiper-preloader-color: #fff}.swiper-lazy-preloader-black{--swiper-preloader-color: #000}@keyframes swiper-preloader-spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}:root{--swiper-navigation-size: 44px}.swiper-button-prev,.swiper-button-next{position:absolute;top:var(--swiper-navigation-top-offset, 50%);width:calc(var(--swiper-navigation-size) / 44 * 27);height:var(--swiper-navigation-size);margin-top:calc(0px - (var(--swiper-navigation-size) / 2));z-index:10;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--swiper-navigation-color, var(--swiper-theme-color))}.swiper-button-prev.swiper-button-disabled,.swiper-button-next.swiper-button-disabled{opacity:.35;cursor:auto;pointer-events:none}.swiper-button-prev.swiper-button-hidden,.swiper-button-next.swiper-button-hidden{opacity:0;cursor:auto;pointer-events:none}.swiper-navigation-disabled .swiper-button-prev,.swiper-navigation-disabled .swiper-button-next{display:none!important}.swiper-button-prev svg,.swiper-button-next svg{width:100%;height:100%;-o-object-fit:contain;object-fit:contain;transform-origin:center}.swiper-rtl .swiper-button-prev svg,.swiper-rtl .swiper-button-next svg{transform:rotate(180deg)}.swiper-button-prev,.swiper-rtl .swiper-button-next{left:var(--swiper-navigation-sides-offset, 10px);right:auto}.swiper-button-lock{display:none}.swiper-button-prev:after,.swiper-button-next:after{font-family:swiper-icons;font-size:var(--swiper-navigation-size);text-transform:none!important;letter-spacing:0;font-variant:initial;line-height:1}.swiper-button-prev:after,.swiper-rtl .swiper-button-next:after{content:"prev"}.swiper-button-next,.swiper-rtl .swiper-button-prev{right:var(--swiper-navigation-sides-offset, 10px);left:auto}.swiper-button-next:after,.swiper-rtl .swiper-button-prev:after{content:"next"}.swiper-pagination{position:absolute;text-align:center;transition:.3s opacity;transform:translateZ(0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-pagination-disabled>.swiper-pagination,.swiper-pagination.swiper-pagination-disabled{display:none!important}.swiper-pagination-fraction,.swiper-pagination-custom,.swiper-horizontal>.swiper-pagination-bullets,.swiper-pagination-bullets.swiper-pagination-horizontal{bottom:var(--swiper-pagination-bottom, 8px);top:var(--swiper-pagination-top, auto);left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transform:scale(.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active,.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{transform:scale(.33)}.swiper-pagination-bullet{width:var(--swiper-pagination-bullet-width, var(--swiper-pagination-bullet-size, 8px));height:var(--swiper-pagination-bullet-height, var(--swiper-pagination-bullet-size, 8px));display:inline-block;border-radius:var(--swiper-pagination-bullet-border-radius, 50%);background:var(--swiper-pagination-bullet-inactive-color, #000);opacity:var(--swiper-pagination-bullet-inactive-opacity, .2)}button.swiper-pagination-bullet{border:none;margin:0;padding:0;box-shadow:none;-webkit-appearance:none;-moz-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet:only-child{display:none!important}.swiper-pagination-bullet-active{opacity:var(--swiper-pagination-bullet-opacity, 1);background:var(--swiper-pagination-color, var(--swiper-theme-color))}.swiper-vertical>.swiper-pagination-bullets,.swiper-pagination-vertical.swiper-pagination-bullets{right:var(--swiper-pagination-right, 8px);left:var(--swiper-pagination-left, auto);top:50%;transform:translate3d(0,-50%,0)}.swiper-vertical>.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-pagination-vertical.swiper-pagination-bullets .swiper-pagination-bullet{margin:var(--swiper-pagination-bullet-vertical-gap, 6px) 0;display:block}.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;transform:translateY(-50%);width:8px}.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;transition:.2s transform,.2s top}.swiper-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 var(--swiper-pagination-bullet-horizontal-gap, 4px)}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;transform:translate(-50%);white-space:nowrap}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s left}.swiper-horizontal.swiper-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s right}.swiper-pagination-fraction{color:var(--swiper-pagination-fraction-color, inherit)}.swiper-pagination-progressbar{background:var(--swiper-pagination-progressbar-bg-color, rgba(0, 0, 0, .25));position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--swiper-pagination-color, var(--swiper-theme-color));position:absolute;left:0;top:0;width:100%;height:100%;transform:scale(0);transform-origin:left top}.swiper-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{transform-origin:right top}.swiper-horizontal>.swiper-pagination-progressbar,.swiper-pagination-progressbar.swiper-pagination-horizontal,.swiper-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-vertical.swiper-pagination-progressbar-opposite{width:100%;height:var(--swiper-pagination-progressbar-size, 4px);left:0;top:0}.swiper-vertical>.swiper-pagination-progressbar,.swiper-pagination-progressbar.swiper-pagination-vertical,.swiper-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite{width:var(--swiper-pagination-progressbar-size, 4px);height:100%;left:0;top:0}.swiper-pagination-lock{display:none}*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.os-static{position:static}.os-absolute{position:absolute}.os-relative{position:relative}.os-right-\\[18px\\]{right:18px}.os-top-\\[50\\%\\]{top:50%}.os-m-0{margin:0}.os-mt-\\[12px\\]{margin-top:12px}.os-mt-\\[16px\\]{margin-top:16px}.os-mt-\\[20px\\]{margin-top:20px}.os-flex{display:flex}.os-hidden{display:none}.os-h-\\[104px\\]{height:104px}.os-h-\\[15px\\]{height:15px}.os-h-\\[2px\\]{height:2px}.os-h-\\[50px\\]{height:50px}.os-h-full{height:100%}.\\!os-w-max{width:-moz-max-content!important;width:max-content!important}.os-w-\\[104px\\]{width:104px}.os-w-\\[10px\\]{width:10px}.os-w-\\[335px\\]{width:335px}.os-w-\\[60\\%\\]{width:60%}.os-w-\\[60px\\]{width:60px}.os-w-fit{width:-moz-fit-content;width:fit-content}.os-w-full{width:100%}.-os-translate-y-2\\/4{--tw-translate-y: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.os-flex-col{flex-direction:column}.os-items-center{align-items:center}.os-justify-center{justify-content:center}.os-justify-between{justify-content:space-between}.os-gap-\\[16px\\]{gap:16px}.os-gap-\\[6px\\]{gap:6px}.os-gap-\\[8px\\]{gap:8px}.os-overflow-hidden{overflow:hidden}.os-rounded-\\[4px\\]{border-radius:4px}.os-border-\\[1px\\]{border-width:1px}.os-border-r-2{border-right-width:2px}.os-border-t-\\[1px\\]{border-top-width:1px}.os-border-dashed{border-style:dashed}.os-border-none{border-style:none}.os-border-\\[\\#dddee9\\]{--tw-border-opacity: 1;border-color:rgb(221 222 233 / var(--tw-border-opacity))}.os-bg-\\[\\#0373bd\\]{--tw-bg-opacity: 1;background-color:rgb(3 115 189 / var(--tw-bg-opacity))}.os-bg-transparent{background-color:transparent}.os-bg-\\[linear-gradient\\(to_bottom\\,_\\#ffc842\\,_\\#f48818\\)\\]{background-image:linear-gradient(to bottom,#ffc842,#f48818)}.os-p-0{padding:0}.os-p-\\[10px\\]{padding:10px}.os-p-\\[8px\\]{padding:8px}.os-px-\\[12px\\]{padding-left:12px;padding-right:12px}.os-px-\\[20px\\]{padding-left:20px;padding-right:20px}.os-py-\\[12px\\]{padding-top:12px;padding-bottom:12px}.os-py-\\[8px\\]{padding-top:8px;padding-bottom:8px}.os-pb-\\[20px\\]{padding-bottom:20px}.os-pb-\\[16px\\]{padding-bottom:16px}.os-text-left{text-align:left}.os-text-center{text-align:center}.os-text-\\[12px\\]{font-size:12px}.os-text-\\[14px\\]{font-size:14px}.os-text-\\[16px\\]{font-size:16px}.os-text-\\[18px\\]{font-size:18px}.os-text-\\[30px\\]{font-size:30px}.os-font-bold{font-weight:700}.os-font-normal{font-weight:400}.os-leading-\\[20px\\]{line-height:20px}.os-leading-\\[22px\\]{line-height:22px}.os-text-\\[\\#0373bd\\]{--tw-text-opacity: 1;color:rgb(3 115 189 / var(--tw-text-opacity))}.os-text-\\[\\#253189\\]{--tw-text-opacity: 1;color:rgb(37 49 137 / var(--tw-text-opacity))}.os-text-\\[\\#333\\]{--tw-text-opacity: 1;color:rgb(51 51 51 / var(--tw-text-opacity))}.os-text-\\[\\#555\\]{--tw-text-opacity: 1;color:rgb(85 85 85 / var(--tw-text-opacity))}.os-text-\\[\\#767676\\]{--tw-text-opacity: 1;color:rgb(118 118 118 / var(--tw-text-opacity))}.os-text-\\[\\#900\\]{--tw-text-opacity: 1;color:rgb(153 0 0 / var(--tw-text-opacity))}.os-text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.os-line-through{text-decoration-line:line-through}button{cursor:pointer}.after\\:os-text-\\[10px\\]:after{content:var(--tw-content);font-size:10px}.focus-within\\:os-outline-none:focus-within{outline:2px solid transparent;outline-offset:2px}.focus\\:os-outline-none:focus{outline:2px solid transparent;outline-offset:2px}@media (min-width: 768px){.md\\:os-block{display:block}.md\\:os-flex{display:flex}.md\\:os-w-\\[460px\\]{width:460px}.md\\:os-w-full{width:100%}.md\\:os-flex-row{flex-direction:row}.md\\:os-px-\\[30px\\]{padding-left:30px;padding-right:30px}.md\\:os-pb-\\[30px\\]{padding-bottom:30px}.md\\:os-text-\\[18px\\]{font-size:18px}.md\\:os-text-\\[20px\\]{font-size:20px}.md\\:os-text-\\[36px\\]{font-size:36px}}.\\[\\&_svg\\]\\:os-w-full svg{width:100%}')),document.head.appendChild(i)}}catch(t){console.error("vite-plugin-css-injected-by-js",t)}})();
(function() {
  "use strict";
  function le(s) {
    return s !== null && typeof s == "object" && "constructor" in s && s.constructor === Object;
  }
  function K(s, e) {
    s === void 0 && (s = {}), e === void 0 && (e = {}), Object.keys(e).forEach((t) => {
      typeof s[t] > "u" ? s[t] = e[t] : le(e[t]) && le(s[t]) && Object.keys(e[t]).length > 0 && K(s[t], e[t]);
    });
  }
  const de = {
    body: {},
    addEventListener() {
    },
    removeEventListener() {
    },
    activeElement: {
      blur() {
      },
      nodeName: ""
    },
    querySelector() {
      return null;
    },
    querySelectorAll() {
      return [];
    },
    getElementById() {
      return null;
    },
    createEvent() {
      return {
        initEvent() {
        }
      };
    },
    createElement() {
      return {
        children: [],
        childNodes: [],
        style: {},
        setAttribute() {
        },
        getElementsByTagName() {
          return [];
        }
      };
    },
    createElementNS() {
      return {};
    },
    importNode() {
      return null;
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    }
  };
  function H() {
    const s = typeof document < "u" ? document : {};
    return K(s, de), s;
  }
  const Le = {
    document: de,
    navigator: {
      userAgent: ""
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    },
    history: {
      replaceState() {
      },
      pushState() {
      },
      go() {
      },
      back() {
      }
    },
    CustomEvent: function() {
      return this;
    },
    addEventListener() {
    },
    removeEventListener() {
    },
    getComputedStyle() {
      return {
        getPropertyValue() {
          return "";
        }
      };
    },
    Image() {
    },
    Date() {
    },
    screen: {},
    setTimeout() {
    },
    clearTimeout() {
    },
    matchMedia() {
      return {};
    },
    requestAnimationFrame(s) {
      return typeof setTimeout > "u" ? (s(), null) : setTimeout(s, 0);
    },
    cancelAnimationFrame(s) {
      typeof setTimeout > "u" || clearTimeout(s);
    }
  };
  function k() {
    const s = typeof window < "u" ? window : {};
    return K(s, Le), s;
  }
  function Pe(s) {
    return s === void 0 && (s = ""), s.trim().split(" ").filter((e) => !!e.trim());
  }
  function Me(s) {
    const e = s;
    Object.keys(e).forEach((t) => {
      try {
        e[t] = null;
      } catch {
      }
      try {
        delete e[t];
      } catch {
      }
    });
  }
  function J(s, e) {
    return e === void 0 && (e = 0), setTimeout(s, e);
  }
  function R() {
    return Date.now();
  }
  function Ie(s) {
    const e = k();
    let t;
    return e.getComputedStyle && (t = e.getComputedStyle(s, null)), !t && s.currentStyle && (t = s.currentStyle), t || (t = s.style), t;
  }
  function Ae(s, e) {
    e === void 0 && (e = "x");
    const t = k();
    let i, r, n;
    const l = Ie(s);
    return t.WebKitCSSMatrix ? (r = l.transform || l.webkitTransform, r.split(",").length > 6 && (r = r.split(", ").map((o) => o.replace(",", ".")).join(", ")), n = new t.WebKitCSSMatrix(r === "none" ? "" : r)) : (n = l.MozTransform || l.OTransform || l.MsTransform || l.msTransform || l.transform || l.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), i = n.toString().split(",")), e === "x" && (t.WebKitCSSMatrix ? r = n.m41 : i.length === 16 ? r = parseFloat(i[12]) : r = parseFloat(i[4])), e === "y" && (t.WebKitCSSMatrix ? r = n.m42 : i.length === 16 ? r = parseFloat(i[13]) : r = parseFloat(i[5])), r || 0;
  }
  function j(s) {
    return typeof s == "object" && s !== null && s.constructor && Object.prototype.toString.call(s).slice(8, -1) === "Object";
  }
  function Oe(s) {
    return typeof window < "u" && typeof window.HTMLElement < "u" ? s instanceof HTMLElement : s && (s.nodeType === 1 || s.nodeType === 11);
  }
  function z() {
    const s = Object(arguments.length <= 0 ? void 0 : arguments[0]), e = ["__proto__", "constructor", "prototype"];
    for (let t = 1; t < arguments.length; t += 1) {
      const i = t < 0 || arguments.length <= t ? void 0 : arguments[t];
      if (i != null && !Oe(i)) {
        const r = Object.keys(Object(i)).filter((n) => e.indexOf(n) < 0);
        for (let n = 0, l = r.length; n < l; n += 1) {
          const o = r[n], a = Object.getOwnPropertyDescriptor(i, o);
          a !== void 0 && a.enumerable && (j(s[o]) && j(i[o]) ? i[o].__swiper__ ? s[o] = i[o] : z(s[o], i[o]) : !j(s[o]) && j(i[o]) ? (s[o] = {}, i[o].__swiper__ ? s[o] = i[o] : z(s[o], i[o])) : s[o] = i[o]);
        }
      }
    }
    return s;
  }
  function q(s, e, t) {
    s.style.setProperty(e, t);
  }
  function ce(s) {
    let {
      swiper: e,
      targetPosition: t,
      side: i
    } = s;
    const r = k(), n = -e.translate;
    let l = null, o;
    const a = e.params.speed;
    e.wrapperEl.style.scrollSnapType = "none", r.cancelAnimationFrame(e.cssModeFrameID);
    const p = t > n ? "next" : "prev", c = (v, m) => p === "next" && v >= m || p === "prev" && v <= m, f = () => {
      o = (/* @__PURE__ */ new Date()).getTime(), l === null && (l = o);
      const v = Math.max(Math.min((o - l) / a, 1), 0), m = 0.5 - Math.cos(v * Math.PI) / 2;
      let h = n + m * (t - n);
      if (c(h, t) && (h = t), e.wrapperEl.scrollTo({
        [i]: h
      }), c(h, t)) {
        e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.scrollSnapType = "", setTimeout(() => {
          e.wrapperEl.style.overflow = "", e.wrapperEl.scrollTo({
            [i]: h
          });
        }), r.cancelAnimationFrame(e.cssModeFrameID);
        return;
      }
      e.cssModeFrameID = r.requestAnimationFrame(f);
    };
    f();
  }
  function G(s, e) {
    return e === void 0 && (e = ""), [...s.children].filter((t) => t.matches(e));
  }
  function W(s) {
    try {
      console.warn(s);
      return;
    } catch {
    }
  }
  function Y(s, e) {
    e === void 0 && (e = []);
    const t = document.createElement(s);
    return t.classList.add(...Array.isArray(e) ? e : Pe(e)), t;
  }
  function ke(s, e) {
    const t = [];
    for (; s.previousElementSibling; ) {
      const i = s.previousElementSibling;
      e ? i.matches(e) && t.push(i) : t.push(i), s = i;
    }
    return t;
  }
  function ze(s, e) {
    const t = [];
    for (; s.nextElementSibling; ) {
      const i = s.nextElementSibling;
      e ? i.matches(e) && t.push(i) : t.push(i), s = i;
    }
    return t;
  }
  function _(s, e) {
    return k().getComputedStyle(s, null).getPropertyValue(e);
  }
  function X(s) {
    let e = s, t;
    if (e) {
      for (t = 0; (e = e.previousSibling) !== null; )
        e.nodeType === 1 && (t += 1);
      return t;
    }
  }
  function pe(s, e) {
    const t = [];
    let i = s.parentElement;
    for (; i; )
      e ? i.matches(e) && t.push(i) : t.push(i), i = i.parentElement;
    return t;
  }
  function Q(s, e, t) {
    const i = k();
    return t ? s[e === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(i.getComputedStyle(s, null).getPropertyValue(e === "width" ? "margin-right" : "margin-top")) + parseFloat(i.getComputedStyle(s, null).getPropertyValue(e === "width" ? "margin-left" : "margin-bottom")) : s.offsetWidth;
  }
  function A(s) {
    return (Array.isArray(s) ? s : [s]).filter((e) => !!e);
  }
  let ee;
  function $e() {
    const s = k(), e = H();
    return {
      smoothScroll: e.documentElement && e.documentElement.style && "scrollBehavior" in e.documentElement.style,
      touch: !!("ontouchstart" in s || s.DocumentTouch && e instanceof s.DocumentTouch)
    };
  }
  function ue() {
    return ee || (ee = $e()), ee;
  }
  let te;
  function De(s) {
    let {
      userAgent: e
    } = s === void 0 ? {} : s;
    const t = ue(), i = k(), r = i.navigator.platform, n = e || i.navigator.userAgent, l = {
      ios: !1,
      android: !1
    }, o = i.screen.width, a = i.screen.height, p = n.match(/(Android);?[\s\/]+([\d.]+)?/);
    let c = n.match(/(iPad).*OS\s([\d_]+)/);
    const f = n.match(/(iPod)(.*OS\s([\d_]+))?/), v = !c && n.match(/(iPhone\sOS|iOS)\s([\d_]+)/), m = r === "Win32";
    let h = r === "MacIntel";
    const w = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
    return !c && h && t.touch && w.indexOf(`${o}x${a}`) >= 0 && (c = n.match(/(Version)\/([\d.]+)/), c || (c = [0, 1, "13_0_0"]), h = !1), p && !m && (l.os = "android", l.android = !0), (c || v || f) && (l.os = "ios", l.ios = !0), l;
  }
  function fe(s) {
    return s === void 0 && (s = {}), te || (te = De(s)), te;
  }
  let se;
  function Ge() {
    const s = k(), e = fe();
    let t = !1;
    function i() {
      const o = s.navigator.userAgent.toLowerCase();
      return o.indexOf("safari") >= 0 && o.indexOf("chrome") < 0 && o.indexOf("android") < 0;
    }
    if (i()) {
      const o = String(s.navigator.userAgent);
      if (o.includes("Version/")) {
        const [a, p] = o.split("Version/")[1].split(" ")[0].split(".").map((c) => Number(c));
        t = a < 16 || a === 16 && p < 2;
      }
    }
    const r = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(s.navigator.userAgent), n = i(), l = n || r && e.ios;
    return {
      isSafari: t || n,
      needPerspectiveFix: t,
      need3dFix: l,
      isWebView: r
    };
  }
  function _e() {
    return se || (se = Ge()), se;
  }
  function Be(s) {
    let {
      swiper: e,
      on: t,
      emit: i
    } = s;
    const r = k();
    let n = null, l = null;
    const o = () => {
      !e || e.destroyed || !e.initialized || (i("beforeResize"), i("resize"));
    }, a = () => {
      !e || e.destroyed || !e.initialized || (n = new ResizeObserver((f) => {
        l = r.requestAnimationFrame(() => {
          const {
            width: v,
            height: m
          } = e;
          let h = v, w = m;
          f.forEach((S) => {
            let {
              contentBoxSize: d,
              contentRect: u,
              target: g
            } = S;
            g && g !== e.el || (h = u ? u.width : (d[0] || d).inlineSize, w = u ? u.height : (d[0] || d).blockSize);
          }), (h !== v || w !== m) && o();
        });
      }), n.observe(e.el));
    }, p = () => {
      l && r.cancelAnimationFrame(l), n && n.unobserve && e.el && (n.unobserve(e.el), n = null);
    }, c = () => {
      !e || e.destroyed || !e.initialized || i("orientationchange");
    };
    t("init", () => {
      if (e.params.resizeObserver && typeof r.ResizeObserver < "u") {
        a();
        return;
      }
      r.addEventListener("resize", o), r.addEventListener("orientationchange", c);
    }), t("destroy", () => {
      p(), r.removeEventListener("resize", o), r.removeEventListener("orientationchange", c);
    });
  }
  function Ve(s) {
    let {
      swiper: e,
      extendParams: t,
      on: i,
      emit: r
    } = s;
    const n = [], l = k(), o = function(c, f) {
      f === void 0 && (f = {});
      const v = l.MutationObserver || l.WebkitMutationObserver, m = new v((h) => {
        if (e.__preventObserver__)
          return;
        if (h.length === 1) {
          r("observerUpdate", h[0]);
          return;
        }
        const w = function() {
          r("observerUpdate", h[0]);
        };
        l.requestAnimationFrame ? l.requestAnimationFrame(w) : l.setTimeout(w, 0);
      });
      m.observe(c, {
        attributes: typeof f.attributes > "u" ? !0 : f.attributes,
        childList: typeof f.childList > "u" ? !0 : f.childList,
        characterData: typeof f.characterData > "u" ? !0 : f.characterData
      }), n.push(m);
    }, a = () => {
      if (e.params.observer) {
        if (e.params.observeParents) {
          const c = pe(e.hostEl);
          for (let f = 0; f < c.length; f += 1)
            o(c[f]);
        }
        o(e.hostEl, {
          childList: e.params.observeSlideChildren
        }), o(e.wrapperEl, {
          attributes: !1
        });
      }
    }, p = () => {
      n.forEach((c) => {
        c.disconnect();
      }), n.splice(0, n.length);
    };
    t({
      observer: !1,
      observeParents: !1,
      observeSlideChildren: !1
    }), i("init", a), i("destroy", p);
  }
  var He = {
    on(s, e, t) {
      const i = this;
      if (!i.eventsListeners || i.destroyed || typeof e != "function")
        return i;
      const r = t ? "unshift" : "push";
      return s.split(" ").forEach((n) => {
        i.eventsListeners[n] || (i.eventsListeners[n] = []), i.eventsListeners[n][r](e);
      }), i;
    },
    once(s, e, t) {
      const i = this;
      if (!i.eventsListeners || i.destroyed || typeof e != "function")
        return i;
      function r() {
        i.off(s, r), r.__emitterProxy && delete r.__emitterProxy;
        for (var n = arguments.length, l = new Array(n), o = 0; o < n; o++)
          l[o] = arguments[o];
        e.apply(i, l);
      }
      return r.__emitterProxy = e, i.on(s, r, t);
    },
    onAny(s, e) {
      const t = this;
      if (!t.eventsListeners || t.destroyed || typeof s != "function")
        return t;
      const i = e ? "unshift" : "push";
      return t.eventsAnyListeners.indexOf(s) < 0 && t.eventsAnyListeners[i](s), t;
    },
    offAny(s) {
      const e = this;
      if (!e.eventsListeners || e.destroyed || !e.eventsAnyListeners)
        return e;
      const t = e.eventsAnyListeners.indexOf(s);
      return t >= 0 && e.eventsAnyListeners.splice(t, 1), e;
    },
    off(s, e) {
      const t = this;
      return !t.eventsListeners || t.destroyed || !t.eventsListeners || s.split(" ").forEach((i) => {
        typeof e > "u" ? t.eventsListeners[i] = [] : t.eventsListeners[i] && t.eventsListeners[i].forEach((r, n) => {
          (r === e || r.__emitterProxy && r.__emitterProxy === e) && t.eventsListeners[i].splice(n, 1);
        });
      }), t;
    },
    emit() {
      const s = this;
      if (!s.eventsListeners || s.destroyed || !s.eventsListeners)
        return s;
      let e, t, i;
      for (var r = arguments.length, n = new Array(r), l = 0; l < r; l++)
        n[l] = arguments[l];
      return typeof n[0] == "string" || Array.isArray(n[0]) ? (e = n[0], t = n.slice(1, n.length), i = s) : (e = n[0].events, t = n[0].data, i = n[0].context || s), t.unshift(i), (Array.isArray(e) ? e : e.split(" ")).forEach((a) => {
        s.eventsAnyListeners && s.eventsAnyListeners.length && s.eventsAnyListeners.forEach((p) => {
          p.apply(i, [a, ...t]);
        }), s.eventsListeners && s.eventsListeners[a] && s.eventsListeners[a].forEach((p) => {
          p.apply(i, t);
        });
      }), s;
    }
  };
  function Fe() {
    const s = this;
    let e, t;
    const i = s.el;
    typeof s.params.width < "u" && s.params.width !== null ? e = s.params.width : e = i.clientWidth, typeof s.params.height < "u" && s.params.height !== null ? t = s.params.height : t = i.clientHeight, !(e === 0 && s.isHorizontal() || t === 0 && s.isVertical()) && (e = e - parseInt(_(i, "padding-left") || 0, 10) - parseInt(_(i, "padding-right") || 0, 10), t = t - parseInt(_(i, "padding-top") || 0, 10) - parseInt(_(i, "padding-bottom") || 0, 10), Number.isNaN(e) && (e = 0), Number.isNaN(t) && (t = 0), Object.assign(s, {
      width: e,
      height: t,
      size: s.isHorizontal() ? e : t
    }));
  }
  function Ne() {
    const s = this;
    function e(b, E) {
      return parseFloat(b.getPropertyValue(s.getDirectionLabel(E)) || 0);
    }
    const t = s.params, {
      wrapperEl: i,
      slidesEl: r,
      size: n,
      rtlTranslate: l,
      wrongRTL: o
    } = s, a = s.virtual && t.virtual.enabled, p = a ? s.virtual.slides.length : s.slides.length, c = G(r, `.${s.params.slideClass}, swiper-slide`), f = a ? s.virtual.slides.length : c.length;
    let v = [];
    const m = [], h = [];
    let w = t.slidesOffsetBefore;
    typeof w == "function" && (w = t.slidesOffsetBefore.call(s));
    let S = t.slidesOffsetAfter;
    typeof S == "function" && (S = t.slidesOffsetAfter.call(s));
    const d = s.snapGrid.length, u = s.slidesGrid.length;
    let g = t.spaceBetween, x = -w, y = 0, M = 0;
    if (typeof n > "u")
      return;
    typeof g == "string" && g.indexOf("%") >= 0 ? g = parseFloat(g.replace("%", "")) / 100 * n : typeof g == "string" && (g = parseFloat(g)), s.virtualSize = -g, c.forEach((b) => {
      l ? b.style.marginLeft = "" : b.style.marginRight = "", b.style.marginBottom = "", b.style.marginTop = "";
    }), t.centeredSlides && t.cssMode && (q(i, "--swiper-centered-offset-before", ""), q(i, "--swiper-centered-offset-after", ""));
    const D = t.grid && t.grid.rows > 1 && s.grid;
    D ? s.grid.initSlides(c) : s.grid && s.grid.unsetSlides();
    let L;
    const O = t.slidesPerView === "auto" && t.breakpoints && Object.keys(t.breakpoints).filter((b) => typeof t.breakpoints[b].slidesPerView < "u").length > 0;
    for (let b = 0; b < f; b += 1) {
      L = 0;
      let E;
      if (c[b] && (E = c[b]), D && s.grid.updateSlide(b, E, c), !(c[b] && _(E, "display") === "none")) {
        if (t.slidesPerView === "auto") {
          O && (c[b].style[s.getDirectionLabel("width")] = "");
          const C = getComputedStyle(E), T = E.style.transform, P = E.style.webkitTransform;
          if (T && (E.style.transform = "none"), P && (E.style.webkitTransform = "none"), t.roundLengths)
            L = s.isHorizontal() ? Q(E, "width", !0) : Q(E, "height", !0);
          else {
            const I = e(C, "width"), B = e(C, "padding-left"), ns = e(C, "padding-right"), Te = e(C, "margin-left"), Ce = e(C, "margin-right"), Ee = C.getPropertyValue("box-sizing");
            if (Ee && Ee === "border-box")
              L = I + Te + Ce;
            else {
              const {
                clientWidth: rs,
                offsetWidth: as
              } = E;
              L = I + B + ns + Te + Ce + (as - rs);
            }
          }
          T && (E.style.transform = T), P && (E.style.webkitTransform = P), t.roundLengths && (L = Math.floor(L));
        } else
          L = (n - (t.slidesPerView - 1) * g) / t.slidesPerView, t.roundLengths && (L = Math.floor(L)), c[b] && (c[b].style[s.getDirectionLabel("width")] = `${L}px`);
        c[b] && (c[b].swiperSlideSize = L), h.push(L), t.centeredSlides ? (x = x + L / 2 + y / 2 + g, y === 0 && b !== 0 && (x = x - n / 2 - g), b === 0 && (x = x - n / 2 - g), Math.abs(x) < 1 / 1e3 && (x = 0), t.roundLengths && (x = Math.floor(x)), M % t.slidesPerGroup === 0 && v.push(x), m.push(x)) : (t.roundLengths && (x = Math.floor(x)), (M - Math.min(s.params.slidesPerGroupSkip, M)) % s.params.slidesPerGroup === 0 && v.push(x), m.push(x), x = x + L + g), s.virtualSize += L + g, y = L, M += 1;
      }
    }
    if (s.virtualSize = Math.max(s.virtualSize, n) + S, l && o && (t.effect === "slide" || t.effect === "coverflow") && (i.style.width = `${s.virtualSize + g}px`), t.setWrapperSize && (i.style[s.getDirectionLabel("width")] = `${s.virtualSize + g}px`), D && s.grid.updateWrapperSize(L, v), !t.centeredSlides) {
      const b = [];
      for (let E = 0; E < v.length; E += 1) {
        let C = v[E];
        t.roundLengths && (C = Math.floor(C)), v[E] <= s.virtualSize - n && b.push(C);
      }
      v = b, Math.floor(s.virtualSize - n) - Math.floor(v[v.length - 1]) > 1 && v.push(s.virtualSize - n);
    }
    if (a && t.loop) {
      const b = h[0] + g;
      if (t.slidesPerGroup > 1) {
        const E = Math.ceil((s.virtual.slidesBefore + s.virtual.slidesAfter) / t.slidesPerGroup), C = b * t.slidesPerGroup;
        for (let T = 0; T < E; T += 1)
          v.push(v[v.length - 1] + C);
      }
      for (let E = 0; E < s.virtual.slidesBefore + s.virtual.slidesAfter; E += 1)
        t.slidesPerGroup === 1 && v.push(v[v.length - 1] + b), m.push(m[m.length - 1] + b), s.virtualSize += b;
    }
    if (v.length === 0 && (v = [0]), g !== 0) {
      const b = s.isHorizontal() && l ? "marginLeft" : s.getDirectionLabel("marginRight");
      c.filter((E, C) => !t.cssMode || t.loop ? !0 : C !== c.length - 1).forEach((E) => {
        E.style[b] = `${g}px`;
      });
    }
    if (t.centeredSlides && t.centeredSlidesBounds) {
      let b = 0;
      h.forEach((C) => {
        b += C + (g || 0);
      }), b -= g;
      const E = b - n;
      v = v.map((C) => C <= 0 ? -w : C > E ? E + S : C);
    }
    if (t.centerInsufficientSlides) {
      let b = 0;
      if (h.forEach((E) => {
        b += E + (g || 0);
      }), b -= g, b < n) {
        const E = (n - b) / 2;
        v.forEach((C, T) => {
          v[T] = C - E;
        }), m.forEach((C, T) => {
          m[T] = C + E;
        });
      }
    }
    if (Object.assign(s, {
      slides: c,
      snapGrid: v,
      slidesGrid: m,
      slidesSizesGrid: h
    }), t.centeredSlides && t.cssMode && !t.centeredSlidesBounds) {
      q(i, "--swiper-centered-offset-before", `${-v[0]}px`), q(i, "--swiper-centered-offset-after", `${s.size / 2 - h[h.length - 1] / 2}px`);
      const b = -s.snapGrid[0], E = -s.slidesGrid[0];
      s.snapGrid = s.snapGrid.map((C) => C + b), s.slidesGrid = s.slidesGrid.map((C) => C + E);
    }
    if (f !== p && s.emit("slidesLengthChange"), v.length !== d && (s.params.watchOverflow && s.checkOverflow(), s.emit("snapGridLengthChange")), m.length !== u && s.emit("slidesGridLengthChange"), t.watchSlidesProgress && s.updateSlidesOffset(), s.emit("slidesUpdated"), !a && !t.cssMode && (t.effect === "slide" || t.effect === "fade")) {
      const b = `${t.containerModifierClass}backface-hidden`, E = s.el.classList.contains(b);
      f <= t.maxBackfaceHiddenSlides ? E || s.el.classList.add(b) : E && s.el.classList.remove(b);
    }
  }
  function Re(s) {
    const e = this, t = [], i = e.virtual && e.params.virtual.enabled;
    let r = 0, n;
    typeof s == "number" ? e.setTransition(s) : s === !0 && e.setTransition(e.params.speed);
    const l = (o) => i ? e.slides[e.getSlideIndexByData(o)] : e.slides[o];
    if (e.params.slidesPerView !== "auto" && e.params.slidesPerView > 1)
      if (e.params.centeredSlides)
        (e.visibleSlides || []).forEach((o) => {
          t.push(o);
        });
      else
        for (n = 0; n < Math.ceil(e.params.slidesPerView); n += 1) {
          const o = e.activeIndex + n;
          if (o > e.slides.length && !i)
            break;
          t.push(l(o));
        }
    else
      t.push(l(e.activeIndex));
    for (n = 0; n < t.length; n += 1)
      if (typeof t[n] < "u") {
        const o = t[n].offsetHeight;
        r = o > r ? o : r;
      }
    (r || r === 0) && (e.wrapperEl.style.height = `${r}px`);
  }
  function je() {
    const s = this, e = s.slides, t = s.isElement ? s.isHorizontal() ? s.wrapperEl.offsetLeft : s.wrapperEl.offsetTop : 0;
    for (let i = 0; i < e.length; i += 1)
      e[i].swiperSlideOffset = (s.isHorizontal() ? e[i].offsetLeft : e[i].offsetTop) - t - s.cssOverflowAdjustment();
  }
  function qe(s) {
    s === void 0 && (s = this && this.translate || 0);
    const e = this, t = e.params, {
      slides: i,
      rtlTranslate: r,
      snapGrid: n
    } = e;
    if (i.length === 0)
      return;
    typeof i[0].swiperSlideOffset > "u" && e.updateSlidesOffset();
    let l = -s;
    r && (l = s), i.forEach((a) => {
      a.classList.remove(t.slideVisibleClass, t.slideFullyVisibleClass);
    }), e.visibleSlidesIndexes = [], e.visibleSlides = [];
    let o = t.spaceBetween;
    typeof o == "string" && o.indexOf("%") >= 0 ? o = parseFloat(o.replace("%", "")) / 100 * e.size : typeof o == "string" && (o = parseFloat(o));
    for (let a = 0; a < i.length; a += 1) {
      const p = i[a];
      let c = p.swiperSlideOffset;
      t.cssMode && t.centeredSlides && (c -= i[0].swiperSlideOffset);
      const f = (l + (t.centeredSlides ? e.minTranslate() : 0) - c) / (p.swiperSlideSize + o), v = (l - n[0] + (t.centeredSlides ? e.minTranslate() : 0) - c) / (p.swiperSlideSize + o), m = -(l - c), h = m + e.slidesSizesGrid[a], w = m >= 0 && m <= e.size - e.slidesSizesGrid[a];
      (m >= 0 && m < e.size - 1 || h > 1 && h <= e.size || m <= 0 && h >= e.size) && (e.visibleSlides.push(p), e.visibleSlidesIndexes.push(a), i[a].classList.add(t.slideVisibleClass)), w && i[a].classList.add(t.slideFullyVisibleClass), p.progress = r ? -f : f, p.originalProgress = r ? -v : v;
    }
  }
  function We(s) {
    const e = this;
    if (typeof s > "u") {
      const c = e.rtlTranslate ? -1 : 1;
      s = e && e.translate && e.translate * c || 0;
    }
    const t = e.params, i = e.maxTranslate() - e.minTranslate();
    let {
      progress: r,
      isBeginning: n,
      isEnd: l,
      progressLoop: o
    } = e;
    const a = n, p = l;
    if (i === 0)
      r = 0, n = !0, l = !0;
    else {
      r = (s - e.minTranslate()) / i;
      const c = Math.abs(s - e.minTranslate()) < 1, f = Math.abs(s - e.maxTranslate()) < 1;
      n = c || r <= 0, l = f || r >= 1, c && (r = 0), f && (r = 1);
    }
    if (t.loop) {
      const c = e.getSlideIndexByData(0), f = e.getSlideIndexByData(e.slides.length - 1), v = e.slidesGrid[c], m = e.slidesGrid[f], h = e.slidesGrid[e.slidesGrid.length - 1], w = Math.abs(s);
      w >= v ? o = (w - v) / h : o = (w + h - m) / h, o > 1 && (o -= 1);
    }
    Object.assign(e, {
      progress: r,
      progressLoop: o,
      isBeginning: n,
      isEnd: l
    }), (t.watchSlidesProgress || t.centeredSlides && t.autoHeight) && e.updateSlidesProgress(s), n && !a && e.emit("reachBeginning toEdge"), l && !p && e.emit("reachEnd toEdge"), (a && !n || p && !l) && e.emit("fromEdge"), e.emit("progress", r);
  }
  function Ye() {
    const s = this, {
      slides: e,
      params: t,
      slidesEl: i,
      activeIndex: r
    } = s, n = s.virtual && t.virtual.enabled, l = s.grid && t.grid && t.grid.rows > 1, o = (f) => G(i, `.${t.slideClass}${f}, swiper-slide${f}`)[0];
    e.forEach((f) => {
      f.classList.remove(t.slideActiveClass, t.slideNextClass, t.slidePrevClass);
    });
    let a, p, c;
    if (n)
      if (t.loop) {
        let f = r - s.virtual.slidesBefore;
        f < 0 && (f = s.virtual.slides.length + f), f >= s.virtual.slides.length && (f -= s.virtual.slides.length), a = o(`[data-swiper-slide-index="${f}"]`);
      } else
        a = o(`[data-swiper-slide-index="${r}"]`);
    else
      l ? (a = e.filter((f) => f.column === r)[0], c = e.filter((f) => f.column === r + 1)[0], p = e.filter((f) => f.column === r - 1)[0]) : a = e[r];
    a && (a.classList.add(t.slideActiveClass), l ? (c && c.classList.add(t.slideNextClass), p && p.classList.add(t.slidePrevClass)) : (c = ze(a, `.${t.slideClass}, swiper-slide`)[0], t.loop && !c && (c = e[0]), c && c.classList.add(t.slideNextClass), p = ke(a, `.${t.slideClass}, swiper-slide`)[0], t.loop && !p === 0 && (p = e[e.length - 1]), p && p.classList.add(t.slidePrevClass))), s.emitSlidesClasses();
  }
  const Z = (s, e) => {
    if (!s || s.destroyed || !s.params)
      return;
    const t = () => s.isElement ? "swiper-slide" : `.${s.params.slideClass}`, i = e.closest(t());
    if (i) {
      let r = i.querySelector(`.${s.params.lazyPreloaderClass}`);
      !r && s.isElement && (i.shadowRoot ? r = i.shadowRoot.querySelector(`.${s.params.lazyPreloaderClass}`) : requestAnimationFrame(() => {
        i.shadowRoot && (r = i.shadowRoot.querySelector(`.${s.params.lazyPreloaderClass}`), r && r.remove());
      })), r && r.remove();
    }
  }, ie = (s, e) => {
    if (!s.slides[e])
      return;
    const t = s.slides[e].querySelector('[loading="lazy"]');
    t && t.removeAttribute("loading");
  }, ne = (s) => {
    if (!s || s.destroyed || !s.params)
      return;
    let e = s.params.lazyPreloadPrevNext;
    const t = s.slides.length;
    if (!t || !e || e < 0)
      return;
    e = Math.min(e, t);
    const i = s.params.slidesPerView === "auto" ? s.slidesPerViewDynamic() : Math.ceil(s.params.slidesPerView), r = s.activeIndex;
    if (s.params.grid && s.params.grid.rows > 1) {
      const l = r, o = [l - e];
      o.push(...Array.from({
        length: e
      }).map((a, p) => l + i + p)), s.slides.forEach((a, p) => {
        o.includes(a.column) && ie(s, p);
      });
      return;
    }
    const n = r + i - 1;
    if (s.params.rewind || s.params.loop)
      for (let l = r - e; l <= n + e; l += 1) {
        const o = (l % t + t) % t;
        (o < r || o > n) && ie(s, o);
      }
    else
      for (let l = Math.max(r - e, 0); l <= Math.min(n + e, t - 1); l += 1)
        l !== r && (l > n || l < r) && ie(s, l);
  };
  function Xe(s) {
    const {
      slidesGrid: e,
      params: t
    } = s, i = s.rtlTranslate ? s.translate : -s.translate;
    let r;
    for (let n = 0; n < e.length; n += 1)
      typeof e[n + 1] < "u" ? i >= e[n] && i < e[n + 1] - (e[n + 1] - e[n]) / 2 ? r = n : i >= e[n] && i < e[n + 1] && (r = n + 1) : i >= e[n] && (r = n);
    return t.normalizeSlideIndex && (r < 0 || typeof r > "u") && (r = 0), r;
  }
  function Ze(s) {
    const e = this, t = e.rtlTranslate ? e.translate : -e.translate, {
      snapGrid: i,
      params: r,
      activeIndex: n,
      realIndex: l,
      snapIndex: o
    } = e;
    let a = s, p;
    const c = (m) => {
      let h = m - e.virtual.slidesBefore;
      return h < 0 && (h = e.virtual.slides.length + h), h >= e.virtual.slides.length && (h -= e.virtual.slides.length), h;
    };
    if (typeof a > "u" && (a = Xe(e)), i.indexOf(t) >= 0)
      p = i.indexOf(t);
    else {
      const m = Math.min(r.slidesPerGroupSkip, a);
      p = m + Math.floor((a - m) / r.slidesPerGroup);
    }
    if (p >= i.length && (p = i.length - 1), a === n && !e.params.loop) {
      p !== o && (e.snapIndex = p, e.emit("snapIndexChange"));
      return;
    }
    if (a === n && e.params.loop && e.virtual && e.params.virtual.enabled) {
      e.realIndex = c(a);
      return;
    }
    const f = e.grid && r.grid && r.grid.rows > 1;
    let v;
    if (e.virtual && r.virtual.enabled && r.loop)
      v = c(a);
    else if (f) {
      const m = e.slides.filter((w) => w.column === a)[0];
      let h = parseInt(m.getAttribute("data-swiper-slide-index"), 10);
      Number.isNaN(h) && (h = Math.max(e.slides.indexOf(m), 0)), v = Math.floor(h / r.grid.rows);
    } else if (e.slides[a]) {
      const m = e.slides[a].getAttribute("data-swiper-slide-index");
      m ? v = parseInt(m, 10) : v = a;
    } else
      v = a;
    Object.assign(e, {
      previousSnapIndex: o,
      snapIndex: p,
      previousRealIndex: l,
      realIndex: v,
      previousIndex: n,
      activeIndex: a
    }), e.initialized && ne(e), e.emit("activeIndexChange"), e.emit("snapIndexChange"), (e.initialized || e.params.runCallbacksOnInit) && (l !== v && e.emit("realIndexChange"), e.emit("slideChange"));
  }
  function Ue(s, e) {
    const t = this, i = t.params;
    let r = s.closest(`.${i.slideClass}, swiper-slide`);
    !r && t.isElement && e && e.length > 1 && e.includes(s) && [...e.slice(e.indexOf(s) + 1, e.length)].forEach((o) => {
      !r && o.matches && o.matches(`.${i.slideClass}, swiper-slide`) && (r = o);
    });
    let n = !1, l;
    if (r) {
      for (let o = 0; o < t.slides.length; o += 1)
        if (t.slides[o] === r) {
          n = !0, l = o;
          break;
        }
    }
    if (r && n)
      t.clickedSlide = r, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(r.getAttribute("data-swiper-slide-index"), 10) : t.clickedIndex = l;
    else {
      t.clickedSlide = void 0, t.clickedIndex = void 0;
      return;
    }
    i.slideToClickedSlide && t.clickedIndex !== void 0 && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide();
  }
  var Ke = {
    updateSize: Fe,
    updateSlides: Ne,
    updateAutoHeight: Re,
    updateSlidesOffset: je,
    updateSlidesProgress: qe,
    updateProgress: We,
    updateSlidesClasses: Ye,
    updateActiveIndex: Ze,
    updateClickedSlide: Ue
  };
  function Je(s) {
    s === void 0 && (s = this.isHorizontal() ? "x" : "y");
    const e = this, {
      params: t,
      rtlTranslate: i,
      translate: r,
      wrapperEl: n
    } = e;
    if (t.virtualTranslate)
      return i ? -r : r;
    if (t.cssMode)
      return r;
    let l = Ae(n, s);
    return l += e.cssOverflowAdjustment(), i && (l = -l), l || 0;
  }
  function Qe(s, e) {
    const t = this, {
      rtlTranslate: i,
      params: r,
      wrapperEl: n,
      progress: l
    } = t;
    let o = 0, a = 0;
    const p = 0;
    t.isHorizontal() ? o = i ? -s : s : a = s, r.roundLengths && (o = Math.floor(o), a = Math.floor(a)), t.previousTranslate = t.translate, t.translate = t.isHorizontal() ? o : a, r.cssMode ? n[t.isHorizontal() ? "scrollLeft" : "scrollTop"] = t.isHorizontal() ? -o : -a : r.virtualTranslate || (t.isHorizontal() ? o -= t.cssOverflowAdjustment() : a -= t.cssOverflowAdjustment(), n.style.transform = `translate3d(${o}px, ${a}px, ${p}px)`);
    let c;
    const f = t.maxTranslate() - t.minTranslate();
    f === 0 ? c = 0 : c = (s - t.minTranslate()) / f, c !== l && t.updateProgress(s), t.emit("setTranslate", t.translate, e);
  }
  function et() {
    return -this.snapGrid[0];
  }
  function tt() {
    return -this.snapGrid[this.snapGrid.length - 1];
  }
  function st(s, e, t, i, r) {
    s === void 0 && (s = 0), e === void 0 && (e = this.params.speed), t === void 0 && (t = !0), i === void 0 && (i = !0);
    const n = this, {
      params: l,
      wrapperEl: o
    } = n;
    if (n.animating && l.preventInteractionOnTransition)
      return !1;
    const a = n.minTranslate(), p = n.maxTranslate();
    let c;
    if (i && s > a ? c = a : i && s < p ? c = p : c = s, n.updateProgress(c), l.cssMode) {
      const f = n.isHorizontal();
      if (e === 0)
        o[f ? "scrollLeft" : "scrollTop"] = -c;
      else {
        if (!n.support.smoothScroll)
          return ce({
            swiper: n,
            targetPosition: -c,
            side: f ? "left" : "top"
          }), !0;
        o.scrollTo({
          [f ? "left" : "top"]: -c,
          behavior: "smooth"
        });
      }
      return !0;
    }
    return e === 0 ? (n.setTransition(0), n.setTranslate(c), t && (n.emit("beforeTransitionStart", e, r), n.emit("transitionEnd"))) : (n.setTransition(e), n.setTranslate(c), t && (n.emit("beforeTransitionStart", e, r), n.emit("transitionStart")), n.animating || (n.animating = !0, n.onTranslateToWrapperTransitionEnd || (n.onTranslateToWrapperTransitionEnd = function(v) {
      !n || n.destroyed || v.target === this && (n.wrapperEl.removeEventListener("transitionend", n.onTranslateToWrapperTransitionEnd), n.onTranslateToWrapperTransitionEnd = null, delete n.onTranslateToWrapperTransitionEnd, t && n.emit("transitionEnd"));
    }), n.wrapperEl.addEventListener("transitionend", n.onTranslateToWrapperTransitionEnd))), !0;
  }
  var it = {
    getTranslate: Je,
    setTranslate: Qe,
    minTranslate: et,
    maxTranslate: tt,
    translateTo: st
  };
  function nt(s, e) {
    const t = this;
    t.params.cssMode || (t.wrapperEl.style.transitionDuration = `${s}ms`, t.wrapperEl.style.transitionDelay = s === 0 ? "0ms" : ""), t.emit("setTransition", s, e);
  }
  function he(s) {
    let {
      swiper: e,
      runCallbacks: t,
      direction: i,
      step: r
    } = s;
    const {
      activeIndex: n,
      previousIndex: l
    } = e;
    let o = i;
    if (o || (n > l ? o = "next" : n < l ? o = "prev" : o = "reset"), e.emit(`transition${r}`), t && n !== l) {
      if (o === "reset") {
        e.emit(`slideResetTransition${r}`);
        return;
      }
      e.emit(`slideChangeTransition${r}`), o === "next" ? e.emit(`slideNextTransition${r}`) : e.emit(`slidePrevTransition${r}`);
    }
  }
  function rt(s, e) {
    s === void 0 && (s = !0);
    const t = this, {
      params: i
    } = t;
    i.cssMode || (i.autoHeight && t.updateAutoHeight(), he({
      swiper: t,
      runCallbacks: s,
      direction: e,
      step: "Start"
    }));
  }
  function at(s, e) {
    s === void 0 && (s = !0);
    const t = this, {
      params: i
    } = t;
    t.animating = !1, !i.cssMode && (t.setTransition(0), he({
      swiper: t,
      runCallbacks: s,
      direction: e,
      step: "End"
    }));
  }
  var ot = {
    setTransition: nt,
    transitionStart: rt,
    transitionEnd: at
  };
  function lt(s, e, t, i, r) {
    s === void 0 && (s = 0), e === void 0 && (e = this.params.speed), t === void 0 && (t = !0), typeof s == "string" && (s = parseInt(s, 10));
    const n = this;
    let l = s;
    l < 0 && (l = 0);
    const {
      params: o,
      snapGrid: a,
      slidesGrid: p,
      previousIndex: c,
      activeIndex: f,
      rtlTranslate: v,
      wrapperEl: m,
      enabled: h
    } = n;
    if (n.animating && o.preventInteractionOnTransition || !h && !i && !r || n.destroyed)
      return !1;
    const w = Math.min(n.params.slidesPerGroupSkip, l);
    let S = w + Math.floor((l - w) / n.params.slidesPerGroup);
    S >= a.length && (S = a.length - 1);
    const d = -a[S];
    if (o.normalizeSlideIndex)
      for (let g = 0; g < p.length; g += 1) {
        const x = -Math.floor(d * 100), y = Math.floor(p[g] * 100), M = Math.floor(p[g + 1] * 100);
        typeof p[g + 1] < "u" ? x >= y && x < M - (M - y) / 2 ? l = g : x >= y && x < M && (l = g + 1) : x >= y && (l = g);
      }
    if (n.initialized && l !== f && (!n.allowSlideNext && (v ? d > n.translate && d > n.minTranslate() : d < n.translate && d < n.minTranslate()) || !n.allowSlidePrev && d > n.translate && d > n.maxTranslate() && (f || 0) !== l))
      return !1;
    l !== (c || 0) && t && n.emit("beforeSlideChangeStart"), n.updateProgress(d);
    let u;
    if (l > f ? u = "next" : l < f ? u = "prev" : u = "reset", v && -d === n.translate || !v && d === n.translate)
      return n.updateActiveIndex(l), o.autoHeight && n.updateAutoHeight(), n.updateSlidesClasses(), o.effect !== "slide" && n.setTranslate(d), u !== "reset" && (n.transitionStart(t, u), n.transitionEnd(t, u)), !1;
    if (o.cssMode) {
      const g = n.isHorizontal(), x = v ? d : -d;
      if (e === 0) {
        const y = n.virtual && n.params.virtual.enabled;
        y && (n.wrapperEl.style.scrollSnapType = "none", n._immediateVirtual = !0), y && !n._cssModeVirtualInitialSet && n.params.initialSlide > 0 ? (n._cssModeVirtualInitialSet = !0, requestAnimationFrame(() => {
          m[g ? "scrollLeft" : "scrollTop"] = x;
        })) : m[g ? "scrollLeft" : "scrollTop"] = x, y && requestAnimationFrame(() => {
          n.wrapperEl.style.scrollSnapType = "", n._immediateVirtual = !1;
        });
      } else {
        if (!n.support.smoothScroll)
          return ce({
            swiper: n,
            targetPosition: x,
            side: g ? "left" : "top"
          }), !0;
        m.scrollTo({
          [g ? "left" : "top"]: x,
          behavior: "smooth"
        });
      }
      return !0;
    }
    return n.setTransition(e), n.setTranslate(d), n.updateActiveIndex(l), n.updateSlidesClasses(), n.emit("beforeTransitionStart", e, i), n.transitionStart(t, u), e === 0 ? n.transitionEnd(t, u) : n.animating || (n.animating = !0, n.onSlideToWrapperTransitionEnd || (n.onSlideToWrapperTransitionEnd = function(x) {
      !n || n.destroyed || x.target === this && (n.wrapperEl.removeEventListener("transitionend", n.onSlideToWrapperTransitionEnd), n.onSlideToWrapperTransitionEnd = null, delete n.onSlideToWrapperTransitionEnd, n.transitionEnd(t, u));
    }), n.wrapperEl.addEventListener("transitionend", n.onSlideToWrapperTransitionEnd)), !0;
  }
  function dt(s, e, t, i) {
    s === void 0 && (s = 0), e === void 0 && (e = this.params.speed), t === void 0 && (t = !0), typeof s == "string" && (s = parseInt(s, 10));
    const r = this;
    if (r.destroyed)
      return;
    const n = r.grid && r.params.grid && r.params.grid.rows > 1;
    let l = s;
    if (r.params.loop)
      if (r.virtual && r.params.virtual.enabled)
        l = l + r.virtual.slidesBefore;
      else {
        let o;
        if (n) {
          const v = l * r.params.grid.rows;
          o = r.slides.filter((m) => m.getAttribute("data-swiper-slide-index") * 1 === v)[0].column;
        } else
          o = r.getSlideIndexByData(l);
        const a = n ? Math.ceil(r.slides.length / r.params.grid.rows) : r.slides.length, {
          centeredSlides: p
        } = r.params;
        let c = r.params.slidesPerView;
        c === "auto" ? c = r.slidesPerViewDynamic() : (c = Math.ceil(parseFloat(r.params.slidesPerView, 10)), p && c % 2 === 0 && (c = c + 1));
        let f = a - o < c;
        if (p && (f = f || o < Math.ceil(c / 2)), f) {
          const v = p ? o < r.activeIndex ? "prev" : "next" : o - r.activeIndex - 1 < r.params.slidesPerView ? "next" : "prev";
          r.loopFix({
            direction: v,
            slideTo: !0,
            activeSlideIndex: v === "next" ? o + 1 : o - a + 1,
            slideRealIndex: v === "next" ? r.realIndex : void 0
          });
        }
        if (n) {
          const v = l * r.params.grid.rows;
          l = r.slides.filter((m) => m.getAttribute("data-swiper-slide-index") * 1 === v)[0].column;
        } else
          l = r.getSlideIndexByData(l);
      }
    return requestAnimationFrame(() => {
      r.slideTo(l, e, t, i);
    }), r;
  }
  function ct(s, e, t) {
    s === void 0 && (s = this.params.speed), e === void 0 && (e = !0);
    const i = this, {
      enabled: r,
      params: n,
      animating: l
    } = i;
    if (!r || i.destroyed)
      return i;
    let o = n.slidesPerGroup;
    n.slidesPerView === "auto" && n.slidesPerGroup === 1 && n.slidesPerGroupAuto && (o = Math.max(i.slidesPerViewDynamic("current", !0), 1));
    const a = i.activeIndex < n.slidesPerGroupSkip ? 1 : o, p = i.virtual && n.virtual.enabled;
    if (n.loop) {
      if (l && !p && n.loopPreventsSliding)
        return !1;
      if (i.loopFix({
        direction: "next"
      }), i._clientLeft = i.wrapperEl.clientLeft, i.activeIndex === i.slides.length - 1 && n.cssMode)
        return requestAnimationFrame(() => {
          i.slideTo(i.activeIndex + a, s, e, t);
        }), !0;
    }
    return n.rewind && i.isEnd ? i.slideTo(0, s, e, t) : i.slideTo(i.activeIndex + a, s, e, t);
  }
  function pt(s, e, t) {
    s === void 0 && (s = this.params.speed), e === void 0 && (e = !0);
    const i = this, {
      params: r,
      snapGrid: n,
      slidesGrid: l,
      rtlTranslate: o,
      enabled: a,
      animating: p
    } = i;
    if (!a || i.destroyed)
      return i;
    const c = i.virtual && r.virtual.enabled;
    if (r.loop) {
      if (p && !c && r.loopPreventsSliding)
        return !1;
      i.loopFix({
        direction: "prev"
      }), i._clientLeft = i.wrapperEl.clientLeft;
    }
    const f = o ? i.translate : -i.translate;
    function v(d) {
      return d < 0 ? -Math.floor(Math.abs(d)) : Math.floor(d);
    }
    const m = v(f), h = n.map((d) => v(d));
    let w = n[h.indexOf(m) - 1];
    if (typeof w > "u" && r.cssMode) {
      let d;
      n.forEach((u, g) => {
        m >= u && (d = g);
      }), typeof d < "u" && (w = n[d > 0 ? d - 1 : d]);
    }
    let S = 0;
    if (typeof w < "u" && (S = l.indexOf(w), S < 0 && (S = i.activeIndex - 1), r.slidesPerView === "auto" && r.slidesPerGroup === 1 && r.slidesPerGroupAuto && (S = S - i.slidesPerViewDynamic("previous", !0) + 1, S = Math.max(S, 0))), r.rewind && i.isBeginning) {
      const d = i.params.virtual && i.params.virtual.enabled && i.virtual ? i.virtual.slides.length - 1 : i.slides.length - 1;
      return i.slideTo(d, s, e, t);
    } else if (r.loop && i.activeIndex === 0 && r.cssMode)
      return requestAnimationFrame(() => {
        i.slideTo(S, s, e, t);
      }), !0;
    return i.slideTo(S, s, e, t);
  }
  function ut(s, e, t) {
    s === void 0 && (s = this.params.speed), e === void 0 && (e = !0);
    const i = this;
    if (!i.destroyed)
      return i.slideTo(i.activeIndex, s, e, t);
  }
  function ft(s, e, t, i) {
    s === void 0 && (s = this.params.speed), e === void 0 && (e = !0), i === void 0 && (i = 0.5);
    const r = this;
    if (r.destroyed)
      return;
    let n = r.activeIndex;
    const l = Math.min(r.params.slidesPerGroupSkip, n), o = l + Math.floor((n - l) / r.params.slidesPerGroup), a = r.rtlTranslate ? r.translate : -r.translate;
    if (a >= r.snapGrid[o]) {
      const p = r.snapGrid[o], c = r.snapGrid[o + 1];
      a - p > (c - p) * i && (n += r.params.slidesPerGroup);
    } else {
      const p = r.snapGrid[o - 1], c = r.snapGrid[o];
      a - p <= (c - p) * i && (n -= r.params.slidesPerGroup);
    }
    return n = Math.max(n, 0), n = Math.min(n, r.slidesGrid.length - 1), r.slideTo(n, s, e, t);
  }
  function ht() {
    const s = this;
    if (s.destroyed)
      return;
    const {
      params: e,
      slidesEl: t
    } = s, i = e.slidesPerView === "auto" ? s.slidesPerViewDynamic() : e.slidesPerView;
    let r = s.clickedIndex, n;
    const l = s.isElement ? "swiper-slide" : `.${e.slideClass}`;
    if (e.loop) {
      if (s.animating)
        return;
      n = parseInt(s.clickedSlide.getAttribute("data-swiper-slide-index"), 10), e.centeredSlides ? r < s.loopedSlides - i / 2 || r > s.slides.length - s.loopedSlides + i / 2 ? (s.loopFix(), r = s.getSlideIndex(G(t, `${l}[data-swiper-slide-index="${n}"]`)[0]), J(() => {
        s.slideTo(r);
      })) : s.slideTo(r) : r > s.slides.length - i ? (s.loopFix(), r = s.getSlideIndex(G(t, `${l}[data-swiper-slide-index="${n}"]`)[0]), J(() => {
        s.slideTo(r);
      })) : s.slideTo(r);
    } else
      s.slideTo(r);
  }
  var mt = {
    slideTo: lt,
    slideToLoop: dt,
    slideNext: ct,
    slidePrev: pt,
    slideReset: ut,
    slideToClosest: ft,
    slideToClickedSlide: ht
  };
  function gt(s) {
    const e = this, {
      params: t,
      slidesEl: i
    } = e;
    if (!t.loop || e.virtual && e.params.virtual.enabled)
      return;
    const r = () => {
      G(i, `.${t.slideClass}, swiper-slide`).forEach((f, v) => {
        f.setAttribute("data-swiper-slide-index", v);
      });
    }, n = e.grid && t.grid && t.grid.rows > 1, l = t.slidesPerGroup * (n ? t.grid.rows : 1), o = e.slides.length % l !== 0, a = n && e.slides.length % t.grid.rows !== 0, p = (c) => {
      for (let f = 0; f < c; f += 1) {
        const v = e.isElement ? Y("swiper-slide", [t.slideBlankClass]) : Y("div", [t.slideClass, t.slideBlankClass]);
        e.slidesEl.append(v);
      }
    };
    if (o) {
      if (t.loopAddBlankSlides) {
        const c = l - e.slides.length % l;
        p(c), e.recalcSlides(), e.updateSlides();
      } else
        W("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
      r();
    } else if (a) {
      if (t.loopAddBlankSlides) {
        const c = t.grid.rows - e.slides.length % t.grid.rows;
        p(c), e.recalcSlides(), e.updateSlides();
      } else
        W("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
      r();
    } else
      r();
    e.loopFix({
      slideRealIndex: s,
      direction: t.centeredSlides ? void 0 : "next"
    });
  }
  function vt(s) {
    let {
      slideRealIndex: e,
      slideTo: t = !0,
      direction: i,
      setTranslate: r,
      activeSlideIndex: n,
      byController: l,
      byMousewheel: o
    } = s === void 0 ? {} : s;
    const a = this;
    if (!a.params.loop)
      return;
    a.emit("beforeLoopFix");
    const {
      slides: p,
      allowSlidePrev: c,
      allowSlideNext: f,
      slidesEl: v,
      params: m
    } = a, {
      centeredSlides: h
    } = m;
    if (a.allowSlidePrev = !0, a.allowSlideNext = !0, a.virtual && m.virtual.enabled) {
      t && (!m.centeredSlides && a.snapIndex === 0 ? a.slideTo(a.virtual.slides.length, 0, !1, !0) : m.centeredSlides && a.snapIndex < m.slidesPerView ? a.slideTo(a.virtual.slides.length + a.snapIndex, 0, !1, !0) : a.snapIndex === a.snapGrid.length - 1 && a.slideTo(a.virtual.slidesBefore, 0, !1, !0)), a.allowSlidePrev = c, a.allowSlideNext = f, a.emit("loopFix");
      return;
    }
    let w = m.slidesPerView;
    w === "auto" ? w = a.slidesPerViewDynamic() : (w = Math.ceil(parseFloat(m.slidesPerView, 10)), h && w % 2 === 0 && (w = w + 1));
    const S = m.slidesPerGroupAuto ? w : m.slidesPerGroup;
    let d = S;
    d % S !== 0 && (d += S - d % S), d += m.loopAdditionalSlides, a.loopedSlides = d;
    const u = a.grid && m.grid && m.grid.rows > 1;
    p.length < w + d ? W("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : u && m.grid.fill === "row" && W("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
    const g = [], x = [];
    let y = a.activeIndex;
    typeof n > "u" ? n = a.getSlideIndex(p.filter((T) => T.classList.contains(m.slideActiveClass))[0]) : y = n;
    const M = i === "next" || !i, D = i === "prev" || !i;
    let L = 0, O = 0;
    const b = u ? Math.ceil(p.length / m.grid.rows) : p.length, C = (u ? p[n].column : n) + (h && typeof r > "u" ? -w / 2 + 0.5 : 0);
    if (C < d) {
      L = Math.max(d - C, S);
      for (let T = 0; T < d - C; T += 1) {
        const P = T - Math.floor(T / b) * b;
        if (u) {
          const I = b - P - 1;
          for (let B = p.length - 1; B >= 0; B -= 1)
            p[B].column === I && g.push(B);
        } else
          g.push(b - P - 1);
      }
    } else if (C + w > b - d) {
      O = Math.max(C - (b - d * 2), S);
      for (let T = 0; T < O; T += 1) {
        const P = T - Math.floor(T / b) * b;
        u ? p.forEach((I, B) => {
          I.column === P && x.push(B);
        }) : x.push(P);
      }
    }
    if (a.__preventObserver__ = !0, requestAnimationFrame(() => {
      a.__preventObserver__ = !1;
    }), D && g.forEach((T) => {
      p[T].swiperLoopMoveDOM = !0, v.prepend(p[T]), p[T].swiperLoopMoveDOM = !1;
    }), M && x.forEach((T) => {
      p[T].swiperLoopMoveDOM = !0, v.append(p[T]), p[T].swiperLoopMoveDOM = !1;
    }), a.recalcSlides(), m.slidesPerView === "auto" ? a.updateSlides() : u && (g.length > 0 && D || x.length > 0 && M) && a.slides.forEach((T, P) => {
      a.grid.updateSlide(P, T, a.slides);
    }), m.watchSlidesProgress && a.updateSlidesOffset(), t) {
      if (g.length > 0 && D) {
        if (typeof e > "u") {
          const T = a.slidesGrid[y], I = a.slidesGrid[y + L] - T;
          o ? a.setTranslate(a.translate - I) : (a.slideTo(y + Math.ceil(L), 0, !1, !0), r && (a.touchEventsData.startTranslate = a.touchEventsData.startTranslate - I, a.touchEventsData.currentTranslate = a.touchEventsData.currentTranslate - I));
        } else if (r) {
          const T = u ? g.length / m.grid.rows : g.length;
          a.slideTo(a.activeIndex + T, 0, !1, !0), a.touchEventsData.currentTranslate = a.translate;
        }
      } else if (x.length > 0 && M)
        if (typeof e > "u") {
          const T = a.slidesGrid[y], I = a.slidesGrid[y - O] - T;
          o ? a.setTranslate(a.translate - I) : (a.slideTo(y - O, 0, !1, !0), r && (a.touchEventsData.startTranslate = a.touchEventsData.startTranslate - I, a.touchEventsData.currentTranslate = a.touchEventsData.currentTranslate - I));
        } else {
          const T = u ? x.length / m.grid.rows : x.length;
          a.slideTo(a.activeIndex - T, 0, !1, !0);
        }
    }
    if (a.allowSlidePrev = c, a.allowSlideNext = f, a.controller && a.controller.control && !l) {
      const T = {
        slideRealIndex: e,
        direction: i,
        setTranslate: r,
        activeSlideIndex: n,
        byController: !0
      };
      Array.isArray(a.controller.control) ? a.controller.control.forEach((P) => {
        !P.destroyed && P.params.loop && P.loopFix({
          ...T,
          slideTo: P.params.slidesPerView === m.slidesPerView ? t : !1
        });
      }) : a.controller.control instanceof a.constructor && a.controller.control.params.loop && a.controller.control.loopFix({
        ...T,
        slideTo: a.controller.control.params.slidesPerView === m.slidesPerView ? t : !1
      });
    }
    a.emit("loopFix");
  }
  function wt() {
    const s = this, {
      params: e,
      slidesEl: t
    } = s;
    if (!e.loop || s.virtual && s.params.virtual.enabled)
      return;
    s.recalcSlides();
    const i = [];
    s.slides.forEach((r) => {
      const n = typeof r.swiperSlideIndex > "u" ? r.getAttribute("data-swiper-slide-index") * 1 : r.swiperSlideIndex;
      i[n] = r;
    }), s.slides.forEach((r) => {
      r.removeAttribute("data-swiper-slide-index");
    }), i.forEach((r) => {
      t.append(r);
    }), s.recalcSlides(), s.slideTo(s.realIndex, 0);
  }
  var xt = {
    loopCreate: gt,
    loopFix: vt,
    loopDestroy: wt
  };
  function bt(s) {
    const e = this;
    if (!e.params.simulateTouch || e.params.watchOverflow && e.isLocked || e.params.cssMode)
      return;
    const t = e.params.touchEventsTarget === "container" ? e.el : e.wrapperEl;
    e.isElement && (e.__preventObserver__ = !0), t.style.cursor = "move", t.style.cursor = s ? "grabbing" : "grab", e.isElement && requestAnimationFrame(() => {
      e.__preventObserver__ = !1;
    });
  }
  function St() {
    const s = this;
    s.params.watchOverflow && s.isLocked || s.params.cssMode || (s.isElement && (s.__preventObserver__ = !0), s[s.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "", s.isElement && requestAnimationFrame(() => {
      s.__preventObserver__ = !1;
    }));
  }
  var yt = {
    setGrabCursor: bt,
    unsetGrabCursor: St
  };
  function Tt(s, e) {
    e === void 0 && (e = this);
    function t(i) {
      if (!i || i === H() || i === k())
        return null;
      i.assignedSlot && (i = i.assignedSlot);
      const r = i.closest(s);
      return !r && !i.getRootNode ? null : r || t(i.getRootNode().host);
    }
    return t(e);
  }
  function me(s, e, t) {
    const i = k(), {
      params: r
    } = s, n = r.edgeSwipeDetection, l = r.edgeSwipeThreshold;
    return n && (t <= l || t >= i.innerWidth - l) ? n === "prevent" ? (e.preventDefault(), !0) : !1 : !0;
  }
  function Ct(s) {
    const e = this, t = H();
    let i = s;
    i.originalEvent && (i = i.originalEvent);
    const r = e.touchEventsData;
    if (i.type === "pointerdown") {
      if (r.pointerId !== null && r.pointerId !== i.pointerId)
        return;
      r.pointerId = i.pointerId;
    } else
      i.type === "touchstart" && i.targetTouches.length === 1 && (r.touchId = i.targetTouches[0].identifier);
    if (i.type === "touchstart") {
      me(e, i, i.targetTouches[0].pageX);
      return;
    }
    const {
      params: n,
      touches: l,
      enabled: o
    } = e;
    if (!o || !n.simulateTouch && i.pointerType === "mouse" || e.animating && n.preventInteractionOnTransition)
      return;
    !e.animating && n.cssMode && n.loop && e.loopFix();
    let a = i.target;
    if (n.touchEventsTarget === "wrapper" && !e.wrapperEl.contains(a) || "which" in i && i.which === 3 || "button" in i && i.button > 0 || r.isTouched && r.isMoved)
      return;
    const p = !!n.noSwipingClass && n.noSwipingClass !== "", c = i.composedPath ? i.composedPath() : i.path;
    p && i.target && i.target.shadowRoot && c && (a = c[0]);
    const f = n.noSwipingSelector ? n.noSwipingSelector : `.${n.noSwipingClass}`, v = !!(i.target && i.target.shadowRoot);
    if (n.noSwiping && (v ? Tt(f, a) : a.closest(f))) {
      e.allowClick = !0;
      return;
    }
    if (n.swipeHandler && !a.closest(n.swipeHandler))
      return;
    l.currentX = i.pageX, l.currentY = i.pageY;
    const m = l.currentX, h = l.currentY;
    if (!me(e, i, m))
      return;
    Object.assign(r, {
      isTouched: !0,
      isMoved: !1,
      allowTouchCallbacks: !0,
      isScrolling: void 0,
      startMoving: void 0
    }), l.startX = m, l.startY = h, r.touchStartTime = R(), e.allowClick = !0, e.updateSize(), e.swipeDirection = void 0, n.threshold > 0 && (r.allowThresholdMove = !1);
    let w = !0;
    a.matches(r.focusableElements) && (w = !1, a.nodeName === "SELECT" && (r.isTouched = !1)), t.activeElement && t.activeElement.matches(r.focusableElements) && t.activeElement !== a && t.activeElement.blur();
    const S = w && e.allowTouchMove && n.touchStartPreventDefault;
    (n.touchStartForcePreventDefault || S) && !a.isContentEditable && i.preventDefault(), n.freeMode && n.freeMode.enabled && e.freeMode && e.animating && !n.cssMode && e.freeMode.onTouchStart(), e.emit("touchStart", i);
  }
  function Et(s) {
    const e = H(), t = this, i = t.touchEventsData, {
      params: r,
      touches: n,
      rtlTranslate: l,
      enabled: o
    } = t;
    if (!o || !r.simulateTouch && s.pointerType === "mouse")
      return;
    let a = s;
    if (a.originalEvent && (a = a.originalEvent), a.type === "pointermove" && (i.touchId !== null || a.pointerId !== i.pointerId))
      return;
    let p;
    if (a.type === "touchmove") {
      if (p = [...a.changedTouches].filter((M) => M.identifier === i.touchId)[0], !p || p.identifier !== i.touchId)
        return;
    } else
      p = a;
    if (!i.isTouched) {
      i.startMoving && i.isScrolling && t.emit("touchMoveOpposite", a);
      return;
    }
    const c = p.pageX, f = p.pageY;
    if (a.preventedByNestedSwiper) {
      n.startX = c, n.startY = f;
      return;
    }
    if (!t.allowTouchMove) {
      a.target.matches(i.focusableElements) || (t.allowClick = !1), i.isTouched && (Object.assign(n, {
        startX: c,
        startY: f,
        currentX: c,
        currentY: f
      }), i.touchStartTime = R());
      return;
    }
    if (r.touchReleaseOnEdges && !r.loop) {
      if (t.isVertical()) {
        if (f < n.startY && t.translate <= t.maxTranslate() || f > n.startY && t.translate >= t.minTranslate()) {
          i.isTouched = !1, i.isMoved = !1;
          return;
        }
      } else if (c < n.startX && t.translate <= t.maxTranslate() || c > n.startX && t.translate >= t.minTranslate())
        return;
    }
    if (e.activeElement && a.target === e.activeElement && a.target.matches(i.focusableElements)) {
      i.isMoved = !0, t.allowClick = !1;
      return;
    }
    i.allowTouchCallbacks && t.emit("touchMove", a), n.previousX = n.currentX, n.previousY = n.currentY, n.currentX = c, n.currentY = f;
    const v = n.currentX - n.startX, m = n.currentY - n.startY;
    if (t.params.threshold && Math.sqrt(v ** 2 + m ** 2) < t.params.threshold)
      return;
    if (typeof i.isScrolling > "u") {
      let M;
      t.isHorizontal() && n.currentY === n.startY || t.isVertical() && n.currentX === n.startX ? i.isScrolling = !1 : v * v + m * m >= 25 && (M = Math.atan2(Math.abs(m), Math.abs(v)) * 180 / Math.PI, i.isScrolling = t.isHorizontal() ? M > r.touchAngle : 90 - M > r.touchAngle);
    }
    if (i.isScrolling && t.emit("touchMoveOpposite", a), typeof i.startMoving > "u" && (n.currentX !== n.startX || n.currentY !== n.startY) && (i.startMoving = !0), i.isScrolling) {
      i.isTouched = !1;
      return;
    }
    if (!i.startMoving)
      return;
    t.allowClick = !1, !r.cssMode && a.cancelable && a.preventDefault(), r.touchMoveStopPropagation && !r.nested && a.stopPropagation();
    let h = t.isHorizontal() ? v : m, w = t.isHorizontal() ? n.currentX - n.previousX : n.currentY - n.previousY;
    r.oneWayMovement && (h = Math.abs(h) * (l ? 1 : -1), w = Math.abs(w) * (l ? 1 : -1)), n.diff = h, h *= r.touchRatio, l && (h = -h, w = -w);
    const S = t.touchesDirection;
    t.swipeDirection = h > 0 ? "prev" : "next", t.touchesDirection = w > 0 ? "prev" : "next";
    const d = t.params.loop && !r.cssMode, u = t.touchesDirection === "next" && t.allowSlideNext || t.touchesDirection === "prev" && t.allowSlidePrev;
    if (!i.isMoved) {
      if (d && u && t.loopFix({
        direction: t.swipeDirection
      }), i.startTranslate = t.getTranslate(), t.setTransition(0), t.animating) {
        const M = new window.CustomEvent("transitionend", {
          bubbles: !0,
          cancelable: !0
        });
        t.wrapperEl.dispatchEvent(M);
      }
      i.allowMomentumBounce = !1, r.grabCursor && (t.allowSlideNext === !0 || t.allowSlidePrev === !0) && t.setGrabCursor(!0), t.emit("sliderFirstMove", a);
    }
    let g;
    if ((/* @__PURE__ */ new Date()).getTime(), i.isMoved && i.allowThresholdMove && S !== t.touchesDirection && d && u && Math.abs(h) >= 1) {
      Object.assign(n, {
        startX: c,
        startY: f,
        currentX: c,
        currentY: f,
        startTranslate: i.currentTranslate
      }), i.loopSwapReset = !0, i.startTranslate = i.currentTranslate;
      return;
    }
    t.emit("sliderMove", a), i.isMoved = !0, i.currentTranslate = h + i.startTranslate;
    let x = !0, y = r.resistanceRatio;
    if (r.touchReleaseOnEdges && (y = 0), h > 0 ? (d && u && !g && i.allowThresholdMove && i.currentTranslate > (r.centeredSlides ? t.minTranslate() - t.slidesSizesGrid[t.activeIndex + 1] : t.minTranslate()) && t.loopFix({
      direction: "prev",
      setTranslate: !0,
      activeSlideIndex: 0
    }), i.currentTranslate > t.minTranslate() && (x = !1, r.resistance && (i.currentTranslate = t.minTranslate() - 1 + (-t.minTranslate() + i.startTranslate + h) ** y))) : h < 0 && (d && u && !g && i.allowThresholdMove && i.currentTranslate < (r.centeredSlides ? t.maxTranslate() + t.slidesSizesGrid[t.slidesSizesGrid.length - 1] : t.maxTranslate()) && t.loopFix({
      direction: "next",
      setTranslate: !0,
      activeSlideIndex: t.slides.length - (r.slidesPerView === "auto" ? t.slidesPerViewDynamic() : Math.ceil(parseFloat(r.slidesPerView, 10)))
    }), i.currentTranslate < t.maxTranslate() && (x = !1, r.resistance && (i.currentTranslate = t.maxTranslate() + 1 - (t.maxTranslate() - i.startTranslate - h) ** y))), x && (a.preventedByNestedSwiper = !0), !t.allowSlideNext && t.swipeDirection === "next" && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !t.allowSlidePrev && t.swipeDirection === "prev" && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), !t.allowSlidePrev && !t.allowSlideNext && (i.currentTranslate = i.startTranslate), r.threshold > 0)
      if (Math.abs(h) > r.threshold || i.allowThresholdMove) {
        if (!i.allowThresholdMove) {
          i.allowThresholdMove = !0, n.startX = n.currentX, n.startY = n.currentY, i.currentTranslate = i.startTranslate, n.diff = t.isHorizontal() ? n.currentX - n.startX : n.currentY - n.startY;
          return;
        }
      } else {
        i.currentTranslate = i.startTranslate;
        return;
      }
    !r.followFinger || r.cssMode || ((r.freeMode && r.freeMode.enabled && t.freeMode || r.watchSlidesProgress) && (t.updateActiveIndex(), t.updateSlidesClasses()), r.freeMode && r.freeMode.enabled && t.freeMode && t.freeMode.onTouchMove(), t.updateProgress(i.currentTranslate), t.setTranslate(i.currentTranslate));
  }
  function Lt(s) {
    const e = this, t = e.touchEventsData;
    let i = s;
    i.originalEvent && (i = i.originalEvent);
    let r;
    if (i.type === "touchend" || i.type === "touchcancel") {
      if (r = [...i.changedTouches].filter((y) => y.identifier === t.touchId)[0], !r || r.identifier !== t.touchId)
        return;
    } else {
      if (t.touchId !== null || i.pointerId !== t.pointerId)
        return;
      r = i;
    }
    if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(i.type) && !(["pointercancel", "contextmenu"].includes(i.type) && (e.browser.isSafari || e.browser.isWebView)))
      return;
    t.pointerId = null, t.touchId = null;
    const {
      params: l,
      touches: o,
      rtlTranslate: a,
      slidesGrid: p,
      enabled: c
    } = e;
    if (!c || !l.simulateTouch && i.pointerType === "mouse")
      return;
    if (t.allowTouchCallbacks && e.emit("touchEnd", i), t.allowTouchCallbacks = !1, !t.isTouched) {
      t.isMoved && l.grabCursor && e.setGrabCursor(!1), t.isMoved = !1, t.startMoving = !1;
      return;
    }
    l.grabCursor && t.isMoved && t.isTouched && (e.allowSlideNext === !0 || e.allowSlidePrev === !0) && e.setGrabCursor(!1);
    const f = R(), v = f - t.touchStartTime;
    if (e.allowClick) {
      const y = i.path || i.composedPath && i.composedPath();
      e.updateClickedSlide(y && y[0] || i.target, y), e.emit("tap click", i), v < 300 && f - t.lastClickTime < 300 && e.emit("doubleTap doubleClick", i);
    }
    if (t.lastClickTime = R(), J(() => {
      e.destroyed || (e.allowClick = !0);
    }), !t.isTouched || !t.isMoved || !e.swipeDirection || o.diff === 0 && !t.loopSwapReset || t.currentTranslate === t.startTranslate && !t.loopSwapReset) {
      t.isTouched = !1, t.isMoved = !1, t.startMoving = !1;
      return;
    }
    t.isTouched = !1, t.isMoved = !1, t.startMoving = !1;
    let m;
    if (l.followFinger ? m = a ? e.translate : -e.translate : m = -t.currentTranslate, l.cssMode)
      return;
    if (l.freeMode && l.freeMode.enabled) {
      e.freeMode.onTouchEnd({
        currentPos: m
      });
      return;
    }
    const h = m >= -e.maxTranslate() && !e.params.loop;
    let w = 0, S = e.slidesSizesGrid[0];
    for (let y = 0; y < p.length; y += y < l.slidesPerGroupSkip ? 1 : l.slidesPerGroup) {
      const M = y < l.slidesPerGroupSkip - 1 ? 1 : l.slidesPerGroup;
      typeof p[y + M] < "u" ? (h || m >= p[y] && m < p[y + M]) && (w = y, S = p[y + M] - p[y]) : (h || m >= p[y]) && (w = y, S = p[p.length - 1] - p[p.length - 2]);
    }
    let d = null, u = null;
    l.rewind && (e.isBeginning ? u = l.virtual && l.virtual.enabled && e.virtual ? e.virtual.slides.length - 1 : e.slides.length - 1 : e.isEnd && (d = 0));
    const g = (m - p[w]) / S, x = w < l.slidesPerGroupSkip - 1 ? 1 : l.slidesPerGroup;
    if (v > l.longSwipesMs) {
      if (!l.longSwipes) {
        e.slideTo(e.activeIndex);
        return;
      }
      e.swipeDirection === "next" && (g >= l.longSwipesRatio ? e.slideTo(l.rewind && e.isEnd ? d : w + x) : e.slideTo(w)), e.swipeDirection === "prev" && (g > 1 - l.longSwipesRatio ? e.slideTo(w + x) : u !== null && g < 0 && Math.abs(g) > l.longSwipesRatio ? e.slideTo(u) : e.slideTo(w));
    } else {
      if (!l.shortSwipes) {
        e.slideTo(e.activeIndex);
        return;
      }
      e.navigation && (i.target === e.navigation.nextEl || i.target === e.navigation.prevEl) ? i.target === e.navigation.nextEl ? e.slideTo(w + x) : e.slideTo(w) : (e.swipeDirection === "next" && e.slideTo(d !== null ? d : w + x), e.swipeDirection === "prev" && e.slideTo(u !== null ? u : w));
    }
  }
  function ge() {
    const s = this, {
      params: e,
      el: t
    } = s;
    if (t && t.offsetWidth === 0)
      return;
    e.breakpoints && s.setBreakpoint();
    const {
      allowSlideNext: i,
      allowSlidePrev: r,
      snapGrid: n
    } = s, l = s.virtual && s.params.virtual.enabled;
    s.allowSlideNext = !0, s.allowSlidePrev = !0, s.updateSize(), s.updateSlides(), s.updateSlidesClasses();
    const o = l && e.loop;
    (e.slidesPerView === "auto" || e.slidesPerView > 1) && s.isEnd && !s.isBeginning && !s.params.centeredSlides && !o ? s.slideTo(s.slides.length - 1, 0, !1, !0) : s.params.loop && !l ? s.slideToLoop(s.realIndex, 0, !1, !0) : s.slideTo(s.activeIndex, 0, !1, !0), s.autoplay && s.autoplay.running && s.autoplay.paused && (clearTimeout(s.autoplay.resizeTimeout), s.autoplay.resizeTimeout = setTimeout(() => {
      s.autoplay && s.autoplay.running && s.autoplay.paused && s.autoplay.resume();
    }, 500)), s.allowSlidePrev = r, s.allowSlideNext = i, s.params.watchOverflow && n !== s.snapGrid && s.checkOverflow();
  }
  function Pt(s) {
    const e = this;
    e.enabled && (e.allowClick || (e.params.preventClicks && s.preventDefault(), e.params.preventClicksPropagation && e.animating && (s.stopPropagation(), s.stopImmediatePropagation())));
  }
  function Mt() {
    const s = this, {
      wrapperEl: e,
      rtlTranslate: t,
      enabled: i
    } = s;
    if (!i)
      return;
    s.previousTranslate = s.translate, s.isHorizontal() ? s.translate = -e.scrollLeft : s.translate = -e.scrollTop, s.translate === 0 && (s.translate = 0), s.updateActiveIndex(), s.updateSlidesClasses();
    let r;
    const n = s.maxTranslate() - s.minTranslate();
    n === 0 ? r = 0 : r = (s.translate - s.minTranslate()) / n, r !== s.progress && s.updateProgress(t ? -s.translate : s.translate), s.emit("setTranslate", s.translate, !1);
  }
  function It(s) {
    const e = this;
    Z(e, s.target), !(e.params.cssMode || e.params.slidesPerView !== "auto" && !e.params.autoHeight) && e.update();
  }
  function At() {
    const s = this;
    s.documentTouchHandlerProceeded || (s.documentTouchHandlerProceeded = !0, s.params.touchReleaseOnEdges && (s.el.style.touchAction = "auto"));
  }
  const ve = (s, e) => {
    const t = H(), {
      params: i,
      el: r,
      wrapperEl: n,
      device: l
    } = s, o = !!i.nested, a = e === "on" ? "addEventListener" : "removeEventListener", p = e;
    t[a]("touchstart", s.onDocumentTouchStart, {
      passive: !1,
      capture: o
    }), r[a]("touchstart", s.onTouchStart, {
      passive: !1
    }), r[a]("pointerdown", s.onTouchStart, {
      passive: !1
    }), t[a]("touchmove", s.onTouchMove, {
      passive: !1,
      capture: o
    }), t[a]("pointermove", s.onTouchMove, {
      passive: !1,
      capture: o
    }), t[a]("touchend", s.onTouchEnd, {
      passive: !0
    }), t[a]("pointerup", s.onTouchEnd, {
      passive: !0
    }), t[a]("pointercancel", s.onTouchEnd, {
      passive: !0
    }), t[a]("touchcancel", s.onTouchEnd, {
      passive: !0
    }), t[a]("pointerout", s.onTouchEnd, {
      passive: !0
    }), t[a]("pointerleave", s.onTouchEnd, {
      passive: !0
    }), t[a]("contextmenu", s.onTouchEnd, {
      passive: !0
    }), (i.preventClicks || i.preventClicksPropagation) && r[a]("click", s.onClick, !0), i.cssMode && n[a]("scroll", s.onScroll), i.updateOnWindowResize ? s[p](l.ios || l.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", ge, !0) : s[p]("observerUpdate", ge, !0), r[a]("load", s.onLoad, {
      capture: !0
    });
  };
  function Ot() {
    const s = this, {
      params: e
    } = s;
    s.onTouchStart = Ct.bind(s), s.onTouchMove = Et.bind(s), s.onTouchEnd = Lt.bind(s), s.onDocumentTouchStart = At.bind(s), e.cssMode && (s.onScroll = Mt.bind(s)), s.onClick = Pt.bind(s), s.onLoad = It.bind(s), ve(s, "on");
  }
  function kt() {
    ve(this, "off");
  }
  var zt = {
    attachEvents: Ot,
    detachEvents: kt
  };
  const we = (s, e) => s.grid && e.grid && e.grid.rows > 1;
  function $t() {
    const s = this, {
      realIndex: e,
      initialized: t,
      params: i,
      el: r
    } = s, n = i.breakpoints;
    if (!n || n && Object.keys(n).length === 0)
      return;
    const l = s.getBreakpoint(n, s.params.breakpointsBase, s.el);
    if (!l || s.currentBreakpoint === l)
      return;
    const a = (l in n ? n[l] : void 0) || s.originalParams, p = we(s, i), c = we(s, a), f = i.enabled;
    p && !c ? (r.classList.remove(`${i.containerModifierClass}grid`, `${i.containerModifierClass}grid-column`), s.emitContainerClasses()) : !p && c && (r.classList.add(`${i.containerModifierClass}grid`), (a.grid.fill && a.grid.fill === "column" || !a.grid.fill && i.grid.fill === "column") && r.classList.add(`${i.containerModifierClass}grid-column`), s.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach((d) => {
      if (typeof a[d] > "u")
        return;
      const u = i[d] && i[d].enabled, g = a[d] && a[d].enabled;
      u && !g && s[d].disable(), !u && g && s[d].enable();
    });
    const v = a.direction && a.direction !== i.direction, m = i.loop && (a.slidesPerView !== i.slidesPerView || v), h = i.loop;
    v && t && s.changeDirection(), z(s.params, a);
    const w = s.params.enabled, S = s.params.loop;
    Object.assign(s, {
      allowTouchMove: s.params.allowTouchMove,
      allowSlideNext: s.params.allowSlideNext,
      allowSlidePrev: s.params.allowSlidePrev
    }), f && !w ? s.disable() : !f && w && s.enable(), s.currentBreakpoint = l, s.emit("_beforeBreakpoint", a), t && (m ? (s.loopDestroy(), s.loopCreate(e), s.updateSlides()) : !h && S ? (s.loopCreate(e), s.updateSlides()) : h && !S && s.loopDestroy()), s.emit("breakpoint", a);
  }
  function Dt(s, e, t) {
    if (e === void 0 && (e = "window"), !s || e === "container" && !t)
      return;
    let i = !1;
    const r = k(), n = e === "window" ? r.innerHeight : t.clientHeight, l = Object.keys(s).map((o) => {
      if (typeof o == "string" && o.indexOf("@") === 0) {
        const a = parseFloat(o.substr(1));
        return {
          value: n * a,
          point: o
        };
      }
      return {
        value: o,
        point: o
      };
    });
    l.sort((o, a) => parseInt(o.value, 10) - parseInt(a.value, 10));
    for (let o = 0; o < l.length; o += 1) {
      const {
        point: a,
        value: p
      } = l[o];
      e === "window" ? r.matchMedia(`(min-width: ${p}px)`).matches && (i = a) : p <= t.clientWidth && (i = a);
    }
    return i || "max";
  }
  var Gt = {
    setBreakpoint: $t,
    getBreakpoint: Dt
  };
  function _t(s, e) {
    const t = [];
    return s.forEach((i) => {
      typeof i == "object" ? Object.keys(i).forEach((r) => {
        i[r] && t.push(e + r);
      }) : typeof i == "string" && t.push(e + i);
    }), t;
  }
  function Bt() {
    const s = this, {
      classNames: e,
      params: t,
      rtl: i,
      el: r,
      device: n
    } = s, l = _t(["initialized", t.direction, {
      "free-mode": s.params.freeMode && t.freeMode.enabled
    }, {
      autoheight: t.autoHeight
    }, {
      rtl: i
    }, {
      grid: t.grid && t.grid.rows > 1
    }, {
      "grid-column": t.grid && t.grid.rows > 1 && t.grid.fill === "column"
    }, {
      android: n.android
    }, {
      ios: n.ios
    }, {
      "css-mode": t.cssMode
    }, {
      centered: t.cssMode && t.centeredSlides
    }, {
      "watch-progress": t.watchSlidesProgress
    }], t.containerModifierClass);
    e.push(...l), r.classList.add(...e), s.emitContainerClasses();
  }
  function Vt() {
    const s = this, {
      el: e,
      classNames: t
    } = s;
    e.classList.remove(...t), s.emitContainerClasses();
  }
  var Ht = {
    addClasses: Bt,
    removeClasses: Vt
  };
  function Ft() {
    const s = this, {
      isLocked: e,
      params: t
    } = s, {
      slidesOffsetBefore: i
    } = t;
    if (i) {
      const r = s.slides.length - 1, n = s.slidesGrid[r] + s.slidesSizesGrid[r] + i * 2;
      s.isLocked = s.size > n;
    } else
      s.isLocked = s.snapGrid.length === 1;
    t.allowSlideNext === !0 && (s.allowSlideNext = !s.isLocked), t.allowSlidePrev === !0 && (s.allowSlidePrev = !s.isLocked), e && e !== s.isLocked && (s.isEnd = !1), e !== s.isLocked && s.emit(s.isLocked ? "lock" : "unlock");
  }
  var Nt = {
    checkOverflow: Ft
  }, xe = {
    init: !0,
    direction: "horizontal",
    oneWayMovement: !1,
    swiperElementNodeName: "SWIPER-CONTAINER",
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: !1,
    updateOnWindowResize: !0,
    resizeObserver: !0,
    nested: !1,
    createElements: !1,
    eventsPrefix: "swiper",
    enabled: !0,
    focusableElements: "input, select, option, textarea, button, video, label",
    // Overrides
    width: null,
    height: null,
    //
    preventInteractionOnTransition: !1,
    // ssr
    userAgent: null,
    url: null,
    // To support iOS's swipe-to-go-back gesture (when being used in-app).
    edgeSwipeDetection: !1,
    edgeSwipeThreshold: 20,
    // Autoheight
    autoHeight: !1,
    // Set wrapper width
    setWrapperSize: !1,
    // Virtual Translate
    virtualTranslate: !1,
    // Effects
    effect: "slide",
    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
    // Breakpoints
    breakpoints: void 0,
    breakpointsBase: "window",
    // Slides grid
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: !1,
    centeredSlides: !1,
    centeredSlidesBounds: !1,
    slidesOffsetBefore: 0,
    // in px
    slidesOffsetAfter: 0,
    // in px
    normalizeSlideIndex: !0,
    centerInsufficientSlides: !1,
    // Disable swiper and hide navigation when container not overflow
    watchOverflow: !0,
    // Round length
    roundLengths: !1,
    // Touches
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: !0,
    shortSwipes: !0,
    longSwipes: !0,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: !0,
    allowTouchMove: !0,
    threshold: 5,
    touchMoveStopPropagation: !1,
    touchStartPreventDefault: !0,
    touchStartForcePreventDefault: !1,
    touchReleaseOnEdges: !1,
    // Unique Navigation Elements
    uniqueNavElements: !0,
    // Resistance
    resistance: !0,
    resistanceRatio: 0.85,
    // Progress
    watchSlidesProgress: !1,
    // Cursor
    grabCursor: !1,
    // Clicks
    preventClicks: !0,
    preventClicksPropagation: !0,
    slideToClickedSlide: !1,
    // loop
    loop: !1,
    loopAddBlankSlides: !0,
    loopAdditionalSlides: 0,
    loopPreventsSliding: !0,
    // rewind
    rewind: !1,
    // Swiping/no swiping
    allowSlidePrev: !0,
    allowSlideNext: !0,
    swipeHandler: null,
    // '.swipe-handler',
    noSwiping: !0,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    // Passive Listeners
    passiveListeners: !0,
    maxBackfaceHiddenSlides: 10,
    // NS
    containerModifierClass: "swiper-",
    // NEW
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-blank",
    slideActiveClass: "swiper-slide-active",
    slideVisibleClass: "swiper-slide-visible",
    slideFullyVisibleClass: "swiper-slide-fully-visible",
    slideNextClass: "swiper-slide-next",
    slidePrevClass: "swiper-slide-prev",
    wrapperClass: "swiper-wrapper",
    lazyPreloaderClass: "swiper-lazy-preloader",
    lazyPreloadPrevNext: 0,
    // Callbacks
    runCallbacksOnInit: !0,
    // Internals
    _emitClasses: !1
  };
  function Rt(s, e) {
    return function(i) {
      i === void 0 && (i = {});
      const r = Object.keys(i)[0], n = i[r];
      if (typeof n != "object" || n === null) {
        z(e, i);
        return;
      }
      if (s[r] === !0 && (s[r] = {
        enabled: !0
      }), r === "navigation" && s[r] && s[r].enabled && !s[r].prevEl && !s[r].nextEl && (s[r].auto = !0), ["pagination", "scrollbar"].indexOf(r) >= 0 && s[r] && s[r].enabled && !s[r].el && (s[r].auto = !0), !(r in s && "enabled" in n)) {
        z(e, i);
        return;
      }
      typeof s[r] == "object" && !("enabled" in s[r]) && (s[r].enabled = !0), s[r] || (s[r] = {
        enabled: !1
      }), z(e, i);
    };
  }
  const re = {
    eventsEmitter: He,
    update: Ke,
    translate: it,
    transition: ot,
    slide: mt,
    loop: xt,
    grabCursor: yt,
    events: zt,
    breakpoints: Gt,
    checkOverflow: Nt,
    classes: Ht
  }, ae = {};
  class $ {
    constructor() {
      let e, t;
      for (var i = arguments.length, r = new Array(i), n = 0; n < i; n++)
        r[n] = arguments[n];
      r.length === 1 && r[0].constructor && Object.prototype.toString.call(r[0]).slice(8, -1) === "Object" ? t = r[0] : [e, t] = r, t || (t = {}), t = z({}, t), e && !t.el && (t.el = e);
      const l = H();
      if (t.el && typeof t.el == "string" && l.querySelectorAll(t.el).length > 1) {
        const c = [];
        return l.querySelectorAll(t.el).forEach((f) => {
          const v = z({}, t, {
            el: f
          });
          c.push(new $(v));
        }), c;
      }
      const o = this;
      o.__swiper__ = !0, o.support = ue(), o.device = fe({
        userAgent: t.userAgent
      }), o.browser = _e(), o.eventsListeners = {}, o.eventsAnyListeners = [], o.modules = [...o.__modules__], t.modules && Array.isArray(t.modules) && o.modules.push(...t.modules);
      const a = {};
      o.modules.forEach((c) => {
        c({
          params: t,
          swiper: o,
          extendParams: Rt(t, a),
          on: o.on.bind(o),
          once: o.once.bind(o),
          off: o.off.bind(o),
          emit: o.emit.bind(o)
        });
      });
      const p = z({}, xe, a);
      return o.params = z({}, p, ae, t), o.originalParams = z({}, o.params), o.passedParams = z({}, t), o.params && o.params.on && Object.keys(o.params.on).forEach((c) => {
        o.on(c, o.params.on[c]);
      }), o.params && o.params.onAny && o.onAny(o.params.onAny), Object.assign(o, {
        enabled: o.params.enabled,
        el: e,
        // Classes
        classNames: [],
        // Slides
        slides: [],
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],
        // isDirection
        isHorizontal() {
          return o.params.direction === "horizontal";
        },
        isVertical() {
          return o.params.direction === "vertical";
        },
        // Indexes
        activeIndex: 0,
        realIndex: 0,
        //
        isBeginning: !0,
        isEnd: !1,
        // Props
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: !1,
        cssOverflowAdjustment() {
          return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
        },
        // Locks
        allowSlideNext: o.params.allowSlideNext,
        allowSlidePrev: o.params.allowSlidePrev,
        // Touch Events
        touchEventsData: {
          isTouched: void 0,
          isMoved: void 0,
          allowTouchCallbacks: void 0,
          touchStartTime: void 0,
          isScrolling: void 0,
          currentTranslate: void 0,
          startTranslate: void 0,
          allowThresholdMove: void 0,
          // Form elements to match
          focusableElements: o.params.focusableElements,
          // Last click time
          lastClickTime: 0,
          clickTimeout: void 0,
          // Velocities
          velocities: [],
          allowMomentumBounce: void 0,
          startMoving: void 0,
          pointerId: null,
          touchId: null
        },
        // Clicks
        allowClick: !0,
        // Touches
        allowTouchMove: o.params.allowTouchMove,
        touches: {
          startX: 0,
          startY: 0,
          currentX: 0,
          currentY: 0,
          diff: 0
        },
        // Images
        imagesToLoad: [],
        imagesLoaded: 0
      }), o.emit("_swiper"), o.params.init && o.init(), o;
    }
    getDirectionLabel(e) {
      return this.isHorizontal() ? e : {
        width: "height",
        "margin-top": "margin-left",
        "margin-bottom ": "margin-right",
        "margin-left": "margin-top",
        "margin-right": "margin-bottom",
        "padding-left": "padding-top",
        "padding-right": "padding-bottom",
        marginRight: "marginBottom"
      }[e];
    }
    getSlideIndex(e) {
      const {
        slidesEl: t,
        params: i
      } = this, r = G(t, `.${i.slideClass}, swiper-slide`), n = X(r[0]);
      return X(e) - n;
    }
    getSlideIndexByData(e) {
      return this.getSlideIndex(this.slides.filter((t) => t.getAttribute("data-swiper-slide-index") * 1 === e)[0]);
    }
    recalcSlides() {
      const e = this, {
        slidesEl: t,
        params: i
      } = e;
      e.slides = G(t, `.${i.slideClass}, swiper-slide`);
    }
    enable() {
      const e = this;
      e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable"));
    }
    disable() {
      const e = this;
      e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable"));
    }
    setProgress(e, t) {
      const i = this;
      e = Math.min(Math.max(e, 0), 1);
      const r = i.minTranslate(), l = (i.maxTranslate() - r) * e + r;
      i.translateTo(l, typeof t > "u" ? 0 : t), i.updateActiveIndex(), i.updateSlidesClasses();
    }
    emitContainerClasses() {
      const e = this;
      if (!e.params._emitClasses || !e.el)
        return;
      const t = e.el.className.split(" ").filter((i) => i.indexOf("swiper") === 0 || i.indexOf(e.params.containerModifierClass) === 0);
      e.emit("_containerClasses", t.join(" "));
    }
    getSlideClasses(e) {
      const t = this;
      return t.destroyed ? "" : e.className.split(" ").filter((i) => i.indexOf("swiper-slide") === 0 || i.indexOf(t.params.slideClass) === 0).join(" ");
    }
    emitSlidesClasses() {
      const e = this;
      if (!e.params._emitClasses || !e.el)
        return;
      const t = [];
      e.slides.forEach((i) => {
        const r = e.getSlideClasses(i);
        t.push({
          slideEl: i,
          classNames: r
        }), e.emit("_slideClass", i, r);
      }), e.emit("_slideClasses", t);
    }
    slidesPerViewDynamic(e, t) {
      e === void 0 && (e = "current"), t === void 0 && (t = !1);
      const i = this, {
        params: r,
        slides: n,
        slidesGrid: l,
        slidesSizesGrid: o,
        size: a,
        activeIndex: p
      } = i;
      let c = 1;
      if (typeof r.slidesPerView == "number")
        return r.slidesPerView;
      if (r.centeredSlides) {
        let f = n[p] ? Math.ceil(n[p].swiperSlideSize) : 0, v;
        for (let m = p + 1; m < n.length; m += 1)
          n[m] && !v && (f += Math.ceil(n[m].swiperSlideSize), c += 1, f > a && (v = !0));
        for (let m = p - 1; m >= 0; m -= 1)
          n[m] && !v && (f += n[m].swiperSlideSize, c += 1, f > a && (v = !0));
      } else if (e === "current")
        for (let f = p + 1; f < n.length; f += 1)
          (t ? l[f] + o[f] - l[p] < a : l[f] - l[p] < a) && (c += 1);
      else
        for (let f = p - 1; f >= 0; f -= 1)
          l[p] - l[f] < a && (c += 1);
      return c;
    }
    update() {
      const e = this;
      if (!e || e.destroyed)
        return;
      const {
        snapGrid: t,
        params: i
      } = e;
      i.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading="lazy"]')].forEach((l) => {
        l.complete && Z(e, l);
      }), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses();
      function r() {
        const l = e.rtlTranslate ? e.translate * -1 : e.translate, o = Math.min(Math.max(l, e.maxTranslate()), e.minTranslate());
        e.setTranslate(o), e.updateActiveIndex(), e.updateSlidesClasses();
      }
      let n;
      if (i.freeMode && i.freeMode.enabled && !i.cssMode)
        r(), i.autoHeight && e.updateAutoHeight();
      else {
        if ((i.slidesPerView === "auto" || i.slidesPerView > 1) && e.isEnd && !i.centeredSlides) {
          const l = e.virtual && i.virtual.enabled ? e.virtual.slides : e.slides;
          n = e.slideTo(l.length - 1, 0, !1, !0);
        } else
          n = e.slideTo(e.activeIndex, 0, !1, !0);
        n || r();
      }
      i.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update");
    }
    changeDirection(e, t) {
      t === void 0 && (t = !0);
      const i = this, r = i.params.direction;
      return e || (e = r === "horizontal" ? "vertical" : "horizontal"), e === r || e !== "horizontal" && e !== "vertical" || (i.el.classList.remove(`${i.params.containerModifierClass}${r}`), i.el.classList.add(`${i.params.containerModifierClass}${e}`), i.emitContainerClasses(), i.params.direction = e, i.slides.forEach((n) => {
        e === "vertical" ? n.style.width = "" : n.style.height = "";
      }), i.emit("changeDirection"), t && i.update()), i;
    }
    changeLanguageDirection(e) {
      const t = this;
      t.rtl && e === "rtl" || !t.rtl && e === "ltr" || (t.rtl = e === "rtl", t.rtlTranslate = t.params.direction === "horizontal" && t.rtl, t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update());
    }
    mount(e) {
      const t = this;
      if (t.mounted)
        return !0;
      let i = e || t.params.el;
      if (typeof i == "string" && (i = document.querySelector(i)), !i)
        return !1;
      i.swiper = t, i.parentNode && i.parentNode.host && i.parentNode.host.nodeName === t.params.swiperElementNodeName.toUpperCase() && (t.isElement = !0);
      const r = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`;
      let l = i && i.shadowRoot && i.shadowRoot.querySelector ? i.shadowRoot.querySelector(r()) : G(i, r())[0];
      return !l && t.params.createElements && (l = Y("div", t.params.wrapperClass), i.append(l), G(i, `.${t.params.slideClass}`).forEach((o) => {
        l.append(o);
      })), Object.assign(t, {
        el: i,
        wrapperEl: l,
        slidesEl: t.isElement && !i.parentNode.host.slideSlots ? i.parentNode.host : l,
        hostEl: t.isElement ? i.parentNode.host : i,
        mounted: !0,
        // RTL
        rtl: i.dir.toLowerCase() === "rtl" || _(i, "direction") === "rtl",
        rtlTranslate: t.params.direction === "horizontal" && (i.dir.toLowerCase() === "rtl" || _(i, "direction") === "rtl"),
        wrongRTL: _(l, "display") === "-webkit-box"
      }), !0;
    }
    init(e) {
      const t = this;
      if (t.initialized || t.mount(e) === !1)
        return t;
      t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(), t.attachEvents();
      const r = [...t.el.querySelectorAll('[loading="lazy"]')];
      return t.isElement && r.push(...t.hostEl.querySelectorAll('[loading="lazy"]')), r.forEach((n) => {
        n.complete ? Z(t, n) : n.addEventListener("load", (l) => {
          Z(t, l.target);
        });
      }), ne(t), t.initialized = !0, ne(t), t.emit("init"), t.emit("afterInit"), t;
    }
    destroy(e, t) {
      e === void 0 && (e = !0), t === void 0 && (t = !0);
      const i = this, {
        params: r,
        el: n,
        wrapperEl: l,
        slides: o
      } = i;
      return typeof i.params > "u" || i.destroyed || (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), r.loop && i.loopDestroy(), t && (i.removeClasses(), n.removeAttribute("style"), l.removeAttribute("style"), o && o.length && o.forEach((a) => {
        a.classList.remove(r.slideVisibleClass, r.slideFullyVisibleClass, r.slideActiveClass, r.slideNextClass, r.slidePrevClass), a.removeAttribute("style"), a.removeAttribute("data-swiper-slide-index");
      })), i.emit("destroy"), Object.keys(i.eventsListeners).forEach((a) => {
        i.off(a);
      }), e !== !1 && (i.el.swiper = null, Me(i)), i.destroyed = !0), null;
    }
    static extendDefaults(e) {
      z(ae, e);
    }
    static get extendedDefaults() {
      return ae;
    }
    static get defaults() {
      return xe;
    }
    static installModule(e) {
      $.prototype.__modules__ || ($.prototype.__modules__ = []);
      const t = $.prototype.__modules__;
      typeof e == "function" && t.indexOf(e) < 0 && t.push(e);
    }
    static use(e) {
      return Array.isArray(e) ? (e.forEach((t) => $.installModule(t)), $) : ($.installModule(e), $);
    }
  }
  Object.keys(re).forEach((s) => {
    Object.keys(re[s]).forEach((e) => {
      $.prototype[e] = re[s][e];
    });
  }), $.use([Be, Ve]);
  function be(s, e, t, i) {
    return s.params.createElements && Object.keys(i).forEach((r) => {
      if (!t[r] && t.auto === !0) {
        let n = G(s.el, `.${i[r]}`)[0];
        n || (n = Y("div", i[r]), n.className = i[r], s.el.append(n)), t[r] = n, e[r] = n;
      }
    }), t;
  }
  function jt(s) {
    let {
      swiper: e,
      extendParams: t,
      on: i,
      emit: r
    } = s;
    t({
      navigation: {
        nextEl: null,
        prevEl: null,
        hideOnClick: !1,
        disabledClass: "swiper-button-disabled",
        hiddenClass: "swiper-button-hidden",
        lockClass: "swiper-button-lock",
        navigationDisabledClass: "swiper-navigation-disabled"
      }
    }), e.navigation = {
      nextEl: null,
      prevEl: null
    };
    function n(h) {
      let w;
      return h && typeof h == "string" && e.isElement && (w = e.el.querySelector(h), w) ? w : (h && (typeof h == "string" && (w = [...document.querySelectorAll(h)]), e.params.uniqueNavElements && typeof h == "string" && w.length > 1 && e.el.querySelectorAll(h).length === 1 && (w = e.el.querySelector(h))), h && !w ? h : w);
    }
    function l(h, w) {
      const S = e.params.navigation;
      h = A(h), h.forEach((d) => {
        d && (d.classList[w ? "add" : "remove"](...S.disabledClass.split(" ")), d.tagName === "BUTTON" && (d.disabled = w), e.params.watchOverflow && e.enabled && d.classList[e.isLocked ? "add" : "remove"](S.lockClass));
      });
    }
    function o() {
      const {
        nextEl: h,
        prevEl: w
      } = e.navigation;
      if (e.params.loop) {
        l(w, !1), l(h, !1);
        return;
      }
      l(w, e.isBeginning && !e.params.rewind), l(h, e.isEnd && !e.params.rewind);
    }
    function a(h) {
      h.preventDefault(), !(e.isBeginning && !e.params.loop && !e.params.rewind) && (e.slidePrev(), r("navigationPrev"));
    }
    function p(h) {
      h.preventDefault(), !(e.isEnd && !e.params.loop && !e.params.rewind) && (e.slideNext(), r("navigationNext"));
    }
    function c() {
      const h = e.params.navigation;
      if (e.params.navigation = be(e, e.originalParams.navigation, e.params.navigation, {
        nextEl: "swiper-button-next",
        prevEl: "swiper-button-prev"
      }), !(h.nextEl || h.prevEl))
        return;
      let w = n(h.nextEl), S = n(h.prevEl);
      Object.assign(e.navigation, {
        nextEl: w,
        prevEl: S
      }), w = A(w), S = A(S);
      const d = (u, g) => {
        u && u.addEventListener("click", g === "next" ? p : a), !e.enabled && u && u.classList.add(...h.lockClass.split(" "));
      };
      w.forEach((u) => d(u, "next")), S.forEach((u) => d(u, "prev"));
    }
    function f() {
      let {
        nextEl: h,
        prevEl: w
      } = e.navigation;
      h = A(h), w = A(w);
      const S = (d, u) => {
        d.removeEventListener("click", u === "next" ? p : a), d.classList.remove(...e.params.navigation.disabledClass.split(" "));
      };
      h.forEach((d) => S(d, "next")), w.forEach((d) => S(d, "prev"));
    }
    i("init", () => {
      e.params.navigation.enabled === !1 ? m() : (c(), o());
    }), i("toEdge fromEdge lock unlock", () => {
      o();
    }), i("destroy", () => {
      f();
    }), i("enable disable", () => {
      let {
        nextEl: h,
        prevEl: w
      } = e.navigation;
      if (h = A(h), w = A(w), e.enabled) {
        o();
        return;
      }
      [...h, ...w].filter((S) => !!S).forEach((S) => S.classList.add(e.params.navigation.lockClass));
    }), i("click", (h, w) => {
      let {
        nextEl: S,
        prevEl: d
      } = e.navigation;
      S = A(S), d = A(d);
      const u = w.target;
      if (e.params.navigation.hideOnClick && !d.includes(u) && !S.includes(u)) {
        if (e.pagination && e.params.pagination && e.params.pagination.clickable && (e.pagination.el === u || e.pagination.el.contains(u)))
          return;
        let g;
        S.length ? g = S[0].classList.contains(e.params.navigation.hiddenClass) : d.length && (g = d[0].classList.contains(e.params.navigation.hiddenClass)), r(g === !0 ? "navigationShow" : "navigationHide"), [...S, ...d].filter((x) => !!x).forEach((x) => x.classList.toggle(e.params.navigation.hiddenClass));
      }
    });
    const v = () => {
      e.el.classList.remove(...e.params.navigation.navigationDisabledClass.split(" ")), c(), o();
    }, m = () => {
      e.el.classList.add(...e.params.navigation.navigationDisabledClass.split(" ")), f();
    };
    Object.assign(e.navigation, {
      enable: v,
      disable: m,
      update: o,
      init: c,
      destroy: f
    });
  }
  function F(s) {
    return s === void 0 && (s = ""), `.${s.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}`;
  }
  function qt(s) {
    let {
      swiper: e,
      extendParams: t,
      on: i,
      emit: r
    } = s;
    const n = "swiper-pagination";
    t({
      pagination: {
        el: null,
        bulletElement: "span",
        clickable: !1,
        hideOnClick: !1,
        renderBullet: null,
        renderProgressbar: null,
        renderFraction: null,
        renderCustom: null,
        progressbarOpposite: !1,
        type: "bullets",
        // 'bullets' or 'progressbar' or 'fraction' or 'custom'
        dynamicBullets: !1,
        dynamicMainBullets: 1,
        formatFractionCurrent: (d) => d,
        formatFractionTotal: (d) => d,
        bulletClass: `${n}-bullet`,
        bulletActiveClass: `${n}-bullet-active`,
        modifierClass: `${n}-`,
        currentClass: `${n}-current`,
        totalClass: `${n}-total`,
        hiddenClass: `${n}-hidden`,
        progressbarFillClass: `${n}-progressbar-fill`,
        progressbarOppositeClass: `${n}-progressbar-opposite`,
        clickableClass: `${n}-clickable`,
        lockClass: `${n}-lock`,
        horizontalClass: `${n}-horizontal`,
        verticalClass: `${n}-vertical`,
        paginationDisabledClass: `${n}-disabled`
      }
    }), e.pagination = {
      el: null,
      bullets: []
    };
    let l, o = 0;
    function a() {
      return !e.params.pagination.el || !e.pagination.el || Array.isArray(e.pagination.el) && e.pagination.el.length === 0;
    }
    function p(d, u) {
      const {
        bulletActiveClass: g
      } = e.params.pagination;
      d && (d = d[`${u === "prev" ? "previous" : "next"}ElementSibling`], d && (d.classList.add(`${g}-${u}`), d = d[`${u === "prev" ? "previous" : "next"}ElementSibling`], d && d.classList.add(`${g}-${u}-${u}`)));
    }
    function c(d) {
      const u = d.target.closest(F(e.params.pagination.bulletClass));
      if (!u)
        return;
      d.preventDefault();
      const g = X(u) * e.params.slidesPerGroup;
      if (e.params.loop) {
        if (e.realIndex === g)
          return;
        e.slideToLoop(g);
      } else
        e.slideTo(g);
    }
    function f() {
      const d = e.rtl, u = e.params.pagination;
      if (a())
        return;
      let g = e.pagination.el;
      g = A(g);
      let x, y;
      const M = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, D = e.params.loop ? Math.ceil(M / e.params.slidesPerGroup) : e.snapGrid.length;
      if (e.params.loop ? (y = e.previousRealIndex || 0, x = e.params.slidesPerGroup > 1 ? Math.floor(e.realIndex / e.params.slidesPerGroup) : e.realIndex) : typeof e.snapIndex < "u" ? (x = e.snapIndex, y = e.previousSnapIndex) : (y = e.previousIndex || 0, x = e.activeIndex || 0), u.type === "bullets" && e.pagination.bullets && e.pagination.bullets.length > 0) {
        const L = e.pagination.bullets;
        let O, b, E;
        if (u.dynamicBullets && (l = Q(L[0], e.isHorizontal() ? "width" : "height", !0), g.forEach((C) => {
          C.style[e.isHorizontal() ? "width" : "height"] = `${l * (u.dynamicMainBullets + 4)}px`;
        }), u.dynamicMainBullets > 1 && y !== void 0 && (o += x - (y || 0), o > u.dynamicMainBullets - 1 ? o = u.dynamicMainBullets - 1 : o < 0 && (o = 0)), O = Math.max(x - o, 0), b = O + (Math.min(L.length, u.dynamicMainBullets) - 1), E = (b + O) / 2), L.forEach((C) => {
          const T = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((P) => `${u.bulletActiveClass}${P}`)].map((P) => typeof P == "string" && P.includes(" ") ? P.split(" ") : P).flat();
          C.classList.remove(...T);
        }), g.length > 1)
          L.forEach((C) => {
            const T = X(C);
            T === x ? C.classList.add(...u.bulletActiveClass.split(" ")) : e.isElement && C.setAttribute("part", "bullet"), u.dynamicBullets && (T >= O && T <= b && C.classList.add(...`${u.bulletActiveClass}-main`.split(" ")), T === O && p(C, "prev"), T === b && p(C, "next"));
          });
        else {
          const C = L[x];
          if (C && C.classList.add(...u.bulletActiveClass.split(" ")), e.isElement && L.forEach((T, P) => {
            T.setAttribute("part", P === x ? "bullet-active" : "bullet");
          }), u.dynamicBullets) {
            const T = L[O], P = L[b];
            for (let I = O; I <= b; I += 1)
              L[I] && L[I].classList.add(...`${u.bulletActiveClass}-main`.split(" "));
            p(T, "prev"), p(P, "next");
          }
        }
        if (u.dynamicBullets) {
          const C = Math.min(L.length, u.dynamicMainBullets + 4), T = (l * C - l) / 2 - E * l, P = d ? "right" : "left";
          L.forEach((I) => {
            I.style[e.isHorizontal() ? P : "top"] = `${T}px`;
          });
        }
      }
      g.forEach((L, O) => {
        if (u.type === "fraction" && (L.querySelectorAll(F(u.currentClass)).forEach((b) => {
          b.textContent = u.formatFractionCurrent(x + 1);
        }), L.querySelectorAll(F(u.totalClass)).forEach((b) => {
          b.textContent = u.formatFractionTotal(D);
        })), u.type === "progressbar") {
          let b;
          u.progressbarOpposite ? b = e.isHorizontal() ? "vertical" : "horizontal" : b = e.isHorizontal() ? "horizontal" : "vertical";
          const E = (x + 1) / D;
          let C = 1, T = 1;
          b === "horizontal" ? C = E : T = E, L.querySelectorAll(F(u.progressbarFillClass)).forEach((P) => {
            P.style.transform = `translate3d(0,0,0) scaleX(${C}) scaleY(${T})`, P.style.transitionDuration = `${e.params.speed}ms`;
          });
        }
        u.type === "custom" && u.renderCustom ? (L.innerHTML = u.renderCustom(e, x + 1, D), O === 0 && r("paginationRender", L)) : (O === 0 && r("paginationRender", L), r("paginationUpdate", L)), e.params.watchOverflow && e.enabled && L.classList[e.isLocked ? "add" : "remove"](u.lockClass);
      });
    }
    function v() {
      const d = e.params.pagination;
      if (a())
        return;
      const u = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.grid && e.params.grid.rows > 1 ? e.slides.length / Math.ceil(e.params.grid.rows) : e.slides.length;
      let g = e.pagination.el;
      g = A(g);
      let x = "";
      if (d.type === "bullets") {
        let y = e.params.loop ? Math.ceil(u / e.params.slidesPerGroup) : e.snapGrid.length;
        e.params.freeMode && e.params.freeMode.enabled && y > u && (y = u);
        for (let M = 0; M < y; M += 1)
          d.renderBullet ? x += d.renderBullet.call(e, M, d.bulletClass) : x += `<${d.bulletElement} ${e.isElement ? 'part="bullet"' : ""} class="${d.bulletClass}"></${d.bulletElement}>`;
      }
      d.type === "fraction" && (d.renderFraction ? x = d.renderFraction.call(e, d.currentClass, d.totalClass) : x = `<span class="${d.currentClass}"></span> / <span class="${d.totalClass}"></span>`), d.type === "progressbar" && (d.renderProgressbar ? x = d.renderProgressbar.call(e, d.progressbarFillClass) : x = `<span class="${d.progressbarFillClass}"></span>`), e.pagination.bullets = [], g.forEach((y) => {
        d.type !== "custom" && (y.innerHTML = x || ""), d.type === "bullets" && e.pagination.bullets.push(...y.querySelectorAll(F(d.bulletClass)));
      }), d.type !== "custom" && r("paginationRender", g[0]);
    }
    function m() {
      e.params.pagination = be(e, e.originalParams.pagination, e.params.pagination, {
        el: "swiper-pagination"
      });
      const d = e.params.pagination;
      if (!d.el)
        return;
      let u;
      typeof d.el == "string" && e.isElement && (u = e.el.querySelector(d.el)), !u && typeof d.el == "string" && (u = [...document.querySelectorAll(d.el)]), u || (u = d.el), !(!u || u.length === 0) && (e.params.uniqueNavElements && typeof d.el == "string" && Array.isArray(u) && u.length > 1 && (u = [...e.el.querySelectorAll(d.el)], u.length > 1 && (u = u.filter((g) => pe(g, ".swiper")[0] === e.el)[0])), Array.isArray(u) && u.length === 1 && (u = u[0]), Object.assign(e.pagination, {
        el: u
      }), u = A(u), u.forEach((g) => {
        d.type === "bullets" && d.clickable && g.classList.add(...(d.clickableClass || "").split(" ")), g.classList.add(d.modifierClass + d.type), g.classList.add(e.isHorizontal() ? d.horizontalClass : d.verticalClass), d.type === "bullets" && d.dynamicBullets && (g.classList.add(`${d.modifierClass}${d.type}-dynamic`), o = 0, d.dynamicMainBullets < 1 && (d.dynamicMainBullets = 1)), d.type === "progressbar" && d.progressbarOpposite && g.classList.add(d.progressbarOppositeClass), d.clickable && g.addEventListener("click", c), e.enabled || g.classList.add(d.lockClass);
      }));
    }
    function h() {
      const d = e.params.pagination;
      if (a())
        return;
      let u = e.pagination.el;
      u && (u = A(u), u.forEach((g) => {
        g.classList.remove(d.hiddenClass), g.classList.remove(d.modifierClass + d.type), g.classList.remove(e.isHorizontal() ? d.horizontalClass : d.verticalClass), d.clickable && (g.classList.remove(...(d.clickableClass || "").split(" ")), g.removeEventListener("click", c));
      })), e.pagination.bullets && e.pagination.bullets.forEach((g) => g.classList.remove(...d.bulletActiveClass.split(" ")));
    }
    i("changeDirection", () => {
      if (!e.pagination || !e.pagination.el)
        return;
      const d = e.params.pagination;
      let {
        el: u
      } = e.pagination;
      u = A(u), u.forEach((g) => {
        g.classList.remove(d.horizontalClass, d.verticalClass), g.classList.add(e.isHorizontal() ? d.horizontalClass : d.verticalClass);
      });
    }), i("init", () => {
      e.params.pagination.enabled === !1 ? S() : (m(), v(), f());
    }), i("activeIndexChange", () => {
      typeof e.snapIndex > "u" && f();
    }), i("snapIndexChange", () => {
      f();
    }), i("snapGridLengthChange", () => {
      v(), f();
    }), i("destroy", () => {
      h();
    }), i("enable disable", () => {
      let {
        el: d
      } = e.pagination;
      d && (d = A(d), d.forEach((u) => u.classList[e.enabled ? "remove" : "add"](e.params.pagination.lockClass)));
    }), i("lock unlock", () => {
      f();
    }), i("click", (d, u) => {
      const g = u.target, x = A(e.pagination.el);
      if (e.params.pagination.el && e.params.pagination.hideOnClick && x && x.length > 0 && !g.classList.contains(e.params.pagination.bulletClass)) {
        if (e.navigation && (e.navigation.nextEl && g === e.navigation.nextEl || e.navigation.prevEl && g === e.navigation.prevEl))
          return;
        const y = x[0].classList.contains(e.params.pagination.hiddenClass);
        r(y === !0 ? "paginationShow" : "paginationHide"), x.forEach((M) => M.classList.toggle(e.params.pagination.hiddenClass));
      }
    });
    const w = () => {
      e.el.classList.remove(e.params.pagination.paginationDisabledClass);
      let {
        el: d
      } = e.pagination;
      d && (d = A(d), d.forEach((u) => u.classList.remove(e.params.pagination.paginationDisabledClass))), m(), v(), f();
    }, S = () => {
      e.el.classList.add(e.params.pagination.paginationDisabledClass);
      let {
        el: d
      } = e.pagination;
      d && (d = A(d), d.forEach((u) => u.classList.add(e.params.pagination.paginationDisabledClass))), h();
    };
    Object.assign(e.pagination, {
      enable: w,
      disable: S,
      render: v,
      update: f,
      init: m,
      destroy: h
    });
  }
  const Wt = {
    close: (
      /* HTML */
      `<svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path
      d="M13.0375 0.306086C12.6432 -0.088301 12.0061 -0.088301 11.6117 0.306086L6.66667 5.24099L1.72165 0.295974C1.32727 -0.0984138 0.690178 -0.0984138 0.295791 0.295974C-0.0985969 0.690361 -0.0985969 1.32745 0.295791 1.72184L5.2408 6.66685L0.295791 11.6119C-0.0985969 12.0062 -0.0985969 12.6433 0.295791 13.0377C0.690178 13.4321 1.32727 13.4321 1.72165 13.0377L6.66667 8.09271L11.6117 13.0377C12.0061 13.4321 12.6432 13.4321 13.0375 13.0377C13.4319 12.6433 13.4319 12.0062 13.0375 11.6119L8.09253 6.66685L13.0375 1.72184C13.4218 1.33756 13.4218 0.690362 13.0375 0.306086Z"
      fill="white"
    />
  </svg> `
    ),
    arrowPrev: (
      /* HTML */
      `<svg width="8" height="12" viewBox="0 0 8 12" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M7 11L2 6L7 1" stroke="#0373BD" stroke-width="2" />
  </svg> `
    ),
    arrowNext: (
      /* HTML */
      `<svg width="8" height="12" viewBox="0 0 8 12" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M1 1L6 6L1 11" stroke="#0373BD" stroke-width="2" />
  </svg> `
    ),
    quality: (
      /* HTML */
      `<svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path
      d="M15.8889 11.198L15.0004 9.35364L14.1119 11.198C14.0204 11.3878 13.8437 11.5193 13.6392 11.5497L11.6523 11.8455L13.0901 13.2811C13.238 13.4289 13.3055 13.6416 13.2706 13.8503L12.9312 15.8775L14.7083 14.9203C14.7997 14.8711 14.9001 14.8465 15.0004 14.8465C15.1007 14.8465 15.201 14.8711 15.2924 14.9203L17.0696 15.8775L16.7301 13.8503C16.6952 13.6417 16.7628 13.4289 16.9106 13.2811L18.3484 11.8455L16.3615 11.5497C16.1571 11.5193 15.9803 11.3878 15.8889 11.198Z"
      fill="#0373BD"
    />
    <path
      d="M24.0317 13.1859C23.9779 13.0165 23.9779 12.8373 24.0317 12.6678L24.5404 11.0643C24.8189 10.1863 24.5161 9.23191 23.7871 8.68924L22.4555 7.69815C22.3148 7.59341 22.212 7.44849 22.1582 7.279L21.6496 5.67541C21.371 4.7975 20.5785 4.20763 19.6774 4.20763H18.0314C17.8575 4.20763 17.6912 4.15227 17.5505 4.04753L16.2188 3.05644C15.4898 2.5139 14.5102 2.5139 13.7812 3.05644L12.4496 4.04753C12.3089 4.15227 12.1425 4.20763 11.9686 4.20763H10.3227C9.4216 4.20763 8.629 4.7975 8.35045 5.67548L7.8418 7.27913C7.78807 7.44855 7.68526 7.59348 7.54454 7.69822L6.21298 8.6893C5.48402 9.23191 5.18124 10.1863 5.45973 11.0643L5.96838 12.6679C6.02217 12.8373 6.02217 13.0165 5.96838 13.186L5.45973 14.7896C5.18124 15.6675 5.48402 16.622 6.21304 17.1646L7.54467 18.1558C7.68539 18.2605 7.78814 18.4054 7.84186 18.5749L8.35051 20.1785C8.62907 21.0564 9.4216 21.6463 10.3227 21.6463H11.9687C12.1426 21.6463 12.3089 21.7017 12.4497 21.8064L13.7813 22.7974C14.1459 23.0688 14.5729 23.2044 15.0001 23.2044C15.4272 23.2044 15.8545 23.0688 16.219 22.7975L17.5506 21.8064C17.6913 21.7017 17.8576 21.6463 18.0316 21.6463H19.6775C20.5786 21.6463 21.3712 21.0564 21.6497 20.1785L22.1584 18.5748C22.2121 18.4054 22.3148 18.2605 22.4556 18.1557L23.7872 17.1646C24.5162 16.622 24.8189 15.6675 24.5405 14.7895L24.0317 13.1859ZM20.1351 11.8571L18.023 13.9661L18.5216 16.9442C18.562 17.1853 18.4651 17.4292 18.2718 17.5731C18.1625 17.6545 18.0329 17.6959 17.9028 17.6959C17.8029 17.6959 17.7027 17.6715 17.6108 17.622L15.0001 16.2159L12.3893 17.622C12.1779 17.7358 11.9215 17.7169 11.7283 17.5731C11.535 17.4292 11.4382 17.1854 11.4785 16.9442L11.9772 13.9661L9.86504 11.8571C9.69394 11.6862 9.63243 11.4307 9.70624 11.1979C9.78012 10.9652 9.97651 10.7956 10.2129 10.7603L13.1318 10.3258L14.4372 7.61624C14.5429 7.39679 14.7611 7.25784 15.0001 7.25784C15.239 7.25784 15.4572 7.39679 15.5629 7.61624L16.8683 10.3258L19.7872 10.7603C20.0237 10.7955 20.2201 10.9652 20.2939 11.1979C20.3677 11.4307 20.3061 11.6862 20.1351 11.8571Z"
      fill="#0373BD"
    />
    <path
      d="M26.8162 21.5851L23.8512 18.547L23.2015 19.0299L22.7239 20.5351C22.2939 21.8918 21.0694 22.8029 19.6773 22.8029H18.1326L17.5244 23.2549L21.3556 27.179C21.4742 27.3005 21.6349 27.3673 21.7994 27.3673C21.842 27.3673 21.8853 27.3628 21.928 27.3532C22.1352 27.3088 22.3065 27.1603 22.3837 26.9584L23.57 23.8528L26.6009 22.6383C26.7986 22.5592 26.9436 22.3836 26.9869 22.1708C27.0302 21.9586 26.9662 21.7381 26.8162 21.5851Z"
      fill="#0373BD"
    />
    <path
      d="M11.8676 22.8029H10.3229C8.9308 22.8029 7.70625 21.8918 7.27631 20.5351L6.79866 19.0299L6.14904 18.547L3.18401 21.5851C3.034 21.7381 2.96998 21.9586 3.01329 22.1708C3.0566 22.3836 3.20158 22.5592 3.39929 22.6383L6.43023 23.8528L7.61649 26.9584C7.69369 27.1603 7.86504 27.3088 8.07217 27.3532C8.11485 27.3628 8.15816 27.3673 8.20084 27.3673C8.36528 27.3673 8.52596 27.3005 8.64459 27.179L12.4758 23.2549L11.8676 22.8029Z"
      fill="#0373BD"
    />
  </svg> `
    ),
    money: (
      /* HTML */
      `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path
      d="M10.114 4.22174C10.4575 3.75614 10.6542 3.18744 10.6542 2.59688V1.5626C10.6542 1.39073 10.5137 1.25012 10.3419 1.25012C9.66746 1.25012 9.31148 1.41886 8.99921 1.56883C8.7088 1.70946 8.459 1.82819 7.92816 1.82819C7.39732 1.82819 7.14751 1.70946 6.85713 1.56883C6.54486 1.41886 6.18888 1.25012 5.51441 1.25012C5.34264 1.25012 5.20215 1.39073 5.20215 1.5626V2.59688C5.20215 3.18744 5.39887 3.75615 5.74236 4.22174H10.114Z"
      fill="white"
    />
    <path
      d="M3.00037 12.5468L5.86909 13.3812C6.24407 12.878 6.84094 12.5655 7.48468 12.5655H9.74401C9.81277 12.5655 9.87839 12.5468 9.93776 12.5093L11.0534 11.7999C11.6221 11.4406 12.2783 11.2499 12.9502 11.2499H13.3721L13.1377 8.75311C12.9908 7.14375 12.1002 5.71252 10.7628 4.84692H5.09409C3.75662 5.71252 2.866 7.14375 2.71913 8.75311L2.36914 12.4749C2.58168 12.4622 2.79267 12.4867 3.00037 12.5468ZM8.21591 9.0031H7.64092C6.10033 8.95622 6.08158 6.725 7.61592 6.64688V6.32189C7.61592 6.14689 7.75654 6.0094 7.92841 6.0094C8.10028 6.0094 8.24091 6.1469 8.24091 6.32189V6.64688H9.08152C9.49402 6.65313 9.49402 7.26563 9.08152 7.27187H7.64092C6.91593 7.28438 6.91593 8.3656 7.64092 8.37811H8.2159C9.7565 8.42186 9.77838 10.6562 8.24091 10.7343V11.0624C8.24091 11.2343 8.10028 11.3749 7.92842 11.3749C7.75655 11.3749 7.61592 11.2343 7.61592 11.0624V10.7343H6.77844C6.36594 10.725 6.36594 10.1156 6.77844 10.1093H8.21591C8.94403 10.0968 8.94403 9.0156 8.21591 9.0031Z"
      fill="white"
    />
    <path
      d="M15.2309 12.1353C15.2371 12.0479 15.2496 11.9604 15.2684 11.876H12.9469C11.9915 11.8134 11.0339 12.5587 10.2693 13.0383C10.11 13.1383 9.92874 13.1914 9.74128 13.1914H7.48233C5.63751 13.2538 5.63576 15.9211 7.48236 15.9815C7.48233 15.9815 9.77564 15.9815 9.77564 15.9815C9.9482 15.9815 10.0881 16.1214 10.0881 16.294C10.0881 16.4665 9.9482 16.6064 9.77564 16.6064H7.48232C6.13326 16.6364 5.10949 15.2122 5.56709 13.9444C5.56707 13.9444 2.82069 13.1477 2.82069 13.1477C1.3852 12.7461 0.601082 14.7794 1.95213 15.4347C1.95209 15.4347 8.02599 18.3123 8.02599 18.3123C9.37545 18.9535 10.9598 18.8882 12.2533 18.1311L14.6654 16.7251C14.8405 16.6161 15.0756 16.6334 15.2715 16.6345C15.2072 16.6452 15.234 12.2631 15.2309 12.1353Z"
      fill="white"
    />
    <path
      d="M18.1211 11.2783H16.793C16.3961 11.2783 16.0555 11.5252 15.9211 11.8752C15.8836 11.9689 15.8617 12.0689 15.8555 12.1721V16.2908C15.8555 16.4126 15.8773 16.5283 15.9211 16.6345C16.0586 16.9814 16.3961 17.2282 16.793 17.2282H18.1211C18.4648 17.2282 18.746 16.947 18.746 16.6032V11.9033C18.746 11.5596 18.4648 11.2783 18.1211 11.2783ZM17.2992 13.2221C16.8898 13.2158 16.8898 12.6064 17.2992 12.5971C17.7117 12.6064 17.7086 13.2158 17.2992 13.2221Z"
      fill="white"
    />
  </svg> `
    ),
    percantage: (
      /* HTML */
      `<svg
    width="28"
    height="28"
    viewBox="0 0 28 28"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      d="M27.3929 11.6749L25.5368 4.25019C25.4904 4.08776 25.4324 3.93694 25.3628 3.79776L22.0796 7.08088C22.5089 7.99734 22.3581 9.1226 21.604 9.87669C20.6412 10.8395 19.0866 10.8396 18.1237 9.87669C17.1608 8.9138 17.1609 7.35919 18.1237 6.39635C18.8778 5.64226 20.003 5.49144 20.9195 5.92074L24.2026 2.63761C24.0634 2.56794 23.9126 2.51002 23.7502 2.46359L16.3255 0.607488C15.4903 0.39869 14.597 0.642269 13.9821 1.25712L0.722145 14.5171C-0.240688 15.4799 -0.240742 17.0345 0.722145 17.9974L10.003 27.2783C10.9659 28.2412 12.5205 28.2411 13.4833 27.2783L26.7433 14.0182C27.3582 13.4033 27.6017 12.5101 27.3929 11.6749ZM10.003 9.87669C10.9659 8.9138 12.5204 8.9138 13.4833 9.87669C14.4463 10.8396 14.4462 12.3941 13.4833 13.357C12.5205 14.3198 10.9659 14.3199 10.003 13.357C9.04005 12.3941 9.04016 10.8395 10.003 9.87669ZM14.6434 21.4777C13.6805 22.4405 12.126 22.4406 11.1631 21.4777C10.2002 20.5148 10.2003 18.9602 11.1631 17.9974C12.126 17.0345 13.6805 17.0345 14.6434 17.9974C15.6063 18.9603 15.6063 20.5148 14.6434 21.4777ZM17.6343 15.9128L7.19335 17.0729C6.93561 17.1007 6.69258 17.0073 6.52211 16.8367C6.39524 16.7099 6.30856 16.5405 6.28701 16.3479C6.23774 15.8976 6.56176 15.492 7.01206 15.4416L17.453 14.2815C17.9028 14.2339 18.3089 14.5562 18.3593 15.0065C18.4086 15.4569 18.0846 15.8624 17.6343 15.9128Z"
      fill="#0373BD"
    />
  </svg>`
    )
  }, {
    close: Se,
    arrowPrev: Yt,
    arrowNext: Xt,
    quality: Zt,
    money: Ut,
    percantage: Kt
  } = Wt;
  let N = null;
  document.querySelectorAll(".add-to-cart").forEach((s) => {
    s.addEventListener("click", async () => {
      N = null;
    });
  });
  const ye = async () => {
    var s, e;
    try {
      if (N)
        return N;
      const i = await (await fetch("https://www.paintscratch.com/cgi-bin/shopping-cart.cgi")).text(), n = new DOMParser().parseFromString(i, "text/html"), l = n.querySelectorAll(".cart-row"), o = [];
      l && l.forEach((c, f) => {
        var S;
        const v = c.querySelector(".cart-pic img"), m = c.querySelector(".item-title a"), h = c.querySelector(".quantity .each-price"), w = {
          image: v.src || v.dataset.cfsrc,
          title: m.textContent,
          price: parseFloat(((S = h == null ? void 0 : h.textContent) == null ? void 0 : S.replace(/[$()@]/g, "")) || "0")
        };
        o.push(w);
      });
      const a = (e = (s = n.querySelector("#subtotals_and_shipping .right_side_text")) == null ? void 0 : s.textContent) == null ? void 0 : e.split("$")[1], p = parseFloat((a == null ? void 0 : a.replace(/[$()@]/g, "")) || "0");
      return N = { products: o, total: p }, N;
    } catch (t) {
      return console.error("Failed to get cart data:", t), { products: [], total: 0 };
    }
  }, V = ({ name: s, desc: e, type: t = "click", loc: i = "" }) => {
    window.dataLayer = window.dataLayer || [], window.dataLayer.push({
      event: "event-to-ga4",
      event_name: s,
      event_desc: e,
      event_type: t,
      event_loc: i
    }), console.log(`Event: ${s} | ${e} | ${t} | ${i}`);
  }, oe = ({ selector: s, viewTime: e = 3, event: t, description: i, location: r }) => {
    let n = new IntersectionObserver(
      (o) => {
        o.forEach((a) => {
          a.isIntersecting && (n.unobserve(a.target), setTimeout(function() {
            l.observe(a.target);
          }, 1e3 * e));
        });
      },
      {
        threshold: 0.5
      }
    ), l = new IntersectionObserver((o) => {
      o.forEach((a) => {
        a.isIntersecting ? (V(
          {
            name: t || `view_element_${a.target.id}`,
            type: "view",
            desc: i || `View element on screen (${e} sec or more)`,
            loc: r || a.target.id
          }
        ), n.unobserve(a.target)) : n.observe(a.target), l.unobserve(a.target);
      });
    });
    document.querySelectorAll(s).forEach((o) => {
      n.observe(o);
    });
  }, Jt = "https://conversionratestore.github.io/projects/paintscratch";
  class Qt {
    constructor() {
      this.popup = null, this.dataPopup = "off-purchase";
    }
    render(e = "body", t = "beforeend") {
      const i = (
        /* HTML */
        `
      <dialog class="os-border-none os-p-0 os-w-[335px] md:os-w-[460px]" data-popup="${this.dataPopup}">
        <div class="os-p-y-[20px] md:os-p-y-[30px] os-pb-[20px] md:os-pb-[30px]">
          <div class="os-relative os-bg-[#0373bd] os-py-[12px] ">
            <button
              data-popup-close="${this.dataPopup}"
              class="os-p-0 os-flex os-justify-center os-absolute os-top-[50%] os-right-[18px] -os-translate-y-2/4 os-bg-transparent os-border-none [&_svg]:os-w-full focus:os-outline-none focus-within:os-outline-none"
            >
              ${Se}
            </button>
            <h2 class="os-m-0 os-text-center os-text-[18px] md:os-text-[20px] os-font-bold os-text-white">Dont leave just yet!</h2>
          </div>
          <div class="os-px-[20px] md:os-px-[30px]">
            <div class="os-flex os-justify-center"><img src="${Jt}/img/kits-deluxe-spray.png" alt="kits deluxe spray" /></div>
          </div>
          <div class="os-px-[20px] md:os-px-[30px] os-text-center os-text-[30px] md:os-text-[36px] os-font-bold os-text-[#333]">
            <span class="os-text-[#0373bd]">Get 5%</span> Off Your <br class="os-hidden md:os-block"> Purchase Now!
        </div>
        <div class="os-flex os-justify-center os-p-[10px]">
          <div class="os-w-[60px] os-h-[2px] os-bg-[#0373bd]"></div>
        </div>
        <div class="os-text-[#333] os-px-[20px] os-text-center os-font-bold os-text-[14px] md:os-text-[18px]">
        Secure Your Exclusive Discount on Professional-Grade Touch-Up Paint!
        </div>
        <div class="os-mt-[16px] os-px-[20px] md:os-px-[30px]">
        <button class="os-text-[#333] os-h-[50px] os-w-full os-font-bold os-text-[16px] md:os-text-[18px] os-border-none os-bg-[linear-gradient(to_bottom,_#ffc842,_#f48818)]" data-button="select-products">Select products</button></div>
        <div class="os-mt-[12px] os-text-[#767676] os-text-[14px] os-text-center os-px-[20px] md:os-px-[30px] os-leading-[20px]">Click to secure your savings! Discount applies automatically at checkout. Act quicklythis offer expires soon!</div>
        </dialog>
    `
      );
      document.querySelector(e).insertAdjacentHTML(t, i), oe({
        selector: `[data-popup="${this.dataPopup}"]`,
        description: "Section",
        event: "exp_exitintent_section_01",
        location: "Exit intent pop-up empty cart Dont leave just yet! Get 5% Off Your Purchase Now!"
      }), this.popup = document.querySelector(`[data-popup="${this.dataPopup}"]`), this.popup.addEventListener("click", (r) => {
        if (r.target.closest("[data-popup-close]") && (this.hide(), V({
          name: "exp_exitintent_button_02",
          type: "click",
          desc: "Close",
          loc: "Exit intent pop-up empty cart Dont leave just yet! Get 5% Off Your Purchase Now!"
        })), r.target === this.popup && this.hide(), r.target.closest('[data-button="select-products"]')) {
          this.hide();
          const n = new URL(window.location.href);
          V({
            name: "exp_exitintent_button_01",
            type: "click",
            desc: "Select products",
            loc: "Exit intent pop-up empty cart Dont leave just yet! Get 5% Off Your Purchase Now!"
          }), n.searchParams.append("discount_code", "FIRSTORDER10"), window.location.href = n.toString();
        }
      });
    }
    show() {
      this.popup && this.popup.showModal();
    }
    hide() {
      this.popup && this.popup.close();
    }
  }
  class es {
    constructor() {
      this.popup = null, this.dataPopup = "cart-purchase", this.total = 0;
    }
    render(e = "body", t = "beforeend") {
      const i = (
        /* HTML */
        `
      <dialog class="os-border-none os-p-0 os-w-[335px] md:os-w-[460px]" data-popup="${this.dataPopup}">
        <div class="os-pb-[20px] md:os-pb-[30px]">
          <div class="os-relative os-bg-[#0373bd] os-py-[12px] ">
            <button
              data-popup-close="${this.dataPopup}"
              class="os-p-0 os-flex os-justify-center os-absolute os-top-[50%] os-right-[18px] -os-translate-y-2/4 os-bg-transparent os-border-none [&_svg]:os-w-full focus:os-outline-none focus-within:os-outline-none"
            >
              ${Se}
            </button>
            <h2 class="os-m-0 os-text-center os-text-[18px] md:os-text-[20px] os-text-white os-font-bold">
              You're Almost There! <br /><span class="os-text-[14px] os-font-normal">Only one step left:</span>
            </h2>
          </div>

          <div class="os-px-[20px] md:os-px-[30px]">
            <div class="" data-swiper></div>

            <div class="os-mt-[16px]">
              <button
                data-button="complete-order"
                class="os-text-[#333] os-h-[50px] os-w-full os-font-bold os-text-[16px] md:os-text-[18px] os-border-none os-bg-[linear-gradient(to_bottom,_#ffc842,_#f48818)]"
              >
                Complete my order
              </button>
            </div>
            <div class="os-mt-[12px] os-text-[#767676] os-text-[14px] os-text-center os-leading-[22px]">
              Click the button to lock in your 10% savings automatically at checkout. Don't delay, offer ends soon!
            </div>
          </div>
        </div>
      </dialog>
    `
      );
      document.querySelector(e).insertAdjacentHTML(t, i), this.popup = document.querySelector(`[data-popup="${this.dataPopup}"]`), document.querySelector('[data-button="complete-order"]').addEventListener("click", () => {
        this.total >= 100 && V({
          name: "exp_exitintent_button_03",
          type: "click",
          desc: "Complete my order",
          loc: "Exit intent pop-up filled cart You're Almost There! More 100 dollars"
        }), this.total < 100 && V({
          name: "exp_exitintent_button_05",
          type: "click",
          desc: "Complete my order",
          loc: "Exit intent pop-up filled cart You're Almost There! Less 100 dollars"
        }), window.location.href = "https://www.paintscratch.com/cgi-bin/shopping-cart.cgi";
      }), this.popup.addEventListener("click", (n) => {
        n.target.closest("[data-popup-close]") && (this.total >= 100 && V({
          name: "exp_exitintent_button_04",
          type: "click",
          desc: "Close",
          loc: "Exit intent pop-up filled cart You're Almost There! More 100 dollars"
        }), this.total < 100 && V({
          name: "exp_exitintent_button_06",
          type: "click",
          desc: "Close",
          loc: "Exit intent pop-up filled cart You're Almost There! Less 100 dollars"
        }), this.hide());
      });
    }
    async cartProducts() {
      const e = await ye();
      this.total = e.total;
      const t = (
        /* HTML */
        `
      <div class="os-w-full os-mt-[20px] os-pb-[16px]" style="border-bottom: 1px dashed #dddee9">
        <div class="swiper">
          <!-- Additional required wrapper -->
          <div class="swiper-wrapper">
            ${e.products && e.products.length > 0 ? e.products.map((i) => (
          /* HTML */
          `
                      <!-- Slides -->
                      <div class="swiper-slide os-w-[60%] os-overflow-hidden" style="border-right: 1px solid #dddee9">
                        <div class="os-flex os-flex-col os-justify-center os-items-center os-gap-[8px]">
                          <div class="os-w-[104px] os-h-[104px] os-flex os-justify-center os-items-center">
                            <img class="os-h-full" src="${i.image}" alt="${i.name}" />
                          </div>
                          <div class="os-text-[#253189] os-text-[16px] os-font-bold os-text-center">
                            ${i.title}
                          </div>
                          <div class="os-text-center os-text-[#555] ">
                            <span class="os-font-bold os-text-[12px]"
                              ><span class="os-text-[14px] os-line-through">${(i.price * 1.05).toFixed(2)}</span
                              ><span class="os-text-[#900] os-text-[18px]"> $${i.price}</span></span
                            >
                            / each
                          </div>
                        </div>
                      </div>
                    `
        )).join("") : ""}
          </div>
          <div class="os-w-full os-mt-[16px] os-flex os-justify-center os-items-center os-gap-[16px]">
            <div
              class="os-static swiper-button-prev os-w-[10px] os-h-[15px] after:os-text-[10px] os-m-0 os-hidden md:os-flex"
            >
              ${Yt}
            </div>
            <div class="swiper-pagination os-static !os-w-max"></div>
            <div
              class="os-static swiper-button-next os-w-[10px] os-h-[15px] after:os-text-[10px] os-m-0 os-hidden md:os-flex"
            >
              ${Xt}
            </div>
          </div>
        </div>
      </div>
      ${+e.total >= 100 ? (
          /* HTML */
          `<div
              data-cart="more"
              class="os-w-fit os-gap-[8px] md:os-w-full os-justify-between os-flex-col md:os-flex-row os-mt-[16px] os-flex os-border-t-[1px] os-border-[#dddee9]"
            >
              <div class="os-text-[#333] os-font-bold os-text-[18px] os-flex os-items-center">
                Total: ${e.products.length === 1 ? (
            /* HTML */
            `<span class="os-font-bold os-text-[12px]"
                ><span class="os-text-[14px] os-line-through">${(e.total * 1.05).toFixed(2)}</span
                ><span class="os-text-[#900] os-text-[18px]"> $${e.total.toFixed(2)}</span></span
              >`
          ) : (
            /* HTML */
            `<span class="os-flex os-items-center">$${e.total.toFixed(2)}</span>`
          )} 
              </div>
              <div
                class="os-flex os-items-center os-gap-[6px] os-bg-[#0373bd] os-rounded-[4px] os-text-white os-font-bold os-p-[8px]"
              >
                <span class="os-flex os-items-center">${Ut}</span>Your savings:
                <span>$${(e.total * 0.05).toFixed(2)}</span>
              </div>
            </div>
            <div
              class="os-flex os-items-center os-w-fit os-gap-[8px] os-mt-[16px] os-py-[8px] os-px-[12px] os-border-dashed os-border-[1px] os-border-[#dddee9]"
            >
              <div>${Zt}</div>
              <div class="os-text-[#333] os-text-left os-leading-[22px]">
                With every selection, you're securing top-quality product at a great price!
              </div>
            </div>`
        ) : (
          /* HTML */
          `<div
            data-cart="less"
            class="os-flex os-items-center  os-gap-[8px] os-mt-[16px] os-py-[8px] os-px-[12px] os-border-dashed os-border-[1px] os-border-[#dddee9]"
          >
            <div>${Kt}</div>
            <div class="os-text-[#333] os-text-left os-leading-[22px]">
              Complete your order now and enjoy<br />
              a <span class="os-text-[#0373bd] os-font-bold">5% discount</span> on your entire order!
            </div>
          </div>`
        )}
    `
      );
      this.popup.querySelector("[data-swiper]").innerHTML = t, oe({
        selector: '[data-cart="more"]',
        description: "Section",
        event: "exp_exitintent_section_02",
        location: "Exit intent pop-up filled cart You're Almost There! More 100 dollars"
      }), oe({
        selector: '[data-cart="less"]',
        description: "Section",
        event: "exp_exitintent_section_03",
        location: "Exit intent pop-up filled cart You're Almost There! Less 100 dollars"
      }), new $(".swiper", {
        modules: [jt, qt],
        direction: "horizontal",
        loop: !0,
        slidesPerView: "auto",
        pagination: {
          el: ".swiper-pagination",
          clickable: !0
        },
        navigation: {
          nextEl: ".swiper-button-next",
          prevEl: ".swiper-button-prev"
        },
        scrollbar: {
          el: ".swiper-scrollbar"
        }
      });
    }
    show() {
      this.popup && (this.cartProducts(), this.popup.showModal());
    }
    hide() {
      this.popup && this.popup.close();
    }
  }
  const ts = function(s) {
    s = s || {};
    let e, t, i, r, n = s.delay || 50;
    function l() {
      e = null, r = 0;
    }
    return l(), function() {
      return t = window.scrollY, e != null && (r = t - e), e = t, clearTimeout(i), i = setTimeout(l, n), r;
    };
  }();
  console.log(
    "%c EXP: Exit Intent Popup (DEV: OS)",
    "background: #3498eb; color: #fccf3a; font-size: 20px; font-weight: bold;"
  );
  const ss = setInterval(function() {
    typeof clarity == "function" && (clearInterval(ss), clarity("set", "exp_exi_inte_popup", "variant_1"));
  }, 1e3), U = {
    mobile: "Mobile",
    desktop: "Desktop"
  };
  class is {
    constructor() {
      this.device = screen.width <= 768 ? U.mobile : U.desktop, console.log("ExitIntendPopup constructor"), this.cartPopup = new es(), this.offPurchasePopup = new Qt();
    }
    init() {
      this.cartPopup.render(), this.offPurchasePopup.render(), this.trigger();
    }
    trigger() {
      const e = async () => {
        const r = await ye();
        r.products && r.products.length > 0 ? this.cartPopup.show() : (console.log("here"), this.offPurchasePopup.show()), sessionStorage.setItem("exit-intent-popup", "true");
      };
      this.device === U.desktop && document.addEventListener("mouseout", async (r) => {
        (r.clientY <= 0 || r.clientX <= 0 || r.clientX >= window.innerWidth || r.clientY >= window.innerHeight) && e();
      }), this.device === U.mobile && document.addEventListener("scroll", async (r) => {
        const n = ts();
        (n > 70 || n < -70) && e();
      }), document.addEventListener("focus", async (r) => {
        r.relatedTarget || await e();
      });
      let t = setTimeout(async () => {
        e();
      }, 2e4);
      const i = () => {
        clearTimeout(t), t = setTimeout(async () => {
          e();
        }, 2e4);
      };
      document.addEventListener("mousemove", i), document.addEventListener("scroll", i), document.addEventListener("keydown", i), document.addEventListener("touchstart", i), document.addEventListener("click", i);
    }
  }
  new is().init();
})();
//# sourceMappingURL=index.js.map
