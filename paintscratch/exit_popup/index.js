(function(){"use strict";try{if(typeof document<"u"){var t=document.createElement("style");t.id="style-injected-by-js",t.appendChild(document.createTextNode('@font-face{font-family:swiper-icons;src:url(data:application/font-woff;charset=utf-8;base64,\\ d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA);font-weight:400;font-style:normal}:root{--swiper-theme-color: #007aff}:host{position:relative;display:block;margin-left:auto;margin-right:auto;z-index:1}.swiper{margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1;display:block}.swiper-vertical>.swiper-wrapper{flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:flex;transition-property:transform;transition-timing-function:ease;transition-timing-function:initial;transition-timing-function:var(--swiper-wrapper-transition-timing-function, initial);box-sizing:content-box}.swiper-android .swiper-slide,.swiper-ios .swiper-slide,.swiper-wrapper{transform:translateZ(0)}.swiper-horizontal{touch-action:pan-y}.swiper-vertical{touch-action:pan-x}.swiper-slide{flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform;display:block}.swiper-slide-invisible-blank{visibility:hidden}.swiper-autoheight,.swiper-autoheight .swiper-slide{height:auto}.swiper-autoheight .swiper-wrapper{align-items:flex-start;transition-property:transform,height}.swiper-backface-hidden .swiper-slide{transform:translateZ(0);backface-visibility:hidden}.swiper-3d.swiper-css-mode .swiper-wrapper{perspective:1200px}.swiper-3d .swiper-wrapper{transform-style:preserve-3d}.swiper-3d{perspective:1200px}.swiper-3d .swiper-slide,.swiper-3d .swiper-cube-shadow{transform-style:preserve-3d}.swiper-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-css-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:start start}.swiper-css-mode.swiper-horizontal>.swiper-wrapper{scroll-snap-type:x mandatory}.swiper-css-mode.swiper-vertical>.swiper-wrapper{scroll-snap-type:y mandatory}.swiper-css-mode.swiper-free-mode>.swiper-wrapper{scroll-snap-type:none}.swiper-css-mode.swiper-free-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:none}.swiper-css-mode.swiper-centered>.swiper-wrapper:before{content:"";flex-shrink:0;order:9999}.swiper-css-mode.swiper-centered>.swiper-wrapper>.swiper-slide{scroll-snap-align:center center;scroll-snap-stop:always}.swiper-css-mode.swiper-centered.swiper-horizontal>.swiper-wrapper>.swiper-slide:first-child{margin-left:var(--swiper-centered-offset-before)}.swiper-css-mode.swiper-centered.swiper-horizontal>.swiper-wrapper:before{height:100%;min-height:1px;width:var(--swiper-centered-offset-after)}.swiper-css-mode.swiper-centered.swiper-vertical>.swiper-wrapper>.swiper-slide:first-child{margin-top:var(--swiper-centered-offset-before)}.swiper-css-mode.swiper-centered.swiper-vertical>.swiper-wrapper:before{width:100%;min-width:1px;height:var(--swiper-centered-offset-after)}.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top,.swiper-3d .swiper-slide-shadow-bottom{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-3d .swiper-slide-shadow{background:#00000026}.swiper-3d .swiper-slide-shadow-left{background-image:-webkit-gradient(linear,right top,left top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:-webkit-linear-gradient(right,rgba(0,0,0,.5),rgba(0,0,0,0));background-image:-moz-linear-gradient(right,rgba(0,0,0,.5),rgba(0,0,0,0));background-image:linear-gradient(to left,#00000080,#0000)}.swiper-3d .swiper-slide-shadow-right{background-image:-webkit-gradient(linear,left top,right top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:-webkit-linear-gradient(left,rgba(0,0,0,.5),rgba(0,0,0,0));background-image:-moz-linear-gradient(left,rgba(0,0,0,.5),rgba(0,0,0,0));background-image:linear-gradient(to right,#00000080,#0000)}.swiper-3d .swiper-slide-shadow-top{background-image:-webkit-gradient(linear,left bottom,left top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:-webkit-linear-gradient(bottom,rgba(0,0,0,.5),rgba(0,0,0,0));background-image:-moz-linear-gradient(bottom,rgba(0,0,0,.5),rgba(0,0,0,0));background-image:linear-gradient(to top,#00000080,#0000)}.swiper-3d .swiper-slide-shadow-bottom{background-image:-webkit-gradient(linear,left top,left bottom,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:-webkit-linear-gradient(top,rgba(0,0,0,.5),rgba(0,0,0,0));background-image:-moz-linear-gradient(top,rgba(0,0,0,.5),rgba(0,0,0,0));background-image:linear-gradient(to bottom,#00000080,#0000)}.swiper-lazy-preloader{width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;transform-origin:50%;box-sizing:border-box;border:4px solid #007aff;border:4px solid var(--swiper-preloader-color, var(--swiper-theme-color));border-radius:50%;border-top-color:transparent}.swiper:not(.swiper-watch-progress) .swiper-lazy-preloader,.swiper-watch-progress .swiper-slide-visible .swiper-lazy-preloader{animation:swiper-preloader-spin 1s infinite linear}.swiper-lazy-preloader-white{--swiper-preloader-color: #fff}.swiper-lazy-preloader-black{--swiper-preloader-color: #000}@keyframes swiper-preloader-spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}:root{--swiper-navigation-size: 44px}.swiper-button-prev,.swiper-button-next{position:absolute;top:50%;top:var(--swiper-navigation-top-offset, 50%);width:-webkit-calc(44px / 44 * 27);width:-moz-calc(44px / 44 * 27);width:27px;width:-webkit-calc(var(--swiper-navigation-size) / 44 * 27);width:-moz-calc(var(--swiper-navigation-size) / 44 * 27);width:calc(var(--swiper-navigation-size) / 44 * 27);height:44px;height:var(--swiper-navigation-size);margin-top:-webkit-calc(0px - (44px / 2));margin-top:-moz-calc(0px - (44px / 2));margin-top:-22px;margin-top:-webkit-calc(0px - (var(--swiper-navigation-size) / 2));margin-top:-moz-calc(0px - (var(--swiper-navigation-size) / 2));margin-top:calc(0px - (var(--swiper-navigation-size) / 2));z-index:10;cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:flex;align-items:center;justify-content:center;color:var(--swiper-navigation-color, var(--swiper-theme-color))}.swiper-button-prev.swiper-button-disabled,.swiper-button-next.swiper-button-disabled{opacity:.35;cursor:auto;pointer-events:none}.swiper-button-prev.swiper-button-hidden,.swiper-button-next.swiper-button-hidden{opacity:0;cursor:auto;pointer-events:none}.swiper-navigation-disabled .swiper-button-prev,.swiper-navigation-disabled .swiper-button-next{display:none!important}.swiper-button-prev svg,.swiper-button-next svg{width:100%;height:100%;-o-object-fit:contain;object-fit:contain;transform-origin:center}.swiper-rtl .swiper-button-prev svg,.swiper-rtl .swiper-button-next svg{transform:rotate(180deg)}.swiper-button-prev,.swiper-rtl .swiper-button-next{left:10px;left:var(--swiper-navigation-sides-offset, 10px);right:auto}.swiper-button-lock{display:none}.swiper-button-prev:after,.swiper-button-next:after{font-family:swiper-icons;font-size:44px;font-size:var(--swiper-navigation-size);text-transform:none!important;letter-spacing:0;font-feature-settings:;font-variant:normal;font-variant:initial;line-height:1}.swiper-button-prev:after,.swiper-rtl .swiper-button-next:after{content:"prev"}.swiper-button-next,.swiper-rtl .swiper-button-prev{right:10px;right:var(--swiper-navigation-sides-offset, 10px);left:auto}.swiper-button-next:after,.swiper-rtl .swiper-button-prev:after{content:"next"}.swiper-pagination{position:absolute;text-align:center;transition:.3s opacity;transform:translateZ(0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-pagination-disabled>.swiper-pagination,.swiper-pagination.swiper-pagination-disabled{display:none!important}.swiper-pagination-fraction,.swiper-pagination-custom,.swiper-horizontal>.swiper-pagination-bullets,.swiper-pagination-bullets.swiper-pagination-horizontal{bottom:8px;bottom:var(--swiper-pagination-bottom, 8px);top:auto;top:var(--swiper-pagination-top, auto);left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transform:scale(.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active,.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{transform:scale(.33)}.swiper-pagination-bullet{width:8px;width:var(--swiper-pagination-bullet-width, var(--swiper-pagination-bullet-size, 8px));height:8px;height:var(--swiper-pagination-bullet-height, var(--swiper-pagination-bullet-size, 8px));display:inline-block;border-radius:50%;border-radius:var(--swiper-pagination-bullet-border-radius, 50%);background:#000;background:var(--swiper-pagination-bullet-inactive-color, #000);opacity:.2;opacity:var(--swiper-pagination-bullet-inactive-opacity, .2)}button.swiper-pagination-bullet{border:none;margin:0;padding:0;box-shadow:none;-webkit-appearance:none;-moz-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet:only-child{display:none!important}.swiper-pagination-bullet-active{opacity:1;opacity:var(--swiper-pagination-bullet-opacity, 1);background:var(--swiper-pagination-color, var(--swiper-theme-color))}.swiper-vertical>.swiper-pagination-bullets,.swiper-pagination-vertical.swiper-pagination-bullets{right:8px;right:var(--swiper-pagination-right, 8px);left:auto;left:var(--swiper-pagination-left, auto);top:50%;transform:translate3d(0,-50%,0)}.swiper-vertical>.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-pagination-vertical.swiper-pagination-bullets .swiper-pagination-bullet{margin:6px 0;margin:var(--swiper-pagination-bullet-vertical-gap, 6px) 0;display:block}.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;transform:translateY(-50%);width:8px}.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;transition:.2s transform,.2s top}.swiper-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 4px;margin:0 var(--swiper-pagination-bullet-horizontal-gap, 4px)}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;transform:translate(-50%);white-space:nowrap}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s left}.swiper-horizontal.swiper-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s right}.swiper-pagination-fraction{color:inherit;color:var(--swiper-pagination-fraction-color, inherit)}.swiper-pagination-progressbar{background:#00000040;background:var(--swiper-pagination-progressbar-bg-color, rgba(0, 0, 0, .25));position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--swiper-pagination-color, var(--swiper-theme-color));position:absolute;left:0;top:0;width:100%;height:100%;transform:scale(0);transform-origin:left top}.swiper-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{transform-origin:right top}.swiper-horizontal>.swiper-pagination-progressbar,.swiper-pagination-progressbar.swiper-pagination-horizontal,.swiper-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-vertical.swiper-pagination-progressbar-opposite{width:100%;height:4px;height:var(--swiper-pagination-progressbar-size, 4px);left:0;top:0}.swiper-vertical>.swiper-pagination-progressbar,.swiper-pagination-progressbar.swiper-pagination-vertical,.swiper-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite{width:4px;width:var(--swiper-pagination-progressbar-size, 4px);height:100%;left:0;top:0}.swiper-pagination-lock{display:none}*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgba(59, 130, 246, .5);--tw-ring-offset-shadow: 0 0 rgba(0,0,0,0);--tw-ring-shadow: 0 0 rgba(0,0,0,0);--tw-shadow: 0 0 rgba(0,0,0,0);--tw-shadow-colored: 0 0 rgba(0,0,0,0);--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgba(59, 130, 246, .5);--tw-ring-offset-shadow: 0 0 rgba(0,0,0,0);--tw-ring-shadow: 0 0 rgba(0,0,0,0);--tw-shadow: 0 0 rgba(0,0,0,0);--tw-shadow-colored: 0 0 rgba(0,0,0,0);--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.os-static{position:static}.os-absolute{position:absolute}.os-relative{position:relative}.os-right-\\[18px\\]{right:18px}.os-top-\\[50\\%\\]{top:50%}.os-m-0{margin:0}.os-mt-\\[12px\\]{margin-top:12px}.os-mt-\\[16px\\]{margin-top:16px}.os-mt-\\[20px\\]{margin-top:20px}.os-flex{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:flex}.os-hidden{display:none}.os-h-\\[104px\\]{height:104px}.os-h-\\[15px\\]{height:15px}.os-h-\\[2px\\]{height:2px}.os-h-\\[50px\\]{height:50px}.os-h-full{height:100%}.\\!os-w-max{width:-moz-max-content!important;width:-webkit-max-content!important;width:max-content!important}.os-w-\\[104px\\]{width:104px}.os-w-\\[10px\\]{width:10px}.os-w-\\[335px\\]{width:335px}.os-w-\\[60\\%\\]{width:60%}.os-w-\\[60px\\]{width:60px}.os-w-fit{width:-moz-fit-content;width:-webkit-fit-content;width:fit-content}.os-w-full{width:100%}.-os-translate-y-2\\/4{--tw-translate-y: -50%;transform:translate(var(--tw-translate-x),-50%) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.os-cursor-pointer{cursor:pointer}.os-flex-col{flex-direction:column}.os-items-center{align-items:center}.os-justify-center{justify-content:center}.os-justify-between{justify-content:space-between}.os-gap-\\[16px\\]{gap:16px}.os-gap-\\[6px\\]{gap:6px}.os-gap-\\[8px\\]{gap:8px}.os-overflow-hidden{overflow:hidden}.os-rounded-\\[4px\\]{border-radius:4px}.os-border-\\[1px\\]{border-width:1px}.os-border-\\[2px\\]{border-width:2px}.os-border-t-\\[1px\\]{border-top-width:1px}.os-border-solid{border-style:solid}.os-border-dashed{border-style:dashed}.os-border-none{border-style:none}.os-border-\\[\\#dddee9\\]{--tw-border-opacity: 1;border-color:#dddee9;border-color:rgba(221,222,233,var(--tw-border-opacity))}.os-border-\\[\\#e68626\\]{--tw-border-opacity: 1;border-color:#e68626;border-color:rgba(230,134,38,var(--tw-border-opacity))}.os-bg-\\[\\#0373bd\\]{--tw-bg-opacity: 1;background-color:#0373bd;background-color:rgba(3,115,189,var(--tw-bg-opacity))}.os-bg-transparent{background-color:transparent}.os-bg-\\[linear-gradient\\(to_bottom\\,_\\#ffc842\\,_\\#f48818\\)\\]{background-image:-webkit-gradient(linear,left top,left bottom,from(#ffc842),to(#f48818));background-image:-webkit-linear-gradient(top,#ffc842,#f48818);background-image:-moz-linear-gradient(top,#ffc842,#f48818);background-image:linear-gradient(to bottom,#ffc842,#f48818)}.os-p-0{padding:0}.os-p-\\[10px\\]{padding:10px}.os-p-\\[8px\\]{padding:8px}.os-px-\\[10px\\]{padding-left:10px;padding-right:10px}.os-px-\\[12px\\]{padding-left:12px;padding-right:12px}.os-px-\\[20px\\]{padding-left:20px;padding-right:20px}.os-py-\\[12px\\]{padding-top:12px;padding-bottom:12px}.os-py-\\[8px\\]{padding-top:8px;padding-bottom:8px}.os-pb-\\[16px\\]{padding-bottom:16px}.os-pb-\\[20px\\]{padding-bottom:20px}.os-text-left{text-align:left}.os-text-center{text-align:center}.os-text-\\[12px\\]{font-size:12px}.os-text-\\[14px\\]{font-size:14px}.os-text-\\[16px\\]{font-size:16px}.os-text-\\[18px\\]{font-size:18px}.os-text-\\[30px\\]{font-size:30px}.os-font-bold{font-weight:700}.os-font-normal{font-weight:400}.os-leading-\\[20px\\]{line-height:20px}.os-leading-\\[22px\\]{line-height:22px}.os-text-\\[\\#0373bd\\]{--tw-text-opacity: 1;color:#0373bd;color:rgba(3,115,189,var(--tw-text-opacity))}.os-text-\\[\\#253189\\]{--tw-text-opacity: 1;color:#253189;color:rgba(37,49,137,var(--tw-text-opacity))}.os-text-\\[\\#333\\]{--tw-text-opacity: 1;color:#333;color:rgba(51,51,51,var(--tw-text-opacity))}.os-text-\\[\\#555\\]{--tw-text-opacity: 1;color:#555;color:rgba(85,85,85,var(--tw-text-opacity))}.os-text-\\[\\#767676\\]{--tw-text-opacity: 1;color:#767676;color:rgba(118,118,118,var(--tw-text-opacity))}.os-text-\\[\\#900\\]{--tw-text-opacity: 1;color:#900;color:rgba(153,0,0,var(--tw-text-opacity))}.os-text-white{--tw-text-opacity: 1;color:#fff;color:rgba(255,255,255,var(--tw-text-opacity))}.os-line-through{text-decoration-line:line-through}button{cursor:pointer}.osborder:not(:first-child){border-left:1px solid #dddee9}dialog::backdrop{-webkit-backdrop-filter:blur(5px);backdrop-filter:blur(5px);background-color:#273038a6}dialog{font-family:Arial}dialog .swiper-slide{width:60%!important}dialog a{-webkit-text-decoration:none;text-decoration:none}dialog a:focus,dialog a:hover{-webkit-text-decoration:none;text-decoration:none;color:inherit}body:has(dialog[open]){overflow:hidden}@media screen and (max-width: 768px){div.screenpop #color_search_pop a.action-button-orange{margin-right:0;width:200px}.total_block .ship span{background:none!important}.total_block .discount span:first-child{background-color:#ffc}}.after\\:os-text-\\[10px\\]:after{content:var(--tw-content);font-size:10px}.focus-within\\:os-outline-none:focus-within{outline:2px solid transparent;outline-offset:2px}.hover\\:os-text-\\[\\#333\\]:hover{--tw-text-opacity: 1;color:#333;color:rgba(51,51,51,var(--tw-text-opacity))}.focus\\:os-text-\\[\\#333\\]:focus{--tw-text-opacity: 1;color:#333;color:rgba(51,51,51,var(--tw-text-opacity))}.focus\\:os-outline-none:focus{outline:2px solid transparent;outline-offset:2px}@media (min-width: 768px){.md\\:os-block{display:block}.md\\:os-flex{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:flex}.md\\:os-w-\\[460px\\]{width:460px}.md\\:os-w-full{width:100%}.md\\:os-flex-row{flex-direction:row}.md\\:os-px-\\[30px\\]{padding-left:30px;padding-right:30px}.md\\:os-pb-\\[20px\\]{padding-bottom:20px}.md\\:os-pb-\\[30px\\]{padding-bottom:30px}.md\\:os-text-\\[16px\\]{font-size:16px}.md\\:os-text-\\[18px\\]{font-size:18px}.md\\:os-text-\\[20px\\]{font-size:20px}.md\\:os-text-\\[36px\\]{font-size:36px}}.\\[\\&_svg\\]\\:os-w-full svg{width:100%}')),document.head.appendChild(t)}}catch(i){console.error("vite-plugin-css-injected-by-js",i)}})();
(function() {
  "use strict";
  function ce(s) {
    return s !== null && typeof s == "object" && "constructor" in s && s.constructor === Object;
  }
  function Q(s, e) {
    s === void 0 && (s = {}), e === void 0 && (e = {}), Object.keys(e).forEach((t) => {
      typeof s[t] > "u" ? s[t] = e[t] : ce(e[t]) && ce(s[t]) && Object.keys(e[t]).length > 0 && Q(s[t], e[t]);
    });
  }
  const pe = {
    body: {},
    addEventListener() {
    },
    removeEventListener() {
    },
    activeElement: {
      blur() {
      },
      nodeName: ""
    },
    querySelector() {
      return null;
    },
    querySelectorAll() {
      return [];
    },
    getElementById() {
      return null;
    },
    createEvent() {
      return {
        initEvent() {
        }
      };
    },
    createElement() {
      return {
        children: [],
        childNodes: [],
        style: {},
        setAttribute() {
        },
        getElementsByTagName() {
          return [];
        }
      };
    },
    createElementNS() {
      return {};
    },
    importNode() {
      return null;
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    }
  };
  function F() {
    const s = typeof document < "u" ? document : {};
    return Q(s, pe), s;
  }
  const Ie = {
    document: pe,
    navigator: {
      userAgent: ""
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    },
    history: {
      replaceState() {
      },
      pushState() {
      },
      go() {
      },
      back() {
      }
    },
    CustomEvent: function() {
      return this;
    },
    addEventListener() {
    },
    removeEventListener() {
    },
    getComputedStyle() {
      return {
        getPropertyValue() {
          return "";
        }
      };
    },
    Image() {
    },
    Date() {
    },
    screen: {},
    setTimeout() {
    },
    clearTimeout() {
    },
    matchMedia() {
      return {};
    },
    requestAnimationFrame(s) {
      return typeof setTimeout > "u" ? (s(), null) : setTimeout(s, 0);
    },
    cancelAnimationFrame(s) {
      typeof setTimeout > "u" || clearTimeout(s);
    }
  };
  function O() {
    const s = typeof window < "u" ? window : {};
    return Q(s, Ie), s;
  }
  function ke(s) {
    return s === void 0 && (s = ""), s.trim().split(" ").filter((e) => !!e.trim());
  }
  function Ae(s) {
    const e = s;
    Object.keys(e).forEach((t) => {
      try {
        e[t] = null;
      } catch {
      }
      try {
        delete e[t];
      } catch {
      }
    });
  }
  function ee(s, e) {
    return e === void 0 && (e = 0), setTimeout(s, e);
  }
  function j() {
    return Date.now();
  }
  function Oe(s) {
    const e = O();
    let t;
    return e.getComputedStyle && (t = e.getComputedStyle(s, null)), !t && s.currentStyle && (t = s.currentStyle), t || (t = s.style), t;
  }
  function ze(s, e) {
    e === void 0 && (e = "x");
    const t = O();
    let i, r, n;
    const l = Oe(s);
    return t.WebKitCSSMatrix ? (r = l.transform || l.webkitTransform, r.split(",").length > 6 && (r = r.split(", ").map((a) => a.replace(",", ".")).join(", ")), n = new t.WebKitCSSMatrix(r === "none" ? "" : r)) : (n = l.MozTransform || l.OTransform || l.MsTransform || l.msTransform || l.transform || l.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), i = n.toString().split(",")), e === "x" && (t.WebKitCSSMatrix ? r = n.m41 : i.length === 16 ? r = parseFloat(i[12]) : r = parseFloat(i[4])), e === "y" && (t.WebKitCSSMatrix ? r = n.m42 : i.length === 16 ? r = parseFloat(i[13]) : r = parseFloat(i[5])), r || 0;
  }
  function Y(s) {
    return typeof s == "object" && s !== null && s.constructor && Object.prototype.toString.call(s).slice(8, -1) === "Object";
  }
  function $e(s) {
    return typeof window < "u" && typeof window.HTMLElement < "u" ? s instanceof HTMLElement : s && (s.nodeType === 1 || s.nodeType === 11);
  }
  function z() {
    const s = Object(arguments.length <= 0 ? void 0 : arguments[0]), e = ["__proto__", "constructor", "prototype"];
    for (let t = 1; t < arguments.length; t += 1) {
      const i = t < 0 || arguments.length <= t ? void 0 : arguments[t];
      if (i != null && !$e(i)) {
        const r = Object.keys(Object(i)).filter((n) => e.indexOf(n) < 0);
        for (let n = 0, l = r.length; n < l; n += 1) {
          const a = r[n], o = Object.getOwnPropertyDescriptor(i, a);
          o !== void 0 && o.enumerable && (Y(s[a]) && Y(i[a]) ? i[a].__swiper__ ? s[a] = i[a] : z(s[a], i[a]) : !Y(s[a]) && Y(i[a]) ? (s[a] = {}, i[a].__swiper__ ? s[a] = i[a] : z(s[a], i[a])) : s[a] = i[a]);
        }
      }
    }
    return s;
  }
  function W(s, e, t) {
    s.style.setProperty(e, t);
  }
  function ue(s) {
    let {
      swiper: e,
      targetPosition: t,
      side: i
    } = s;
    const r = O(), n = -e.translate;
    let l = null, a;
    const o = e.params.speed;
    e.wrapperEl.style.scrollSnapType = "none", r.cancelAnimationFrame(e.cssModeFrameID);
    const c = t > n ? "next" : "prev", p = (g, h) => c === "next" && g >= h || c === "prev" && g <= h, f = () => {
      a = (/* @__PURE__ */ new Date()).getTime(), l === null && (l = a);
      const g = Math.max(Math.min((a - l) / o, 1), 0), h = 0.5 - Math.cos(g * Math.PI) / 2;
      let m = n + h * (t - n);
      if (p(m, t) && (m = t), e.wrapperEl.scrollTo({
        [i]: m
      }), p(m, t)) {
        e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.scrollSnapType = "", setTimeout(() => {
          e.wrapperEl.style.overflow = "", e.wrapperEl.scrollTo({
            [i]: m
          });
        }), r.cancelAnimationFrame(e.cssModeFrameID);
        return;
      }
      e.cssModeFrameID = r.requestAnimationFrame(f);
    };
    f();
  }
  function _(s, e) {
    return e === void 0 && (e = ""), [...s.children].filter((t) => t.matches(e));
  }
  function X(s) {
    try {
      console.warn(s);
      return;
    } catch {
    }
  }
  function Z(s, e) {
    e === void 0 && (e = []);
    const t = document.createElement(s);
    return t.classList.add(...Array.isArray(e) ? e : ke(e)), t;
  }
  function De(s, e) {
    const t = [];
    for (; s.previousElementSibling; ) {
      const i = s.previousElementSibling;
      e ? i.matches(e) && t.push(i) : t.push(i), s = i;
    }
    return t;
  }
  function _e(s, e) {
    const t = [];
    for (; s.nextElementSibling; ) {
      const i = s.nextElementSibling;
      e ? i.matches(e) && t.push(i) : t.push(i), s = i;
    }
    return t;
  }
  function G(s, e) {
    return O().getComputedStyle(s, null).getPropertyValue(e);
  }
  function U(s) {
    let e = s, t;
    if (e) {
      for (t = 0; (e = e.previousSibling) !== null; )
        e.nodeType === 1 && (t += 1);
      return t;
    }
  }
  function fe(s, e) {
    const t = [];
    let i = s.parentElement;
    for (; i; )
      e ? i.matches(e) && t.push(i) : t.push(i), i = i.parentElement;
    return t;
  }
  function te(s, e, t) {
    const i = O();
    return t ? s[e === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(i.getComputedStyle(s, null).getPropertyValue(e === "width" ? "margin-right" : "margin-top")) + parseFloat(i.getComputedStyle(s, null).getPropertyValue(e === "width" ? "margin-left" : "margin-bottom")) : s.offsetWidth;
  }
  function k(s) {
    return (Array.isArray(s) ? s : [s]).filter((e) => !!e);
  }
  let se;
  function Ge() {
    const s = O(), e = F();
    return {
      smoothScroll: e.documentElement && e.documentElement.style && "scrollBehavior" in e.documentElement.style,
      touch: !!("ontouchstart" in s || s.DocumentTouch && e instanceof s.DocumentTouch)
    };
  }
  function me() {
    return se || (se = Ge()), se;
  }
  let ie;
  function Be(s) {
    let {
      userAgent: e
    } = s === void 0 ? {} : s;
    const t = me(), i = O(), r = i.navigator.platform, n = e || i.navigator.userAgent, l = {
      ios: !1,
      android: !1
    }, a = i.screen.width, o = i.screen.height, c = n.match(/(Android);?[\s\/]+([\d.]+)?/);
    let p = n.match(/(iPad).*OS\s([\d_]+)/);
    const f = n.match(/(iPod)(.*OS\s([\d_]+))?/), g = !p && n.match(/(iPhone\sOS|iOS)\s([\d_]+)/), h = r === "Win32";
    let m = r === "MacIntel";
    const w = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
    return !p && m && t.touch && w.indexOf(`${a}x${o}`) >= 0 && (p = n.match(/(Version)\/([\d.]+)/), p || (p = [0, 1, "13_0_0"]), m = !1), c && !h && (l.os = "android", l.android = !0), (p || g || f) && (l.os = "ios", l.ios = !0), l;
  }
  function he(s) {
    return s === void 0 && (s = {}), ie || (ie = Be(s)), ie;
  }
  let ne;
  function Ve() {
    const s = O(), e = he();
    let t = !1;
    function i() {
      const a = s.navigator.userAgent.toLowerCase();
      return a.indexOf("safari") >= 0 && a.indexOf("chrome") < 0 && a.indexOf("android") < 0;
    }
    if (i()) {
      const a = String(s.navigator.userAgent);
      if (a.includes("Version/")) {
        const [o, c] = a.split("Version/")[1].split(" ")[0].split(".").map((p) => Number(p));
        t = o < 16 || o === 16 && c < 2;
      }
    }
    const r = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(s.navigator.userAgent), n = i(), l = n || r && e.ios;
    return {
      isSafari: t || n,
      needPerspectiveFix: t,
      need3dFix: l,
      isWebView: r
    };
  }
  function Fe() {
    return ne || (ne = Ve()), ne;
  }
  function He(s) {
    let {
      swiper: e,
      on: t,
      emit: i
    } = s;
    const r = O();
    let n = null, l = null;
    const a = () => {
      !e || e.destroyed || !e.initialized || (i("beforeResize"), i("resize"));
    }, o = () => {
      !e || e.destroyed || !e.initialized || (n = new ResizeObserver((f) => {
        l = r.requestAnimationFrame(() => {
          const {
            width: g,
            height: h
          } = e;
          let m = g, w = h;
          f.forEach((b) => {
            let {
              contentBoxSize: d,
              contentRect: u,
              target: v
            } = b;
            v && v !== e.el || (m = u ? u.width : (d[0] || d).inlineSize, w = u ? u.height : (d[0] || d).blockSize);
          }), (m !== g || w !== h) && a();
        });
      }), n.observe(e.el));
    }, c = () => {
      l && r.cancelAnimationFrame(l), n && n.unobserve && e.el && (n.unobserve(e.el), n = null);
    }, p = () => {
      !e || e.destroyed || !e.initialized || i("orientationchange");
    };
    t("init", () => {
      if (e.params.resizeObserver && typeof r.ResizeObserver < "u") {
        o();
        return;
      }
      r.addEventListener("resize", a), r.addEventListener("orientationchange", p);
    }), t("destroy", () => {
      c(), r.removeEventListener("resize", a), r.removeEventListener("orientationchange", p);
    });
  }
  function Ne(s) {
    let {
      swiper: e,
      extendParams: t,
      on: i,
      emit: r
    } = s;
    const n = [], l = O(), a = function(p, f) {
      f === void 0 && (f = {});
      const g = l.MutationObserver || l.WebkitMutationObserver, h = new g((m) => {
        if (e.__preventObserver__)
          return;
        if (m.length === 1) {
          r("observerUpdate", m[0]);
          return;
        }
        const w = function() {
          r("observerUpdate", m[0]);
        };
        l.requestAnimationFrame ? l.requestAnimationFrame(w) : l.setTimeout(w, 0);
      });
      h.observe(p, {
        attributes: typeof f.attributes > "u" ? !0 : f.attributes,
        childList: typeof f.childList > "u" ? !0 : f.childList,
        characterData: typeof f.characterData > "u" ? !0 : f.characterData
      }), n.push(h);
    }, o = () => {
      if (e.params.observer) {
        if (e.params.observeParents) {
          const p = fe(e.hostEl);
          for (let f = 0; f < p.length; f += 1)
            a(p[f]);
        }
        a(e.hostEl, {
          childList: e.params.observeSlideChildren
        }), a(e.wrapperEl, {
          attributes: !1
        });
      }
    }, c = () => {
      n.forEach((p) => {
        p.disconnect();
      }), n.splice(0, n.length);
    };
    t({
      observer: !1,
      observeParents: !1,
      observeSlideChildren: !1
    }), i("init", o), i("destroy", c);
  }
  var Re = {
    on(s, e, t) {
      const i = this;
      if (!i.eventsListeners || i.destroyed || typeof e != "function")
        return i;
      const r = t ? "unshift" : "push";
      return s.split(" ").forEach((n) => {
        i.eventsListeners[n] || (i.eventsListeners[n] = []), i.eventsListeners[n][r](e);
      }), i;
    },
    once(s, e, t) {
      const i = this;
      if (!i.eventsListeners || i.destroyed || typeof e != "function")
        return i;
      function r() {
        i.off(s, r), r.__emitterProxy && delete r.__emitterProxy;
        for (var n = arguments.length, l = new Array(n), a = 0; a < n; a++)
          l[a] = arguments[a];
        e.apply(i, l);
      }
      return r.__emitterProxy = e, i.on(s, r, t);
    },
    onAny(s, e) {
      const t = this;
      if (!t.eventsListeners || t.destroyed || typeof s != "function")
        return t;
      const i = e ? "unshift" : "push";
      return t.eventsAnyListeners.indexOf(s) < 0 && t.eventsAnyListeners[i](s), t;
    },
    offAny(s) {
      const e = this;
      if (!e.eventsListeners || e.destroyed || !e.eventsAnyListeners)
        return e;
      const t = e.eventsAnyListeners.indexOf(s);
      return t >= 0 && e.eventsAnyListeners.splice(t, 1), e;
    },
    off(s, e) {
      const t = this;
      return !t.eventsListeners || t.destroyed || !t.eventsListeners || s.split(" ").forEach((i) => {
        typeof e > "u" ? t.eventsListeners[i] = [] : t.eventsListeners[i] && t.eventsListeners[i].forEach((r, n) => {
          (r === e || r.__emitterProxy && r.__emitterProxy === e) && t.eventsListeners[i].splice(n, 1);
        });
      }), t;
    },
    emit() {
      const s = this;
      if (!s.eventsListeners || s.destroyed || !s.eventsListeners)
        return s;
      let e, t, i;
      for (var r = arguments.length, n = new Array(r), l = 0; l < r; l++)
        n[l] = arguments[l];
      return typeof n[0] == "string" || Array.isArray(n[0]) ? (e = n[0], t = n.slice(1, n.length), i = s) : (e = n[0].events, t = n[0].data, i = n[0].context || s), t.unshift(i), (Array.isArray(e) ? e : e.split(" ")).forEach((o) => {
        s.eventsAnyListeners && s.eventsAnyListeners.length && s.eventsAnyListeners.forEach((c) => {
          c.apply(i, [o, ...t]);
        }), s.eventsListeners && s.eventsListeners[o] && s.eventsListeners[o].forEach((c) => {
          c.apply(i, t);
        });
      }), s;
    }
  };
  function qe() {
    const s = this;
    let e, t;
    const i = s.el;
    typeof s.params.width < "u" && s.params.width !== null ? e = s.params.width : e = i.clientWidth, typeof s.params.height < "u" && s.params.height !== null ? t = s.params.height : t = i.clientHeight, !(e === 0 && s.isHorizontal() || t === 0 && s.isVertical()) && (e = e - parseInt(G(i, "padding-left") || 0, 10) - parseInt(G(i, "padding-right") || 0, 10), t = t - parseInt(G(i, "padding-top") || 0, 10) - parseInt(G(i, "padding-bottom") || 0, 10), Number.isNaN(e) && (e = 0), Number.isNaN(t) && (t = 0), Object.assign(s, {
      width: e,
      height: t,
      size: s.isHorizontal() ? e : t
    }));
  }
  function je() {
    const s = this;
    function e(S, E) {
      return parseFloat(S.getPropertyValue(s.getDirectionLabel(E)) || 0);
    }
    const t = s.params, {
      wrapperEl: i,
      slidesEl: r,
      size: n,
      rtlTranslate: l,
      wrongRTL: a
    } = s, o = s.virtual && t.virtual.enabled, c = o ? s.virtual.slides.length : s.slides.length, p = _(r, `.${s.params.slideClass}, swiper-slide`), f = o ? s.virtual.slides.length : p.length;
    let g = [];
    const h = [], m = [];
    let w = t.slidesOffsetBefore;
    typeof w == "function" && (w = t.slidesOffsetBefore.call(s));
    let b = t.slidesOffsetAfter;
    typeof b == "function" && (b = t.slidesOffsetAfter.call(s));
    const d = s.snapGrid.length, u = s.slidesGrid.length;
    let v = t.spaceBetween, x = -w, y = 0, M = 0;
    if (typeof n > "u")
      return;
    typeof v == "string" && v.indexOf("%") >= 0 ? v = parseFloat(v.replace("%", "")) / 100 * n : typeof v == "string" && (v = parseFloat(v)), s.virtualSize = -v, p.forEach((S) => {
      l ? S.style.marginLeft = "" : S.style.marginRight = "", S.style.marginBottom = "", S.style.marginTop = "";
    }), t.centeredSlides && t.cssMode && (W(i, "--swiper-centered-offset-before", ""), W(i, "--swiper-centered-offset-after", ""));
    const D = t.grid && t.grid.rows > 1 && s.grid;
    D ? s.grid.initSlides(p) : s.grid && s.grid.unsetSlides();
    let L;
    const A = t.slidesPerView === "auto" && t.breakpoints && Object.keys(t.breakpoints).filter((S) => typeof t.breakpoints[S].slidesPerView < "u").length > 0;
    for (let S = 0; S < f; S += 1) {
      L = 0;
      let E;
      if (p[S] && (E = p[S]), D && s.grid.updateSlide(S, E, p), !(p[S] && G(E, "display") === "none")) {
        if (t.slidesPerView === "auto") {
          A && (p[S].style[s.getDirectionLabel("width")] = "");
          const C = getComputedStyle(E), T = E.style.transform, P = E.style.webkitTransform;
          if (T && (E.style.transform = "none"), P && (E.style.webkitTransform = "none"), t.roundLengths)
            L = s.isHorizontal() ? te(E, "width", !0) : te(E, "height", !0);
          else {
            const I = e(C, "width"), B = e(C, "padding-left"), ls = e(C, "padding-right"), Le = e(C, "margin-left"), Pe = e(C, "margin-right"), Me = C.getPropertyValue("box-sizing");
            if (Me && Me === "border-box")
              L = I + Le + Pe;
            else {
              const {
                clientWidth: ds,
                offsetWidth: cs
              } = E;
              L = I + B + ls + Le + Pe + (cs - ds);
            }
          }
          T && (E.style.transform = T), P && (E.style.webkitTransform = P), t.roundLengths && (L = Math.floor(L));
        } else
          L = (n - (t.slidesPerView - 1) * v) / t.slidesPerView, t.roundLengths && (L = Math.floor(L)), p[S] && (p[S].style[s.getDirectionLabel("width")] = `${L}px`);
        p[S] && (p[S].swiperSlideSize = L), m.push(L), t.centeredSlides ? (x = x + L / 2 + y / 2 + v, y === 0 && S !== 0 && (x = x - n / 2 - v), S === 0 && (x = x - n / 2 - v), Math.abs(x) < 1 / 1e3 && (x = 0), t.roundLengths && (x = Math.floor(x)), M % t.slidesPerGroup === 0 && g.push(x), h.push(x)) : (t.roundLengths && (x = Math.floor(x)), (M - Math.min(s.params.slidesPerGroupSkip, M)) % s.params.slidesPerGroup === 0 && g.push(x), h.push(x), x = x + L + v), s.virtualSize += L + v, y = L, M += 1;
      }
    }
    if (s.virtualSize = Math.max(s.virtualSize, n) + b, l && a && (t.effect === "slide" || t.effect === "coverflow") && (i.style.width = `${s.virtualSize + v}px`), t.setWrapperSize && (i.style[s.getDirectionLabel("width")] = `${s.virtualSize + v}px`), D && s.grid.updateWrapperSize(L, g), !t.centeredSlides) {
      const S = [];
      for (let E = 0; E < g.length; E += 1) {
        let C = g[E];
        t.roundLengths && (C = Math.floor(C)), g[E] <= s.virtualSize - n && S.push(C);
      }
      g = S, Math.floor(s.virtualSize - n) - Math.floor(g[g.length - 1]) > 1 && g.push(s.virtualSize - n);
    }
    if (o && t.loop) {
      const S = m[0] + v;
      if (t.slidesPerGroup > 1) {
        const E = Math.ceil((s.virtual.slidesBefore + s.virtual.slidesAfter) / t.slidesPerGroup), C = S * t.slidesPerGroup;
        for (let T = 0; T < E; T += 1)
          g.push(g[g.length - 1] + C);
      }
      for (let E = 0; E < s.virtual.slidesBefore + s.virtual.slidesAfter; E += 1)
        t.slidesPerGroup === 1 && g.push(g[g.length - 1] + S), h.push(h[h.length - 1] + S), s.virtualSize += S;
    }
    if (g.length === 0 && (g = [0]), v !== 0) {
      const S = s.isHorizontal() && l ? "marginLeft" : s.getDirectionLabel("marginRight");
      p.filter((E, C) => !t.cssMode || t.loop ? !0 : C !== p.length - 1).forEach((E) => {
        E.style[S] = `${v}px`;
      });
    }
    if (t.centeredSlides && t.centeredSlidesBounds) {
      let S = 0;
      m.forEach((C) => {
        S += C + (v || 0);
      }), S -= v;
      const E = S - n;
      g = g.map((C) => C <= 0 ? -w : C > E ? E + b : C);
    }
    if (t.centerInsufficientSlides) {
      let S = 0;
      if (m.forEach((E) => {
        S += E + (v || 0);
      }), S -= v, S < n) {
        const E = (n - S) / 2;
        g.forEach((C, T) => {
          g[T] = C - E;
        }), h.forEach((C, T) => {
          h[T] = C + E;
        });
      }
    }
    if (Object.assign(s, {
      slides: p,
      snapGrid: g,
      slidesGrid: h,
      slidesSizesGrid: m
    }), t.centeredSlides && t.cssMode && !t.centeredSlidesBounds) {
      W(i, "--swiper-centered-offset-before", `${-g[0]}px`), W(i, "--swiper-centered-offset-after", `${s.size / 2 - m[m.length - 1] / 2}px`);
      const S = -s.snapGrid[0], E = -s.slidesGrid[0];
      s.snapGrid = s.snapGrid.map((C) => C + S), s.slidesGrid = s.slidesGrid.map((C) => C + E);
    }
    if (f !== c && s.emit("slidesLengthChange"), g.length !== d && (s.params.watchOverflow && s.checkOverflow(), s.emit("snapGridLengthChange")), h.length !== u && s.emit("slidesGridLengthChange"), t.watchSlidesProgress && s.updateSlidesOffset(), s.emit("slidesUpdated"), !o && !t.cssMode && (t.effect === "slide" || t.effect === "fade")) {
      const S = `${t.containerModifierClass}backface-hidden`, E = s.el.classList.contains(S);
      f <= t.maxBackfaceHiddenSlides ? E || s.el.classList.add(S) : E && s.el.classList.remove(S);
    }
  }
  function Ye(s) {
    const e = this, t = [], i = e.virtual && e.params.virtual.enabled;
    let r = 0, n;
    typeof s == "number" ? e.setTransition(s) : s === !0 && e.setTransition(e.params.speed);
    const l = (a) => i ? e.slides[e.getSlideIndexByData(a)] : e.slides[a];
    if (e.params.slidesPerView !== "auto" && e.params.slidesPerView > 1)
      if (e.params.centeredSlides)
        (e.visibleSlides || []).forEach((a) => {
          t.push(a);
        });
      else
        for (n = 0; n < Math.ceil(e.params.slidesPerView); n += 1) {
          const a = e.activeIndex + n;
          if (a > e.slides.length && !i)
            break;
          t.push(l(a));
        }
    else
      t.push(l(e.activeIndex));
    for (n = 0; n < t.length; n += 1)
      if (typeof t[n] < "u") {
        const a = t[n].offsetHeight;
        r = a > r ? a : r;
      }
    (r || r === 0) && (e.wrapperEl.style.height = `${r}px`);
  }
  function We() {
    const s = this, e = s.slides, t = s.isElement ? s.isHorizontal() ? s.wrapperEl.offsetLeft : s.wrapperEl.offsetTop : 0;
    for (let i = 0; i < e.length; i += 1)
      e[i].swiperSlideOffset = (s.isHorizontal() ? e[i].offsetLeft : e[i].offsetTop) - t - s.cssOverflowAdjustment();
  }
  function Xe(s) {
    s === void 0 && (s = this && this.translate || 0);
    const e = this, t = e.params, {
      slides: i,
      rtlTranslate: r,
      snapGrid: n
    } = e;
    if (i.length === 0)
      return;
    typeof i[0].swiperSlideOffset > "u" && e.updateSlidesOffset();
    let l = -s;
    r && (l = s), i.forEach((o) => {
      o.classList.remove(t.slideVisibleClass, t.slideFullyVisibleClass);
    }), e.visibleSlidesIndexes = [], e.visibleSlides = [];
    let a = t.spaceBetween;
    typeof a == "string" && a.indexOf("%") >= 0 ? a = parseFloat(a.replace("%", "")) / 100 * e.size : typeof a == "string" && (a = parseFloat(a));
    for (let o = 0; o < i.length; o += 1) {
      const c = i[o];
      let p = c.swiperSlideOffset;
      t.cssMode && t.centeredSlides && (p -= i[0].swiperSlideOffset);
      const f = (l + (t.centeredSlides ? e.minTranslate() : 0) - p) / (c.swiperSlideSize + a), g = (l - n[0] + (t.centeredSlides ? e.minTranslate() : 0) - p) / (c.swiperSlideSize + a), h = -(l - p), m = h + e.slidesSizesGrid[o], w = h >= 0 && h <= e.size - e.slidesSizesGrid[o];
      (h >= 0 && h < e.size - 1 || m > 1 && m <= e.size || h <= 0 && m >= e.size) && (e.visibleSlides.push(c), e.visibleSlidesIndexes.push(o), i[o].classList.add(t.slideVisibleClass)), w && i[o].classList.add(t.slideFullyVisibleClass), c.progress = r ? -f : f, c.originalProgress = r ? -g : g;
    }
  }
  function Ze(s) {
    const e = this;
    if (typeof s > "u") {
      const p = e.rtlTranslate ? -1 : 1;
      s = e && e.translate && e.translate * p || 0;
    }
    const t = e.params, i = e.maxTranslate() - e.minTranslate();
    let {
      progress: r,
      isBeginning: n,
      isEnd: l,
      progressLoop: a
    } = e;
    const o = n, c = l;
    if (i === 0)
      r = 0, n = !0, l = !0;
    else {
      r = (s - e.minTranslate()) / i;
      const p = Math.abs(s - e.minTranslate()) < 1, f = Math.abs(s - e.maxTranslate()) < 1;
      n = p || r <= 0, l = f || r >= 1, p && (r = 0), f && (r = 1);
    }
    if (t.loop) {
      const p = e.getSlideIndexByData(0), f = e.getSlideIndexByData(e.slides.length - 1), g = e.slidesGrid[p], h = e.slidesGrid[f], m = e.slidesGrid[e.slidesGrid.length - 1], w = Math.abs(s);
      w >= g ? a = (w - g) / m : a = (w + m - h) / m, a > 1 && (a -= 1);
    }
    Object.assign(e, {
      progress: r,
      progressLoop: a,
      isBeginning: n,
      isEnd: l
    }), (t.watchSlidesProgress || t.centeredSlides && t.autoHeight) && e.updateSlidesProgress(s), n && !o && e.emit("reachBeginning toEdge"), l && !c && e.emit("reachEnd toEdge"), (o && !n || c && !l) && e.emit("fromEdge"), e.emit("progress", r);
  }
  function Ue() {
    const s = this, {
      slides: e,
      params: t,
      slidesEl: i,
      activeIndex: r
    } = s, n = s.virtual && t.virtual.enabled, l = s.grid && t.grid && t.grid.rows > 1, a = (f) => _(i, `.${t.slideClass}${f}, swiper-slide${f}`)[0];
    e.forEach((f) => {
      f.classList.remove(t.slideActiveClass, t.slideNextClass, t.slidePrevClass);
    });
    let o, c, p;
    if (n)
      if (t.loop) {
        let f = r - s.virtual.slidesBefore;
        f < 0 && (f = s.virtual.slides.length + f), f >= s.virtual.slides.length && (f -= s.virtual.slides.length), o = a(`[data-swiper-slide-index="${f}"]`);
      } else
        o = a(`[data-swiper-slide-index="${r}"]`);
    else
      l ? (o = e.filter((f) => f.column === r)[0], p = e.filter((f) => f.column === r + 1)[0], c = e.filter((f) => f.column === r - 1)[0]) : o = e[r];
    o && (o.classList.add(t.slideActiveClass), l ? (p && p.classList.add(t.slideNextClass), c && c.classList.add(t.slidePrevClass)) : (p = _e(o, `.${t.slideClass}, swiper-slide`)[0], t.loop && !p && (p = e[0]), p && p.classList.add(t.slideNextClass), c = De(o, `.${t.slideClass}, swiper-slide`)[0], t.loop && !c === 0 && (c = e[e.length - 1]), c && c.classList.add(t.slidePrevClass))), s.emitSlidesClasses();
  }
  const K = (s, e) => {
    if (!s || s.destroyed || !s.params)
      return;
    const t = () => s.isElement ? "swiper-slide" : `.${s.params.slideClass}`, i = e.closest(t());
    if (i) {
      let r = i.querySelector(`.${s.params.lazyPreloaderClass}`);
      !r && s.isElement && (i.shadowRoot ? r = i.shadowRoot.querySelector(`.${s.params.lazyPreloaderClass}`) : requestAnimationFrame(() => {
        i.shadowRoot && (r = i.shadowRoot.querySelector(`.${s.params.lazyPreloaderClass}`), r && r.remove());
      })), r && r.remove();
    }
  }, re = (s, e) => {
    if (!s.slides[e])
      return;
    const t = s.slides[e].querySelector('[loading="lazy"]');
    t && t.removeAttribute("loading");
  }, oe = (s) => {
    if (!s || s.destroyed || !s.params)
      return;
    let e = s.params.lazyPreloadPrevNext;
    const t = s.slides.length;
    if (!t || !e || e < 0)
      return;
    e = Math.min(e, t);
    const i = s.params.slidesPerView === "auto" ? s.slidesPerViewDynamic() : Math.ceil(s.params.slidesPerView), r = s.activeIndex;
    if (s.params.grid && s.params.grid.rows > 1) {
      const l = r, a = [l - e];
      a.push(...Array.from({
        length: e
      }).map((o, c) => l + i + c)), s.slides.forEach((o, c) => {
        a.includes(o.column) && re(s, c);
      });
      return;
    }
    const n = r + i - 1;
    if (s.params.rewind || s.params.loop)
      for (let l = r - e; l <= n + e; l += 1) {
        const a = (l % t + t) % t;
        (a < r || a > n) && re(s, a);
      }
    else
      for (let l = Math.max(r - e, 0); l <= Math.min(n + e, t - 1); l += 1)
        l !== r && (l > n || l < r) && re(s, l);
  };
  function Ke(s) {
    const {
      slidesGrid: e,
      params: t
    } = s, i = s.rtlTranslate ? s.translate : -s.translate;
    let r;
    for (let n = 0; n < e.length; n += 1)
      typeof e[n + 1] < "u" ? i >= e[n] && i < e[n + 1] - (e[n + 1] - e[n]) / 2 ? r = n : i >= e[n] && i < e[n + 1] && (r = n + 1) : i >= e[n] && (r = n);
    return t.normalizeSlideIndex && (r < 0 || typeof r > "u") && (r = 0), r;
  }
  function Je(s) {
    const e = this, t = e.rtlTranslate ? e.translate : -e.translate, {
      snapGrid: i,
      params: r,
      activeIndex: n,
      realIndex: l,
      snapIndex: a
    } = e;
    let o = s, c;
    const p = (h) => {
      let m = h - e.virtual.slidesBefore;
      return m < 0 && (m = e.virtual.slides.length + m), m >= e.virtual.slides.length && (m -= e.virtual.slides.length), m;
    };
    if (typeof o > "u" && (o = Ke(e)), i.indexOf(t) >= 0)
      c = i.indexOf(t);
    else {
      const h = Math.min(r.slidesPerGroupSkip, o);
      c = h + Math.floor((o - h) / r.slidesPerGroup);
    }
    if (c >= i.length && (c = i.length - 1), o === n && !e.params.loop) {
      c !== a && (e.snapIndex = c, e.emit("snapIndexChange"));
      return;
    }
    if (o === n && e.params.loop && e.virtual && e.params.virtual.enabled) {
      e.realIndex = p(o);
      return;
    }
    const f = e.grid && r.grid && r.grid.rows > 1;
    let g;
    if (e.virtual && r.virtual.enabled && r.loop)
      g = p(o);
    else if (f) {
      const h = e.slides.filter((w) => w.column === o)[0];
      let m = parseInt(h.getAttribute("data-swiper-slide-index"), 10);
      Number.isNaN(m) && (m = Math.max(e.slides.indexOf(h), 0)), g = Math.floor(m / r.grid.rows);
    } else if (e.slides[o]) {
      const h = e.slides[o].getAttribute("data-swiper-slide-index");
      h ? g = parseInt(h, 10) : g = o;
    } else
      g = o;
    Object.assign(e, {
      previousSnapIndex: a,
      snapIndex: c,
      previousRealIndex: l,
      realIndex: g,
      previousIndex: n,
      activeIndex: o
    }), e.initialized && oe(e), e.emit("activeIndexChange"), e.emit("snapIndexChange"), (e.initialized || e.params.runCallbacksOnInit) && (l !== g && e.emit("realIndexChange"), e.emit("slideChange"));
  }
  function Qe(s, e) {
    const t = this, i = t.params;
    let r = s.closest(`.${i.slideClass}, swiper-slide`);
    !r && t.isElement && e && e.length > 1 && e.includes(s) && [...e.slice(e.indexOf(s) + 1, e.length)].forEach((a) => {
      !r && a.matches && a.matches(`.${i.slideClass}, swiper-slide`) && (r = a);
    });
    let n = !1, l;
    if (r) {
      for (let a = 0; a < t.slides.length; a += 1)
        if (t.slides[a] === r) {
          n = !0, l = a;
          break;
        }
    }
    if (r && n)
      t.clickedSlide = r, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(r.getAttribute("data-swiper-slide-index"), 10) : t.clickedIndex = l;
    else {
      t.clickedSlide = void 0, t.clickedIndex = void 0;
      return;
    }
    i.slideToClickedSlide && t.clickedIndex !== void 0 && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide();
  }
  var et = {
    updateSize: qe,
    updateSlides: je,
    updateAutoHeight: Ye,
    updateSlidesOffset: We,
    updateSlidesProgress: Xe,
    updateProgress: Ze,
    updateSlidesClasses: Ue,
    updateActiveIndex: Je,
    updateClickedSlide: Qe
  };
  function tt(s) {
    s === void 0 && (s = this.isHorizontal() ? "x" : "y");
    const e = this, {
      params: t,
      rtlTranslate: i,
      translate: r,
      wrapperEl: n
    } = e;
    if (t.virtualTranslate)
      return i ? -r : r;
    if (t.cssMode)
      return r;
    let l = ze(n, s);
    return l += e.cssOverflowAdjustment(), i && (l = -l), l || 0;
  }
  function st(s, e) {
    const t = this, {
      rtlTranslate: i,
      params: r,
      wrapperEl: n,
      progress: l
    } = t;
    let a = 0, o = 0;
    const c = 0;
    t.isHorizontal() ? a = i ? -s : s : o = s, r.roundLengths && (a = Math.floor(a), o = Math.floor(o)), t.previousTranslate = t.translate, t.translate = t.isHorizontal() ? a : o, r.cssMode ? n[t.isHorizontal() ? "scrollLeft" : "scrollTop"] = t.isHorizontal() ? -a : -o : r.virtualTranslate || (t.isHorizontal() ? a -= t.cssOverflowAdjustment() : o -= t.cssOverflowAdjustment(), n.style.transform = `translate3d(${a}px, ${o}px, ${c}px)`);
    let p;
    const f = t.maxTranslate() - t.minTranslate();
    f === 0 ? p = 0 : p = (s - t.minTranslate()) / f, p !== l && t.updateProgress(s), t.emit("setTranslate", t.translate, e);
  }
  function it() {
    return -this.snapGrid[0];
  }
  function nt() {
    return -this.snapGrid[this.snapGrid.length - 1];
  }
  function rt(s, e, t, i, r) {
    s === void 0 && (s = 0), e === void 0 && (e = this.params.speed), t === void 0 && (t = !0), i === void 0 && (i = !0);
    const n = this, {
      params: l,
      wrapperEl: a
    } = n;
    if (n.animating && l.preventInteractionOnTransition)
      return !1;
    const o = n.minTranslate(), c = n.maxTranslate();
    let p;
    if (i && s > o ? p = o : i && s < c ? p = c : p = s, n.updateProgress(p), l.cssMode) {
      const f = n.isHorizontal();
      if (e === 0)
        a[f ? "scrollLeft" : "scrollTop"] = -p;
      else {
        if (!n.support.smoothScroll)
          return ue({
            swiper: n,
            targetPosition: -p,
            side: f ? "left" : "top"
          }), !0;
        a.scrollTo({
          [f ? "left" : "top"]: -p,
          behavior: "smooth"
        });
      }
      return !0;
    }
    return e === 0 ? (n.setTransition(0), n.setTranslate(p), t && (n.emit("beforeTransitionStart", e, r), n.emit("transitionEnd"))) : (n.setTransition(e), n.setTranslate(p), t && (n.emit("beforeTransitionStart", e, r), n.emit("transitionStart")), n.animating || (n.animating = !0, n.onTranslateToWrapperTransitionEnd || (n.onTranslateToWrapperTransitionEnd = function(g) {
      !n || n.destroyed || g.target === this && (n.wrapperEl.removeEventListener("transitionend", n.onTranslateToWrapperTransitionEnd), n.onTranslateToWrapperTransitionEnd = null, delete n.onTranslateToWrapperTransitionEnd, t && n.emit("transitionEnd"));
    }), n.wrapperEl.addEventListener("transitionend", n.onTranslateToWrapperTransitionEnd))), !0;
  }
  var ot = {
    getTranslate: tt,
    setTranslate: st,
    minTranslate: it,
    maxTranslate: nt,
    translateTo: rt
  };
  function at(s, e) {
    const t = this;
    t.params.cssMode || (t.wrapperEl.style.transitionDuration = `${s}ms`, t.wrapperEl.style.transitionDelay = s === 0 ? "0ms" : ""), t.emit("setTransition", s, e);
  }
  function ge(s) {
    let {
      swiper: e,
      runCallbacks: t,
      direction: i,
      step: r
    } = s;
    const {
      activeIndex: n,
      previousIndex: l
    } = e;
    let a = i;
    if (a || (n > l ? a = "next" : n < l ? a = "prev" : a = "reset"), e.emit(`transition${r}`), t && n !== l) {
      if (a === "reset") {
        e.emit(`slideResetTransition${r}`);
        return;
      }
      e.emit(`slideChangeTransition${r}`), a === "next" ? e.emit(`slideNextTransition${r}`) : e.emit(`slidePrevTransition${r}`);
    }
  }
  function lt(s, e) {
    s === void 0 && (s = !0);
    const t = this, {
      params: i
    } = t;
    i.cssMode || (i.autoHeight && t.updateAutoHeight(), ge({
      swiper: t,
      runCallbacks: s,
      direction: e,
      step: "Start"
    }));
  }
  function dt(s, e) {
    s === void 0 && (s = !0);
    const t = this, {
      params: i
    } = t;
    t.animating = !1, !i.cssMode && (t.setTransition(0), ge({
      swiper: t,
      runCallbacks: s,
      direction: e,
      step: "End"
    }));
  }
  var ct = {
    setTransition: at,
    transitionStart: lt,
    transitionEnd: dt
  };
  function pt(s, e, t, i, r) {
    s === void 0 && (s = 0), e === void 0 && (e = this.params.speed), t === void 0 && (t = !0), typeof s == "string" && (s = parseInt(s, 10));
    const n = this;
    let l = s;
    l < 0 && (l = 0);
    const {
      params: a,
      snapGrid: o,
      slidesGrid: c,
      previousIndex: p,
      activeIndex: f,
      rtlTranslate: g,
      wrapperEl: h,
      enabled: m
    } = n;
    if (n.animating && a.preventInteractionOnTransition || !m && !i && !r || n.destroyed)
      return !1;
    const w = Math.min(n.params.slidesPerGroupSkip, l);
    let b = w + Math.floor((l - w) / n.params.slidesPerGroup);
    b >= o.length && (b = o.length - 1);
    const d = -o[b];
    if (a.normalizeSlideIndex)
      for (let v = 0; v < c.length; v += 1) {
        const x = -Math.floor(d * 100), y = Math.floor(c[v] * 100), M = Math.floor(c[v + 1] * 100);
        typeof c[v + 1] < "u" ? x >= y && x < M - (M - y) / 2 ? l = v : x >= y && x < M && (l = v + 1) : x >= y && (l = v);
      }
    if (n.initialized && l !== f && (!n.allowSlideNext && (g ? d > n.translate && d > n.minTranslate() : d < n.translate && d < n.minTranslate()) || !n.allowSlidePrev && d > n.translate && d > n.maxTranslate() && (f || 0) !== l))
      return !1;
    l !== (p || 0) && t && n.emit("beforeSlideChangeStart"), n.updateProgress(d);
    let u;
    if (l > f ? u = "next" : l < f ? u = "prev" : u = "reset", g && -d === n.translate || !g && d === n.translate)
      return n.updateActiveIndex(l), a.autoHeight && n.updateAutoHeight(), n.updateSlidesClasses(), a.effect !== "slide" && n.setTranslate(d), u !== "reset" && (n.transitionStart(t, u), n.transitionEnd(t, u)), !1;
    if (a.cssMode) {
      const v = n.isHorizontal(), x = g ? d : -d;
      if (e === 0) {
        const y = n.virtual && n.params.virtual.enabled;
        y && (n.wrapperEl.style.scrollSnapType = "none", n._immediateVirtual = !0), y && !n._cssModeVirtualInitialSet && n.params.initialSlide > 0 ? (n._cssModeVirtualInitialSet = !0, requestAnimationFrame(() => {
          h[v ? "scrollLeft" : "scrollTop"] = x;
        })) : h[v ? "scrollLeft" : "scrollTop"] = x, y && requestAnimationFrame(() => {
          n.wrapperEl.style.scrollSnapType = "", n._immediateVirtual = !1;
        });
      } else {
        if (!n.support.smoothScroll)
          return ue({
            swiper: n,
            targetPosition: x,
            side: v ? "left" : "top"
          }), !0;
        h.scrollTo({
          [v ? "left" : "top"]: x,
          behavior: "smooth"
        });
      }
      return !0;
    }
    return n.setTransition(e), n.setTranslate(d), n.updateActiveIndex(l), n.updateSlidesClasses(), n.emit("beforeTransitionStart", e, i), n.transitionStart(t, u), e === 0 ? n.transitionEnd(t, u) : n.animating || (n.animating = !0, n.onSlideToWrapperTransitionEnd || (n.onSlideToWrapperTransitionEnd = function(x) {
      !n || n.destroyed || x.target === this && (n.wrapperEl.removeEventListener("transitionend", n.onSlideToWrapperTransitionEnd), n.onSlideToWrapperTransitionEnd = null, delete n.onSlideToWrapperTransitionEnd, n.transitionEnd(t, u));
    }), n.wrapperEl.addEventListener("transitionend", n.onSlideToWrapperTransitionEnd)), !0;
  }
  function ut(s, e, t, i) {
    s === void 0 && (s = 0), e === void 0 && (e = this.params.speed), t === void 0 && (t = !0), typeof s == "string" && (s = parseInt(s, 10));
    const r = this;
    if (r.destroyed)
      return;
    const n = r.grid && r.params.grid && r.params.grid.rows > 1;
    let l = s;
    if (r.params.loop)
      if (r.virtual && r.params.virtual.enabled)
        l = l + r.virtual.slidesBefore;
      else {
        let a;
        if (n) {
          const g = l * r.params.grid.rows;
          a = r.slides.filter((h) => h.getAttribute("data-swiper-slide-index") * 1 === g)[0].column;
        } else
          a = r.getSlideIndexByData(l);
        const o = n ? Math.ceil(r.slides.length / r.params.grid.rows) : r.slides.length, {
          centeredSlides: c
        } = r.params;
        let p = r.params.slidesPerView;
        p === "auto" ? p = r.slidesPerViewDynamic() : (p = Math.ceil(parseFloat(r.params.slidesPerView, 10)), c && p % 2 === 0 && (p = p + 1));
        let f = o - a < p;
        if (c && (f = f || a < Math.ceil(p / 2)), f) {
          const g = c ? a < r.activeIndex ? "prev" : "next" : a - r.activeIndex - 1 < r.params.slidesPerView ? "next" : "prev";
          r.loopFix({
            direction: g,
            slideTo: !0,
            activeSlideIndex: g === "next" ? a + 1 : a - o + 1,
            slideRealIndex: g === "next" ? r.realIndex : void 0
          });
        }
        if (n) {
          const g = l * r.params.grid.rows;
          l = r.slides.filter((h) => h.getAttribute("data-swiper-slide-index") * 1 === g)[0].column;
        } else
          l = r.getSlideIndexByData(l);
      }
    return requestAnimationFrame(() => {
      r.slideTo(l, e, t, i);
    }), r;
  }
  function ft(s, e, t) {
    s === void 0 && (s = this.params.speed), e === void 0 && (e = !0);
    const i = this, {
      enabled: r,
      params: n,
      animating: l
    } = i;
    if (!r || i.destroyed)
      return i;
    let a = n.slidesPerGroup;
    n.slidesPerView === "auto" && n.slidesPerGroup === 1 && n.slidesPerGroupAuto && (a = Math.max(i.slidesPerViewDynamic("current", !0), 1));
    const o = i.activeIndex < n.slidesPerGroupSkip ? 1 : a, c = i.virtual && n.virtual.enabled;
    if (n.loop) {
      if (l && !c && n.loopPreventsSliding)
        return !1;
      if (i.loopFix({
        direction: "next"
      }), i._clientLeft = i.wrapperEl.clientLeft, i.activeIndex === i.slides.length - 1 && n.cssMode)
        return requestAnimationFrame(() => {
          i.slideTo(i.activeIndex + o, s, e, t);
        }), !0;
    }
    return n.rewind && i.isEnd ? i.slideTo(0, s, e, t) : i.slideTo(i.activeIndex + o, s, e, t);
  }
  function mt(s, e, t) {
    s === void 0 && (s = this.params.speed), e === void 0 && (e = !0);
    const i = this, {
      params: r,
      snapGrid: n,
      slidesGrid: l,
      rtlTranslate: a,
      enabled: o,
      animating: c
    } = i;
    if (!o || i.destroyed)
      return i;
    const p = i.virtual && r.virtual.enabled;
    if (r.loop) {
      if (c && !p && r.loopPreventsSliding)
        return !1;
      i.loopFix({
        direction: "prev"
      }), i._clientLeft = i.wrapperEl.clientLeft;
    }
    const f = a ? i.translate : -i.translate;
    function g(d) {
      return d < 0 ? -Math.floor(Math.abs(d)) : Math.floor(d);
    }
    const h = g(f), m = n.map((d) => g(d));
    let w = n[m.indexOf(h) - 1];
    if (typeof w > "u" && r.cssMode) {
      let d;
      n.forEach((u, v) => {
        h >= u && (d = v);
      }), typeof d < "u" && (w = n[d > 0 ? d - 1 : d]);
    }
    let b = 0;
    if (typeof w < "u" && (b = l.indexOf(w), b < 0 && (b = i.activeIndex - 1), r.slidesPerView === "auto" && r.slidesPerGroup === 1 && r.slidesPerGroupAuto && (b = b - i.slidesPerViewDynamic("previous", !0) + 1, b = Math.max(b, 0))), r.rewind && i.isBeginning) {
      const d = i.params.virtual && i.params.virtual.enabled && i.virtual ? i.virtual.slides.length - 1 : i.slides.length - 1;
      return i.slideTo(d, s, e, t);
    } else if (r.loop && i.activeIndex === 0 && r.cssMode)
      return requestAnimationFrame(() => {
        i.slideTo(b, s, e, t);
      }), !0;
    return i.slideTo(b, s, e, t);
  }
  function ht(s, e, t) {
    s === void 0 && (s = this.params.speed), e === void 0 && (e = !0);
    const i = this;
    if (!i.destroyed)
      return i.slideTo(i.activeIndex, s, e, t);
  }
  function gt(s, e, t, i) {
    s === void 0 && (s = this.params.speed), e === void 0 && (e = !0), i === void 0 && (i = 0.5);
    const r = this;
    if (r.destroyed)
      return;
    let n = r.activeIndex;
    const l = Math.min(r.params.slidesPerGroupSkip, n), a = l + Math.floor((n - l) / r.params.slidesPerGroup), o = r.rtlTranslate ? r.translate : -r.translate;
    if (o >= r.snapGrid[a]) {
      const c = r.snapGrid[a], p = r.snapGrid[a + 1];
      o - c > (p - c) * i && (n += r.params.slidesPerGroup);
    } else {
      const c = r.snapGrid[a - 1], p = r.snapGrid[a];
      o - c <= (p - c) * i && (n -= r.params.slidesPerGroup);
    }
    return n = Math.max(n, 0), n = Math.min(n, r.slidesGrid.length - 1), r.slideTo(n, s, e, t);
  }
  function vt() {
    const s = this;
    if (s.destroyed)
      return;
    const {
      params: e,
      slidesEl: t
    } = s, i = e.slidesPerView === "auto" ? s.slidesPerViewDynamic() : e.slidesPerView;
    let r = s.clickedIndex, n;
    const l = s.isElement ? "swiper-slide" : `.${e.slideClass}`;
    if (e.loop) {
      if (s.animating)
        return;
      n = parseInt(s.clickedSlide.getAttribute("data-swiper-slide-index"), 10), e.centeredSlides ? r < s.loopedSlides - i / 2 || r > s.slides.length - s.loopedSlides + i / 2 ? (s.loopFix(), r = s.getSlideIndex(_(t, `${l}[data-swiper-slide-index="${n}"]`)[0]), ee(() => {
        s.slideTo(r);
      })) : s.slideTo(r) : r > s.slides.length - i ? (s.loopFix(), r = s.getSlideIndex(_(t, `${l}[data-swiper-slide-index="${n}"]`)[0]), ee(() => {
        s.slideTo(r);
      })) : s.slideTo(r);
    } else
      s.slideTo(r);
  }
  var wt = {
    slideTo: pt,
    slideToLoop: ut,
    slideNext: ft,
    slidePrev: mt,
    slideReset: ht,
    slideToClosest: gt,
    slideToClickedSlide: vt
  };
  function xt(s) {
    const e = this, {
      params: t,
      slidesEl: i
    } = e;
    if (!t.loop || e.virtual && e.params.virtual.enabled)
      return;
    const r = () => {
      _(i, `.${t.slideClass}, swiper-slide`).forEach((f, g) => {
        f.setAttribute("data-swiper-slide-index", g);
      });
    }, n = e.grid && t.grid && t.grid.rows > 1, l = t.slidesPerGroup * (n ? t.grid.rows : 1), a = e.slides.length % l !== 0, o = n && e.slides.length % t.grid.rows !== 0, c = (p) => {
      for (let f = 0; f < p; f += 1) {
        const g = e.isElement ? Z("swiper-slide", [t.slideBlankClass]) : Z("div", [t.slideClass, t.slideBlankClass]);
        e.slidesEl.append(g);
      }
    };
    if (a) {
      if (t.loopAddBlankSlides) {
        const p = l - e.slides.length % l;
        c(p), e.recalcSlides(), e.updateSlides();
      } else
        X("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
      r();
    } else if (o) {
      if (t.loopAddBlankSlides) {
        const p = t.grid.rows - e.slides.length % t.grid.rows;
        c(p), e.recalcSlides(), e.updateSlides();
      } else
        X("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
      r();
    } else
      r();
    e.loopFix({
      slideRealIndex: s,
      direction: t.centeredSlides ? void 0 : "next"
    });
  }
  function bt(s) {
    let {
      slideRealIndex: e,
      slideTo: t = !0,
      direction: i,
      setTranslate: r,
      activeSlideIndex: n,
      byController: l,
      byMousewheel: a
    } = s === void 0 ? {} : s;
    const o = this;
    if (!o.params.loop)
      return;
    o.emit("beforeLoopFix");
    const {
      slides: c,
      allowSlidePrev: p,
      allowSlideNext: f,
      slidesEl: g,
      params: h
    } = o, {
      centeredSlides: m
    } = h;
    if (o.allowSlidePrev = !0, o.allowSlideNext = !0, o.virtual && h.virtual.enabled) {
      t && (!h.centeredSlides && o.snapIndex === 0 ? o.slideTo(o.virtual.slides.length, 0, !1, !0) : h.centeredSlides && o.snapIndex < h.slidesPerView ? o.slideTo(o.virtual.slides.length + o.snapIndex, 0, !1, !0) : o.snapIndex === o.snapGrid.length - 1 && o.slideTo(o.virtual.slidesBefore, 0, !1, !0)), o.allowSlidePrev = p, o.allowSlideNext = f, o.emit("loopFix");
      return;
    }
    let w = h.slidesPerView;
    w === "auto" ? w = o.slidesPerViewDynamic() : (w = Math.ceil(parseFloat(h.slidesPerView, 10)), m && w % 2 === 0 && (w = w + 1));
    const b = h.slidesPerGroupAuto ? w : h.slidesPerGroup;
    let d = b;
    d % b !== 0 && (d += b - d % b), d += h.loopAdditionalSlides, o.loopedSlides = d;
    const u = o.grid && h.grid && h.grid.rows > 1;
    c.length < w + d ? X("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : u && h.grid.fill === "row" && X("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
    const v = [], x = [];
    let y = o.activeIndex;
    typeof n > "u" ? n = o.getSlideIndex(c.filter((T) => T.classList.contains(h.slideActiveClass))[0]) : y = n;
    const M = i === "next" || !i, D = i === "prev" || !i;
    let L = 0, A = 0;
    const S = u ? Math.ceil(c.length / h.grid.rows) : c.length, C = (u ? c[n].column : n) + (m && typeof r > "u" ? -w / 2 + 0.5 : 0);
    if (C < d) {
      L = Math.max(d - C, b);
      for (let T = 0; T < d - C; T += 1) {
        const P = T - Math.floor(T / S) * S;
        if (u) {
          const I = S - P - 1;
          for (let B = c.length - 1; B >= 0; B -= 1)
            c[B].column === I && v.push(B);
        } else
          v.push(S - P - 1);
      }
    } else if (C + w > S - d) {
      A = Math.max(C - (S - d * 2), b);
      for (let T = 0; T < A; T += 1) {
        const P = T - Math.floor(T / S) * S;
        u ? c.forEach((I, B) => {
          I.column === P && x.push(B);
        }) : x.push(P);
      }
    }
    if (o.__preventObserver__ = !0, requestAnimationFrame(() => {
      o.__preventObserver__ = !1;
    }), D && v.forEach((T) => {
      c[T].swiperLoopMoveDOM = !0, g.prepend(c[T]), c[T].swiperLoopMoveDOM = !1;
    }), M && x.forEach((T) => {
      c[T].swiperLoopMoveDOM = !0, g.append(c[T]), c[T].swiperLoopMoveDOM = !1;
    }), o.recalcSlides(), h.slidesPerView === "auto" ? o.updateSlides() : u && (v.length > 0 && D || x.length > 0 && M) && o.slides.forEach((T, P) => {
      o.grid.updateSlide(P, T, o.slides);
    }), h.watchSlidesProgress && o.updateSlidesOffset(), t) {
      if (v.length > 0 && D) {
        if (typeof e > "u") {
          const T = o.slidesGrid[y], I = o.slidesGrid[y + L] - T;
          a ? o.setTranslate(o.translate - I) : (o.slideTo(y + Math.ceil(L), 0, !1, !0), r && (o.touchEventsData.startTranslate = o.touchEventsData.startTranslate - I, o.touchEventsData.currentTranslate = o.touchEventsData.currentTranslate - I));
        } else if (r) {
          const T = u ? v.length / h.grid.rows : v.length;
          o.slideTo(o.activeIndex + T, 0, !1, !0), o.touchEventsData.currentTranslate = o.translate;
        }
      } else if (x.length > 0 && M)
        if (typeof e > "u") {
          const T = o.slidesGrid[y], I = o.slidesGrid[y - A] - T;
          a ? o.setTranslate(o.translate - I) : (o.slideTo(y - A, 0, !1, !0), r && (o.touchEventsData.startTranslate = o.touchEventsData.startTranslate - I, o.touchEventsData.currentTranslate = o.touchEventsData.currentTranslate - I));
        } else {
          const T = u ? x.length / h.grid.rows : x.length;
          o.slideTo(o.activeIndex - T, 0, !1, !0);
        }
    }
    if (o.allowSlidePrev = p, o.allowSlideNext = f, o.controller && o.controller.control && !l) {
      const T = {
        slideRealIndex: e,
        direction: i,
        setTranslate: r,
        activeSlideIndex: n,
        byController: !0
      };
      Array.isArray(o.controller.control) ? o.controller.control.forEach((P) => {
        !P.destroyed && P.params.loop && P.loopFix({
          ...T,
          slideTo: P.params.slidesPerView === h.slidesPerView ? t : !1
        });
      }) : o.controller.control instanceof o.constructor && o.controller.control.params.loop && o.controller.control.loopFix({
        ...T,
        slideTo: o.controller.control.params.slidesPerView === h.slidesPerView ? t : !1
      });
    }
    o.emit("loopFix");
  }
  function St() {
    const s = this, {
      params: e,
      slidesEl: t
    } = s;
    if (!e.loop || s.virtual && s.params.virtual.enabled)
      return;
    s.recalcSlides();
    const i = [];
    s.slides.forEach((r) => {
      const n = typeof r.swiperSlideIndex > "u" ? r.getAttribute("data-swiper-slide-index") * 1 : r.swiperSlideIndex;
      i[n] = r;
    }), s.slides.forEach((r) => {
      r.removeAttribute("data-swiper-slide-index");
    }), i.forEach((r) => {
      t.append(r);
    }), s.recalcSlides(), s.slideTo(s.realIndex, 0);
  }
  var yt = {
    loopCreate: xt,
    loopFix: bt,
    loopDestroy: St
  };
  function Tt(s) {
    const e = this;
    if (!e.params.simulateTouch || e.params.watchOverflow && e.isLocked || e.params.cssMode)
      return;
    const t = e.params.touchEventsTarget === "container" ? e.el : e.wrapperEl;
    e.isElement && (e.__preventObserver__ = !0), t.style.cursor = "move", t.style.cursor = s ? "grabbing" : "grab", e.isElement && requestAnimationFrame(() => {
      e.__preventObserver__ = !1;
    });
  }
  function Ct() {
    const s = this;
    s.params.watchOverflow && s.isLocked || s.params.cssMode || (s.isElement && (s.__preventObserver__ = !0), s[s.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "", s.isElement && requestAnimationFrame(() => {
      s.__preventObserver__ = !1;
    }));
  }
  var Et = {
    setGrabCursor: Tt,
    unsetGrabCursor: Ct
  };
  function Lt(s, e) {
    e === void 0 && (e = this);
    function t(i) {
      if (!i || i === F() || i === O())
        return null;
      i.assignedSlot && (i = i.assignedSlot);
      const r = i.closest(s);
      return !r && !i.getRootNode ? null : r || t(i.getRootNode().host);
    }
    return t(e);
  }
  function ve(s, e, t) {
    const i = O(), {
      params: r
    } = s, n = r.edgeSwipeDetection, l = r.edgeSwipeThreshold;
    return n && (t <= l || t >= i.innerWidth - l) ? n === "prevent" ? (e.preventDefault(), !0) : !1 : !0;
  }
  function Pt(s) {
    const e = this, t = F();
    let i = s;
    i.originalEvent && (i = i.originalEvent);
    const r = e.touchEventsData;
    if (i.type === "pointerdown") {
      if (r.pointerId !== null && r.pointerId !== i.pointerId)
        return;
      r.pointerId = i.pointerId;
    } else
      i.type === "touchstart" && i.targetTouches.length === 1 && (r.touchId = i.targetTouches[0].identifier);
    if (i.type === "touchstart") {
      ve(e, i, i.targetTouches[0].pageX);
      return;
    }
    const {
      params: n,
      touches: l,
      enabled: a
    } = e;
    if (!a || !n.simulateTouch && i.pointerType === "mouse" || e.animating && n.preventInteractionOnTransition)
      return;
    !e.animating && n.cssMode && n.loop && e.loopFix();
    let o = i.target;
    if (n.touchEventsTarget === "wrapper" && !e.wrapperEl.contains(o) || "which" in i && i.which === 3 || "button" in i && i.button > 0 || r.isTouched && r.isMoved)
      return;
    const c = !!n.noSwipingClass && n.noSwipingClass !== "", p = i.composedPath ? i.composedPath() : i.path;
    c && i.target && i.target.shadowRoot && p && (o = p[0]);
    const f = n.noSwipingSelector ? n.noSwipingSelector : `.${n.noSwipingClass}`, g = !!(i.target && i.target.shadowRoot);
    if (n.noSwiping && (g ? Lt(f, o) : o.closest(f))) {
      e.allowClick = !0;
      return;
    }
    if (n.swipeHandler && !o.closest(n.swipeHandler))
      return;
    l.currentX = i.pageX, l.currentY = i.pageY;
    const h = l.currentX, m = l.currentY;
    if (!ve(e, i, h))
      return;
    Object.assign(r, {
      isTouched: !0,
      isMoved: !1,
      allowTouchCallbacks: !0,
      isScrolling: void 0,
      startMoving: void 0
    }), l.startX = h, l.startY = m, r.touchStartTime = j(), e.allowClick = !0, e.updateSize(), e.swipeDirection = void 0, n.threshold > 0 && (r.allowThresholdMove = !1);
    let w = !0;
    o.matches(r.focusableElements) && (w = !1, o.nodeName === "SELECT" && (r.isTouched = !1)), t.activeElement && t.activeElement.matches(r.focusableElements) && t.activeElement !== o && t.activeElement.blur();
    const b = w && e.allowTouchMove && n.touchStartPreventDefault;
    (n.touchStartForcePreventDefault || b) && !o.isContentEditable && i.preventDefault(), n.freeMode && n.freeMode.enabled && e.freeMode && e.animating && !n.cssMode && e.freeMode.onTouchStart(), e.emit("touchStart", i);
  }
  function Mt(s) {
    const e = F(), t = this, i = t.touchEventsData, {
      params: r,
      touches: n,
      rtlTranslate: l,
      enabled: a
    } = t;
    if (!a || !r.simulateTouch && s.pointerType === "mouse")
      return;
    let o = s;
    if (o.originalEvent && (o = o.originalEvent), o.type === "pointermove" && (i.touchId !== null || o.pointerId !== i.pointerId))
      return;
    let c;
    if (o.type === "touchmove") {
      if (c = [...o.changedTouches].filter((M) => M.identifier === i.touchId)[0], !c || c.identifier !== i.touchId)
        return;
    } else
      c = o;
    if (!i.isTouched) {
      i.startMoving && i.isScrolling && t.emit("touchMoveOpposite", o);
      return;
    }
    const p = c.pageX, f = c.pageY;
    if (o.preventedByNestedSwiper) {
      n.startX = p, n.startY = f;
      return;
    }
    if (!t.allowTouchMove) {
      o.target.matches(i.focusableElements) || (t.allowClick = !1), i.isTouched && (Object.assign(n, {
        startX: p,
        startY: f,
        currentX: p,
        currentY: f
      }), i.touchStartTime = j());
      return;
    }
    if (r.touchReleaseOnEdges && !r.loop) {
      if (t.isVertical()) {
        if (f < n.startY && t.translate <= t.maxTranslate() || f > n.startY && t.translate >= t.minTranslate()) {
          i.isTouched = !1, i.isMoved = !1;
          return;
        }
      } else if (p < n.startX && t.translate <= t.maxTranslate() || p > n.startX && t.translate >= t.minTranslate())
        return;
    }
    if (e.activeElement && o.target === e.activeElement && o.target.matches(i.focusableElements)) {
      i.isMoved = !0, t.allowClick = !1;
      return;
    }
    i.allowTouchCallbacks && t.emit("touchMove", o), n.previousX = n.currentX, n.previousY = n.currentY, n.currentX = p, n.currentY = f;
    const g = n.currentX - n.startX, h = n.currentY - n.startY;
    if (t.params.threshold && Math.sqrt(g ** 2 + h ** 2) < t.params.threshold)
      return;
    if (typeof i.isScrolling > "u") {
      let M;
      t.isHorizontal() && n.currentY === n.startY || t.isVertical() && n.currentX === n.startX ? i.isScrolling = !1 : g * g + h * h >= 25 && (M = Math.atan2(Math.abs(h), Math.abs(g)) * 180 / Math.PI, i.isScrolling = t.isHorizontal() ? M > r.touchAngle : 90 - M > r.touchAngle);
    }
    if (i.isScrolling && t.emit("touchMoveOpposite", o), typeof i.startMoving > "u" && (n.currentX !== n.startX || n.currentY !== n.startY) && (i.startMoving = !0), i.isScrolling) {
      i.isTouched = !1;
      return;
    }
    if (!i.startMoving)
      return;
    t.allowClick = !1, !r.cssMode && o.cancelable && o.preventDefault(), r.touchMoveStopPropagation && !r.nested && o.stopPropagation();
    let m = t.isHorizontal() ? g : h, w = t.isHorizontal() ? n.currentX - n.previousX : n.currentY - n.previousY;
    r.oneWayMovement && (m = Math.abs(m) * (l ? 1 : -1), w = Math.abs(w) * (l ? 1 : -1)), n.diff = m, m *= r.touchRatio, l && (m = -m, w = -w);
    const b = t.touchesDirection;
    t.swipeDirection = m > 0 ? "prev" : "next", t.touchesDirection = w > 0 ? "prev" : "next";
    const d = t.params.loop && !r.cssMode, u = t.touchesDirection === "next" && t.allowSlideNext || t.touchesDirection === "prev" && t.allowSlidePrev;
    if (!i.isMoved) {
      if (d && u && t.loopFix({
        direction: t.swipeDirection
      }), i.startTranslate = t.getTranslate(), t.setTransition(0), t.animating) {
        const M = new window.CustomEvent("transitionend", {
          bubbles: !0,
          cancelable: !0
        });
        t.wrapperEl.dispatchEvent(M);
      }
      i.allowMomentumBounce = !1, r.grabCursor && (t.allowSlideNext === !0 || t.allowSlidePrev === !0) && t.setGrabCursor(!0), t.emit("sliderFirstMove", o);
    }
    let v;
    if ((/* @__PURE__ */ new Date()).getTime(), i.isMoved && i.allowThresholdMove && b !== t.touchesDirection && d && u && Math.abs(m) >= 1) {
      Object.assign(n, {
        startX: p,
        startY: f,
        currentX: p,
        currentY: f,
        startTranslate: i.currentTranslate
      }), i.loopSwapReset = !0, i.startTranslate = i.currentTranslate;
      return;
    }
    t.emit("sliderMove", o), i.isMoved = !0, i.currentTranslate = m + i.startTranslate;
    let x = !0, y = r.resistanceRatio;
    if (r.touchReleaseOnEdges && (y = 0), m > 0 ? (d && u && !v && i.allowThresholdMove && i.currentTranslate > (r.centeredSlides ? t.minTranslate() - t.slidesSizesGrid[t.activeIndex + 1] : t.minTranslate()) && t.loopFix({
      direction: "prev",
      setTranslate: !0,
      activeSlideIndex: 0
    }), i.currentTranslate > t.minTranslate() && (x = !1, r.resistance && (i.currentTranslate = t.minTranslate() - 1 + (-t.minTranslate() + i.startTranslate + m) ** y))) : m < 0 && (d && u && !v && i.allowThresholdMove && i.currentTranslate < (r.centeredSlides ? t.maxTranslate() + t.slidesSizesGrid[t.slidesSizesGrid.length - 1] : t.maxTranslate()) && t.loopFix({
      direction: "next",
      setTranslate: !0,
      activeSlideIndex: t.slides.length - (r.slidesPerView === "auto" ? t.slidesPerViewDynamic() : Math.ceil(parseFloat(r.slidesPerView, 10)))
    }), i.currentTranslate < t.maxTranslate() && (x = !1, r.resistance && (i.currentTranslate = t.maxTranslate() + 1 - (t.maxTranslate() - i.startTranslate - m) ** y))), x && (o.preventedByNestedSwiper = !0), !t.allowSlideNext && t.swipeDirection === "next" && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !t.allowSlidePrev && t.swipeDirection === "prev" && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), !t.allowSlidePrev && !t.allowSlideNext && (i.currentTranslate = i.startTranslate), r.threshold > 0)
      if (Math.abs(m) > r.threshold || i.allowThresholdMove) {
        if (!i.allowThresholdMove) {
          i.allowThresholdMove = !0, n.startX = n.currentX, n.startY = n.currentY, i.currentTranslate = i.startTranslate, n.diff = t.isHorizontal() ? n.currentX - n.startX : n.currentY - n.startY;
          return;
        }
      } else {
        i.currentTranslate = i.startTranslate;
        return;
      }
    !r.followFinger || r.cssMode || ((r.freeMode && r.freeMode.enabled && t.freeMode || r.watchSlidesProgress) && (t.updateActiveIndex(), t.updateSlidesClasses()), r.freeMode && r.freeMode.enabled && t.freeMode && t.freeMode.onTouchMove(), t.updateProgress(i.currentTranslate), t.setTranslate(i.currentTranslate));
  }
  function It(s) {
    const e = this, t = e.touchEventsData;
    let i = s;
    i.originalEvent && (i = i.originalEvent);
    let r;
    if (i.type === "touchend" || i.type === "touchcancel") {
      if (r = [...i.changedTouches].filter((y) => y.identifier === t.touchId)[0], !r || r.identifier !== t.touchId)
        return;
    } else {
      if (t.touchId !== null || i.pointerId !== t.pointerId)
        return;
      r = i;
    }
    if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(i.type) && !(["pointercancel", "contextmenu"].includes(i.type) && (e.browser.isSafari || e.browser.isWebView)))
      return;
    t.pointerId = null, t.touchId = null;
    const {
      params: l,
      touches: a,
      rtlTranslate: o,
      slidesGrid: c,
      enabled: p
    } = e;
    if (!p || !l.simulateTouch && i.pointerType === "mouse")
      return;
    if (t.allowTouchCallbacks && e.emit("touchEnd", i), t.allowTouchCallbacks = !1, !t.isTouched) {
      t.isMoved && l.grabCursor && e.setGrabCursor(!1), t.isMoved = !1, t.startMoving = !1;
      return;
    }
    l.grabCursor && t.isMoved && t.isTouched && (e.allowSlideNext === !0 || e.allowSlidePrev === !0) && e.setGrabCursor(!1);
    const f = j(), g = f - t.touchStartTime;
    if (e.allowClick) {
      const y = i.path || i.composedPath && i.composedPath();
      e.updateClickedSlide(y && y[0] || i.target, y), e.emit("tap click", i), g < 300 && f - t.lastClickTime < 300 && e.emit("doubleTap doubleClick", i);
    }
    if (t.lastClickTime = j(), ee(() => {
      e.destroyed || (e.allowClick = !0);
    }), !t.isTouched || !t.isMoved || !e.swipeDirection || a.diff === 0 && !t.loopSwapReset || t.currentTranslate === t.startTranslate && !t.loopSwapReset) {
      t.isTouched = !1, t.isMoved = !1, t.startMoving = !1;
      return;
    }
    t.isTouched = !1, t.isMoved = !1, t.startMoving = !1;
    let h;
    if (l.followFinger ? h = o ? e.translate : -e.translate : h = -t.currentTranslate, l.cssMode)
      return;
    if (l.freeMode && l.freeMode.enabled) {
      e.freeMode.onTouchEnd({
        currentPos: h
      });
      return;
    }
    const m = h >= -e.maxTranslate() && !e.params.loop;
    let w = 0, b = e.slidesSizesGrid[0];
    for (let y = 0; y < c.length; y += y < l.slidesPerGroupSkip ? 1 : l.slidesPerGroup) {
      const M = y < l.slidesPerGroupSkip - 1 ? 1 : l.slidesPerGroup;
      typeof c[y + M] < "u" ? (m || h >= c[y] && h < c[y + M]) && (w = y, b = c[y + M] - c[y]) : (m || h >= c[y]) && (w = y, b = c[c.length - 1] - c[c.length - 2]);
    }
    let d = null, u = null;
    l.rewind && (e.isBeginning ? u = l.virtual && l.virtual.enabled && e.virtual ? e.virtual.slides.length - 1 : e.slides.length - 1 : e.isEnd && (d = 0));
    const v = (h - c[w]) / b, x = w < l.slidesPerGroupSkip - 1 ? 1 : l.slidesPerGroup;
    if (g > l.longSwipesMs) {
      if (!l.longSwipes) {
        e.slideTo(e.activeIndex);
        return;
      }
      e.swipeDirection === "next" && (v >= l.longSwipesRatio ? e.slideTo(l.rewind && e.isEnd ? d : w + x) : e.slideTo(w)), e.swipeDirection === "prev" && (v > 1 - l.longSwipesRatio ? e.slideTo(w + x) : u !== null && v < 0 && Math.abs(v) > l.longSwipesRatio ? e.slideTo(u) : e.slideTo(w));
    } else {
      if (!l.shortSwipes) {
        e.slideTo(e.activeIndex);
        return;
      }
      e.navigation && (i.target === e.navigation.nextEl || i.target === e.navigation.prevEl) ? i.target === e.navigation.nextEl ? e.slideTo(w + x) : e.slideTo(w) : (e.swipeDirection === "next" && e.slideTo(d !== null ? d : w + x), e.swipeDirection === "prev" && e.slideTo(u !== null ? u : w));
    }
  }
  function we() {
    const s = this, {
      params: e,
      el: t
    } = s;
    if (t && t.offsetWidth === 0)
      return;
    e.breakpoints && s.setBreakpoint();
    const {
      allowSlideNext: i,
      allowSlidePrev: r,
      snapGrid: n
    } = s, l = s.virtual && s.params.virtual.enabled;
    s.allowSlideNext = !0, s.allowSlidePrev = !0, s.updateSize(), s.updateSlides(), s.updateSlidesClasses();
    const a = l && e.loop;
    (e.slidesPerView === "auto" || e.slidesPerView > 1) && s.isEnd && !s.isBeginning && !s.params.centeredSlides && !a ? s.slideTo(s.slides.length - 1, 0, !1, !0) : s.params.loop && !l ? s.slideToLoop(s.realIndex, 0, !1, !0) : s.slideTo(s.activeIndex, 0, !1, !0), s.autoplay && s.autoplay.running && s.autoplay.paused && (clearTimeout(s.autoplay.resizeTimeout), s.autoplay.resizeTimeout = setTimeout(() => {
      s.autoplay && s.autoplay.running && s.autoplay.paused && s.autoplay.resume();
    }, 500)), s.allowSlidePrev = r, s.allowSlideNext = i, s.params.watchOverflow && n !== s.snapGrid && s.checkOverflow();
  }
  function kt(s) {
    const e = this;
    e.enabled && (e.allowClick || (e.params.preventClicks && s.preventDefault(), e.params.preventClicksPropagation && e.animating && (s.stopPropagation(), s.stopImmediatePropagation())));
  }
  function At() {
    const s = this, {
      wrapperEl: e,
      rtlTranslate: t,
      enabled: i
    } = s;
    if (!i)
      return;
    s.previousTranslate = s.translate, s.isHorizontal() ? s.translate = -e.scrollLeft : s.translate = -e.scrollTop, s.translate === 0 && (s.translate = 0), s.updateActiveIndex(), s.updateSlidesClasses();
    let r;
    const n = s.maxTranslate() - s.minTranslate();
    n === 0 ? r = 0 : r = (s.translate - s.minTranslate()) / n, r !== s.progress && s.updateProgress(t ? -s.translate : s.translate), s.emit("setTranslate", s.translate, !1);
  }
  function Ot(s) {
    const e = this;
    K(e, s.target), !(e.params.cssMode || e.params.slidesPerView !== "auto" && !e.params.autoHeight) && e.update();
  }
  function zt() {
    const s = this;
    s.documentTouchHandlerProceeded || (s.documentTouchHandlerProceeded = !0, s.params.touchReleaseOnEdges && (s.el.style.touchAction = "auto"));
  }
  const xe = (s, e) => {
    const t = F(), {
      params: i,
      el: r,
      wrapperEl: n,
      device: l
    } = s, a = !!i.nested, o = e === "on" ? "addEventListener" : "removeEventListener", c = e;
    t[o]("touchstart", s.onDocumentTouchStart, {
      passive: !1,
      capture: a
    }), r[o]("touchstart", s.onTouchStart, {
      passive: !1
    }), r[o]("pointerdown", s.onTouchStart, {
      passive: !1
    }), t[o]("touchmove", s.onTouchMove, {
      passive: !1,
      capture: a
    }), t[o]("pointermove", s.onTouchMove, {
      passive: !1,
      capture: a
    }), t[o]("touchend", s.onTouchEnd, {
      passive: !0
    }), t[o]("pointerup", s.onTouchEnd, {
      passive: !0
    }), t[o]("pointercancel", s.onTouchEnd, {
      passive: !0
    }), t[o]("touchcancel", s.onTouchEnd, {
      passive: !0
    }), t[o]("pointerout", s.onTouchEnd, {
      passive: !0
    }), t[o]("pointerleave", s.onTouchEnd, {
      passive: !0
    }), t[o]("contextmenu", s.onTouchEnd, {
      passive: !0
    }), (i.preventClicks || i.preventClicksPropagation) && r[o]("click", s.onClick, !0), i.cssMode && n[o]("scroll", s.onScroll), i.updateOnWindowResize ? s[c](l.ios || l.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", we, !0) : s[c]("observerUpdate", we, !0), r[o]("load", s.onLoad, {
      capture: !0
    });
  };
  function $t() {
    const s = this, {
      params: e
    } = s;
    s.onTouchStart = Pt.bind(s), s.onTouchMove = Mt.bind(s), s.onTouchEnd = It.bind(s), s.onDocumentTouchStart = zt.bind(s), e.cssMode && (s.onScroll = At.bind(s)), s.onClick = kt.bind(s), s.onLoad = Ot.bind(s), xe(s, "on");
  }
  function Dt() {
    xe(this, "off");
  }
  var _t = {
    attachEvents: $t,
    detachEvents: Dt
  };
  const be = (s, e) => s.grid && e.grid && e.grid.rows > 1;
  function Gt() {
    const s = this, {
      realIndex: e,
      initialized: t,
      params: i,
      el: r
    } = s, n = i.breakpoints;
    if (!n || n && Object.keys(n).length === 0)
      return;
    const l = s.getBreakpoint(n, s.params.breakpointsBase, s.el);
    if (!l || s.currentBreakpoint === l)
      return;
    const o = (l in n ? n[l] : void 0) || s.originalParams, c = be(s, i), p = be(s, o), f = i.enabled;
    c && !p ? (r.classList.remove(`${i.containerModifierClass}grid`, `${i.containerModifierClass}grid-column`), s.emitContainerClasses()) : !c && p && (r.classList.add(`${i.containerModifierClass}grid`), (o.grid.fill && o.grid.fill === "column" || !o.grid.fill && i.grid.fill === "column") && r.classList.add(`${i.containerModifierClass}grid-column`), s.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach((d) => {
      if (typeof o[d] > "u")
        return;
      const u = i[d] && i[d].enabled, v = o[d] && o[d].enabled;
      u && !v && s[d].disable(), !u && v && s[d].enable();
    });
    const g = o.direction && o.direction !== i.direction, h = i.loop && (o.slidesPerView !== i.slidesPerView || g), m = i.loop;
    g && t && s.changeDirection(), z(s.params, o);
    const w = s.params.enabled, b = s.params.loop;
    Object.assign(s, {
      allowTouchMove: s.params.allowTouchMove,
      allowSlideNext: s.params.allowSlideNext,
      allowSlidePrev: s.params.allowSlidePrev
    }), f && !w ? s.disable() : !f && w && s.enable(), s.currentBreakpoint = l, s.emit("_beforeBreakpoint", o), t && (h ? (s.loopDestroy(), s.loopCreate(e), s.updateSlides()) : !m && b ? (s.loopCreate(e), s.updateSlides()) : m && !b && s.loopDestroy()), s.emit("breakpoint", o);
  }
  function Bt(s, e, t) {
    if (e === void 0 && (e = "window"), !s || e === "container" && !t)
      return;
    let i = !1;
    const r = O(), n = e === "window" ? r.innerHeight : t.clientHeight, l = Object.keys(s).map((a) => {
      if (typeof a == "string" && a.indexOf("@") === 0) {
        const o = parseFloat(a.substr(1));
        return {
          value: n * o,
          point: a
        };
      }
      return {
        value: a,
        point: a
      };
    });
    l.sort((a, o) => parseInt(a.value, 10) - parseInt(o.value, 10));
    for (let a = 0; a < l.length; a += 1) {
      const {
        point: o,
        value: c
      } = l[a];
      e === "window" ? r.matchMedia(`(min-width: ${c}px)`).matches && (i = o) : c <= t.clientWidth && (i = o);
    }
    return i || "max";
  }
  var Vt = {
    setBreakpoint: Gt,
    getBreakpoint: Bt
  };
  function Ft(s, e) {
    const t = [];
    return s.forEach((i) => {
      typeof i == "object" ? Object.keys(i).forEach((r) => {
        i[r] && t.push(e + r);
      }) : typeof i == "string" && t.push(e + i);
    }), t;
  }
  function Ht() {
    const s = this, {
      classNames: e,
      params: t,
      rtl: i,
      el: r,
      device: n
    } = s, l = Ft(["initialized", t.direction, {
      "free-mode": s.params.freeMode && t.freeMode.enabled
    }, {
      autoheight: t.autoHeight
    }, {
      rtl: i
    }, {
      grid: t.grid && t.grid.rows > 1
    }, {
      "grid-column": t.grid && t.grid.rows > 1 && t.grid.fill === "column"
    }, {
      android: n.android
    }, {
      ios: n.ios
    }, {
      "css-mode": t.cssMode
    }, {
      centered: t.cssMode && t.centeredSlides
    }, {
      "watch-progress": t.watchSlidesProgress
    }], t.containerModifierClass);
    e.push(...l), r.classList.add(...e), s.emitContainerClasses();
  }
  function Nt() {
    const s = this, {
      el: e,
      classNames: t
    } = s;
    e.classList.remove(...t), s.emitContainerClasses();
  }
  var Rt = {
    addClasses: Ht,
    removeClasses: Nt
  };
  function qt() {
    const s = this, {
      isLocked: e,
      params: t
    } = s, {
      slidesOffsetBefore: i
    } = t;
    if (i) {
      const r = s.slides.length - 1, n = s.slidesGrid[r] + s.slidesSizesGrid[r] + i * 2;
      s.isLocked = s.size > n;
    } else
      s.isLocked = s.snapGrid.length === 1;
    t.allowSlideNext === !0 && (s.allowSlideNext = !s.isLocked), t.allowSlidePrev === !0 && (s.allowSlidePrev = !s.isLocked), e && e !== s.isLocked && (s.isEnd = !1), e !== s.isLocked && s.emit(s.isLocked ? "lock" : "unlock");
  }
  var jt = {
    checkOverflow: qt
  }, Se = {
    init: !0,
    direction: "horizontal",
    oneWayMovement: !1,
    swiperElementNodeName: "SWIPER-CONTAINER",
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: !1,
    updateOnWindowResize: !0,
    resizeObserver: !0,
    nested: !1,
    createElements: !1,
    eventsPrefix: "swiper",
    enabled: !0,
    focusableElements: "input, select, option, textarea, button, video, label",
    // Overrides
    width: null,
    height: null,
    //
    preventInteractionOnTransition: !1,
    // ssr
    userAgent: null,
    url: null,
    // To support iOS's swipe-to-go-back gesture (when being used in-app).
    edgeSwipeDetection: !1,
    edgeSwipeThreshold: 20,
    // Autoheight
    autoHeight: !1,
    // Set wrapper width
    setWrapperSize: !1,
    // Virtual Translate
    virtualTranslate: !1,
    // Effects
    effect: "slide",
    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
    // Breakpoints
    breakpoints: void 0,
    breakpointsBase: "window",
    // Slides grid
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: !1,
    centeredSlides: !1,
    centeredSlidesBounds: !1,
    slidesOffsetBefore: 0,
    // in px
    slidesOffsetAfter: 0,
    // in px
    normalizeSlideIndex: !0,
    centerInsufficientSlides: !1,
    // Disable swiper and hide navigation when container not overflow
    watchOverflow: !0,
    // Round length
    roundLengths: !1,
    // Touches
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: !0,
    shortSwipes: !0,
    longSwipes: !0,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: !0,
    allowTouchMove: !0,
    threshold: 5,
    touchMoveStopPropagation: !1,
    touchStartPreventDefault: !0,
    touchStartForcePreventDefault: !1,
    touchReleaseOnEdges: !1,
    // Unique Navigation Elements
    uniqueNavElements: !0,
    // Resistance
    resistance: !0,
    resistanceRatio: 0.85,
    // Progress
    watchSlidesProgress: !1,
    // Cursor
    grabCursor: !1,
    // Clicks
    preventClicks: !0,
    preventClicksPropagation: !0,
    slideToClickedSlide: !1,
    // loop
    loop: !1,
    loopAddBlankSlides: !0,
    loopAdditionalSlides: 0,
    loopPreventsSliding: !0,
    // rewind
    rewind: !1,
    // Swiping/no swiping
    allowSlidePrev: !0,
    allowSlideNext: !0,
    swipeHandler: null,
    // '.swipe-handler',
    noSwiping: !0,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    // Passive Listeners
    passiveListeners: !0,
    maxBackfaceHiddenSlides: 10,
    // NS
    containerModifierClass: "swiper-",
    // NEW
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-blank",
    slideActiveClass: "swiper-slide-active",
    slideVisibleClass: "swiper-slide-visible",
    slideFullyVisibleClass: "swiper-slide-fully-visible",
    slideNextClass: "swiper-slide-next",
    slidePrevClass: "swiper-slide-prev",
    wrapperClass: "swiper-wrapper",
    lazyPreloaderClass: "swiper-lazy-preloader",
    lazyPreloadPrevNext: 0,
    // Callbacks
    runCallbacksOnInit: !0,
    // Internals
    _emitClasses: !1
  };
  function Yt(s, e) {
    return function(i) {
      i === void 0 && (i = {});
      const r = Object.keys(i)[0], n = i[r];
      if (typeof n != "object" || n === null) {
        z(e, i);
        return;
      }
      if (s[r] === !0 && (s[r] = {
        enabled: !0
      }), r === "navigation" && s[r] && s[r].enabled && !s[r].prevEl && !s[r].nextEl && (s[r].auto = !0), ["pagination", "scrollbar"].indexOf(r) >= 0 && s[r] && s[r].enabled && !s[r].el && (s[r].auto = !0), !(r in s && "enabled" in n)) {
        z(e, i);
        return;
      }
      typeof s[r] == "object" && !("enabled" in s[r]) && (s[r].enabled = !0), s[r] || (s[r] = {
        enabled: !1
      }), z(e, i);
    };
  }
  const ae = {
    eventsEmitter: Re,
    update: et,
    translate: ot,
    transition: ct,
    slide: wt,
    loop: yt,
    grabCursor: Et,
    events: _t,
    breakpoints: Vt,
    checkOverflow: jt,
    classes: Rt
  }, le = {};
  class $ {
    constructor() {
      let e, t;
      for (var i = arguments.length, r = new Array(i), n = 0; n < i; n++)
        r[n] = arguments[n];
      r.length === 1 && r[0].constructor && Object.prototype.toString.call(r[0]).slice(8, -1) === "Object" ? t = r[0] : [e, t] = r, t || (t = {}), t = z({}, t), e && !t.el && (t.el = e);
      const l = F();
      if (t.el && typeof t.el == "string" && l.querySelectorAll(t.el).length > 1) {
        const p = [];
        return l.querySelectorAll(t.el).forEach((f) => {
          const g = z({}, t, {
            el: f
          });
          p.push(new $(g));
        }), p;
      }
      const a = this;
      a.__swiper__ = !0, a.support = me(), a.device = he({
        userAgent: t.userAgent
      }), a.browser = Fe(), a.eventsListeners = {}, a.eventsAnyListeners = [], a.modules = [...a.__modules__], t.modules && Array.isArray(t.modules) && a.modules.push(...t.modules);
      const o = {};
      a.modules.forEach((p) => {
        p({
          params: t,
          swiper: a,
          extendParams: Yt(t, o),
          on: a.on.bind(a),
          once: a.once.bind(a),
          off: a.off.bind(a),
          emit: a.emit.bind(a)
        });
      });
      const c = z({}, Se, o);
      return a.params = z({}, c, le, t), a.originalParams = z({}, a.params), a.passedParams = z({}, t), a.params && a.params.on && Object.keys(a.params.on).forEach((p) => {
        a.on(p, a.params.on[p]);
      }), a.params && a.params.onAny && a.onAny(a.params.onAny), Object.assign(a, {
        enabled: a.params.enabled,
        el: e,
        // Classes
        classNames: [],
        // Slides
        slides: [],
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],
        // isDirection
        isHorizontal() {
          return a.params.direction === "horizontal";
        },
        isVertical() {
          return a.params.direction === "vertical";
        },
        // Indexes
        activeIndex: 0,
        realIndex: 0,
        //
        isBeginning: !0,
        isEnd: !1,
        // Props
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: !1,
        cssOverflowAdjustment() {
          return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
        },
        // Locks
        allowSlideNext: a.params.allowSlideNext,
        allowSlidePrev: a.params.allowSlidePrev,
        // Touch Events
        touchEventsData: {
          isTouched: void 0,
          isMoved: void 0,
          allowTouchCallbacks: void 0,
          touchStartTime: void 0,
          isScrolling: void 0,
          currentTranslate: void 0,
          startTranslate: void 0,
          allowThresholdMove: void 0,
          // Form elements to match
          focusableElements: a.params.focusableElements,
          // Last click time
          lastClickTime: 0,
          clickTimeout: void 0,
          // Velocities
          velocities: [],
          allowMomentumBounce: void 0,
          startMoving: void 0,
          pointerId: null,
          touchId: null
        },
        // Clicks
        allowClick: !0,
        // Touches
        allowTouchMove: a.params.allowTouchMove,
        touches: {
          startX: 0,
          startY: 0,
          currentX: 0,
          currentY: 0,
          diff: 0
        },
        // Images
        imagesToLoad: [],
        imagesLoaded: 0
      }), a.emit("_swiper"), a.params.init && a.init(), a;
    }
    getDirectionLabel(e) {
      return this.isHorizontal() ? e : {
        width: "height",
        "margin-top": "margin-left",
        "margin-bottom ": "margin-right",
        "margin-left": "margin-top",
        "margin-right": "margin-bottom",
        "padding-left": "padding-top",
        "padding-right": "padding-bottom",
        marginRight: "marginBottom"
      }[e];
    }
    getSlideIndex(e) {
      const {
        slidesEl: t,
        params: i
      } = this, r = _(t, `.${i.slideClass}, swiper-slide`), n = U(r[0]);
      return U(e) - n;
    }
    getSlideIndexByData(e) {
      return this.getSlideIndex(this.slides.filter((t) => t.getAttribute("data-swiper-slide-index") * 1 === e)[0]);
    }
    recalcSlides() {
      const e = this, {
        slidesEl: t,
        params: i
      } = e;
      e.slides = _(t, `.${i.slideClass}, swiper-slide`);
    }
    enable() {
      const e = this;
      e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable"));
    }
    disable() {
      const e = this;
      e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable"));
    }
    setProgress(e, t) {
      const i = this;
      e = Math.min(Math.max(e, 0), 1);
      const r = i.minTranslate(), l = (i.maxTranslate() - r) * e + r;
      i.translateTo(l, typeof t > "u" ? 0 : t), i.updateActiveIndex(), i.updateSlidesClasses();
    }
    emitContainerClasses() {
      const e = this;
      if (!e.params._emitClasses || !e.el)
        return;
      const t = e.el.className.split(" ").filter((i) => i.indexOf("swiper") === 0 || i.indexOf(e.params.containerModifierClass) === 0);
      e.emit("_containerClasses", t.join(" "));
    }
    getSlideClasses(e) {
      const t = this;
      return t.destroyed ? "" : e.className.split(" ").filter((i) => i.indexOf("swiper-slide") === 0 || i.indexOf(t.params.slideClass) === 0).join(" ");
    }
    emitSlidesClasses() {
      const e = this;
      if (!e.params._emitClasses || !e.el)
        return;
      const t = [];
      e.slides.forEach((i) => {
        const r = e.getSlideClasses(i);
        t.push({
          slideEl: i,
          classNames: r
        }), e.emit("_slideClass", i, r);
      }), e.emit("_slideClasses", t);
    }
    slidesPerViewDynamic(e, t) {
      e === void 0 && (e = "current"), t === void 0 && (t = !1);
      const i = this, {
        params: r,
        slides: n,
        slidesGrid: l,
        slidesSizesGrid: a,
        size: o,
        activeIndex: c
      } = i;
      let p = 1;
      if (typeof r.slidesPerView == "number")
        return r.slidesPerView;
      if (r.centeredSlides) {
        let f = n[c] ? Math.ceil(n[c].swiperSlideSize) : 0, g;
        for (let h = c + 1; h < n.length; h += 1)
          n[h] && !g && (f += Math.ceil(n[h].swiperSlideSize), p += 1, f > o && (g = !0));
        for (let h = c - 1; h >= 0; h -= 1)
          n[h] && !g && (f += n[h].swiperSlideSize, p += 1, f > o && (g = !0));
      } else if (e === "current")
        for (let f = c + 1; f < n.length; f += 1)
          (t ? l[f] + a[f] - l[c] < o : l[f] - l[c] < o) && (p += 1);
      else
        for (let f = c - 1; f >= 0; f -= 1)
          l[c] - l[f] < o && (p += 1);
      return p;
    }
    update() {
      const e = this;
      if (!e || e.destroyed)
        return;
      const {
        snapGrid: t,
        params: i
      } = e;
      i.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading="lazy"]')].forEach((l) => {
        l.complete && K(e, l);
      }), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses();
      function r() {
        const l = e.rtlTranslate ? e.translate * -1 : e.translate, a = Math.min(Math.max(l, e.maxTranslate()), e.minTranslate());
        e.setTranslate(a), e.updateActiveIndex(), e.updateSlidesClasses();
      }
      let n;
      if (i.freeMode && i.freeMode.enabled && !i.cssMode)
        r(), i.autoHeight && e.updateAutoHeight();
      else {
        if ((i.slidesPerView === "auto" || i.slidesPerView > 1) && e.isEnd && !i.centeredSlides) {
          const l = e.virtual && i.virtual.enabled ? e.virtual.slides : e.slides;
          n = e.slideTo(l.length - 1, 0, !1, !0);
        } else
          n = e.slideTo(e.activeIndex, 0, !1, !0);
        n || r();
      }
      i.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update");
    }
    changeDirection(e, t) {
      t === void 0 && (t = !0);
      const i = this, r = i.params.direction;
      return e || (e = r === "horizontal" ? "vertical" : "horizontal"), e === r || e !== "horizontal" && e !== "vertical" || (i.el.classList.remove(`${i.params.containerModifierClass}${r}`), i.el.classList.add(`${i.params.containerModifierClass}${e}`), i.emitContainerClasses(), i.params.direction = e, i.slides.forEach((n) => {
        e === "vertical" ? n.style.width = "" : n.style.height = "";
      }), i.emit("changeDirection"), t && i.update()), i;
    }
    changeLanguageDirection(e) {
      const t = this;
      t.rtl && e === "rtl" || !t.rtl && e === "ltr" || (t.rtl = e === "rtl", t.rtlTranslate = t.params.direction === "horizontal" && t.rtl, t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update());
    }
    mount(e) {
      const t = this;
      if (t.mounted)
        return !0;
      let i = e || t.params.el;
      if (typeof i == "string" && (i = document.querySelector(i)), !i)
        return !1;
      i.swiper = t, i.parentNode && i.parentNode.host && i.parentNode.host.nodeName === t.params.swiperElementNodeName.toUpperCase() && (t.isElement = !0);
      const r = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`;
      let l = i && i.shadowRoot && i.shadowRoot.querySelector ? i.shadowRoot.querySelector(r()) : _(i, r())[0];
      return !l && t.params.createElements && (l = Z("div", t.params.wrapperClass), i.append(l), _(i, `.${t.params.slideClass}`).forEach((a) => {
        l.append(a);
      })), Object.assign(t, {
        el: i,
        wrapperEl: l,
        slidesEl: t.isElement && !i.parentNode.host.slideSlots ? i.parentNode.host : l,
        hostEl: t.isElement ? i.parentNode.host : i,
        mounted: !0,
        // RTL
        rtl: i.dir.toLowerCase() === "rtl" || G(i, "direction") === "rtl",
        rtlTranslate: t.params.direction === "horizontal" && (i.dir.toLowerCase() === "rtl" || G(i, "direction") === "rtl"),
        wrongRTL: G(l, "display") === "-webkit-box"
      }), !0;
    }
    init(e) {
      const t = this;
      if (t.initialized || t.mount(e) === !1)
        return t;
      t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(), t.attachEvents();
      const r = [...t.el.querySelectorAll('[loading="lazy"]')];
      return t.isElement && r.push(...t.hostEl.querySelectorAll('[loading="lazy"]')), r.forEach((n) => {
        n.complete ? K(t, n) : n.addEventListener("load", (l) => {
          K(t, l.target);
        });
      }), oe(t), t.initialized = !0, oe(t), t.emit("init"), t.emit("afterInit"), t;
    }
    destroy(e, t) {
      e === void 0 && (e = !0), t === void 0 && (t = !0);
      const i = this, {
        params: r,
        el: n,
        wrapperEl: l,
        slides: a
      } = i;
      return typeof i.params > "u" || i.destroyed || (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), r.loop && i.loopDestroy(), t && (i.removeClasses(), n.removeAttribute("style"), l.removeAttribute("style"), a && a.length && a.forEach((o) => {
        o.classList.remove(r.slideVisibleClass, r.slideFullyVisibleClass, r.slideActiveClass, r.slideNextClass, r.slidePrevClass), o.removeAttribute("style"), o.removeAttribute("data-swiper-slide-index");
      })), i.emit("destroy"), Object.keys(i.eventsListeners).forEach((o) => {
        i.off(o);
      }), e !== !1 && (i.el.swiper = null, Ae(i)), i.destroyed = !0), null;
    }
    static extendDefaults(e) {
      z(le, e);
    }
    static get extendedDefaults() {
      return le;
    }
    static get defaults() {
      return Se;
    }
    static installModule(e) {
      $.prototype.__modules__ || ($.prototype.__modules__ = []);
      const t = $.prototype.__modules__;
      typeof e == "function" && t.indexOf(e) < 0 && t.push(e);
    }
    static use(e) {
      return Array.isArray(e) ? (e.forEach((t) => $.installModule(t)), $) : ($.installModule(e), $);
    }
  }
  Object.keys(ae).forEach((s) => {
    Object.keys(ae[s]).forEach((e) => {
      $.prototype[e] = ae[s][e];
    });
  }), $.use([He, Ne]);
  function ye(s, e, t, i) {
    return s.params.createElements && Object.keys(i).forEach((r) => {
      if (!t[r] && t.auto === !0) {
        let n = _(s.el, `.${i[r]}`)[0];
        n || (n = Z("div", i[r]), n.className = i[r], s.el.append(n)), t[r] = n, e[r] = n;
      }
    }), t;
  }
  function Wt(s) {
    let {
      swiper: e,
      extendParams: t,
      on: i,
      emit: r
    } = s;
    t({
      navigation: {
        nextEl: null,
        prevEl: null,
        hideOnClick: !1,
        disabledClass: "swiper-button-disabled",
        hiddenClass: "swiper-button-hidden",
        lockClass: "swiper-button-lock",
        navigationDisabledClass: "swiper-navigation-disabled"
      }
    }), e.navigation = {
      nextEl: null,
      prevEl: null
    };
    function n(m) {
      let w;
      return m && typeof m == "string" && e.isElement && (w = e.el.querySelector(m), w) ? w : (m && (typeof m == "string" && (w = [...document.querySelectorAll(m)]), e.params.uniqueNavElements && typeof m == "string" && w.length > 1 && e.el.querySelectorAll(m).length === 1 && (w = e.el.querySelector(m))), m && !w ? m : w);
    }
    function l(m, w) {
      const b = e.params.navigation;
      m = k(m), m.forEach((d) => {
        d && (d.classList[w ? "add" : "remove"](...b.disabledClass.split(" ")), d.tagName === "BUTTON" && (d.disabled = w), e.params.watchOverflow && e.enabled && d.classList[e.isLocked ? "add" : "remove"](b.lockClass));
      });
    }
    function a() {
      const {
        nextEl: m,
        prevEl: w
      } = e.navigation;
      if (e.params.loop) {
        l(w, !1), l(m, !1);
        return;
      }
      l(w, e.isBeginning && !e.params.rewind), l(m, e.isEnd && !e.params.rewind);
    }
    function o(m) {
      m.preventDefault(), !(e.isBeginning && !e.params.loop && !e.params.rewind) && (e.slidePrev(), r("navigationPrev"));
    }
    function c(m) {
      m.preventDefault(), !(e.isEnd && !e.params.loop && !e.params.rewind) && (e.slideNext(), r("navigationNext"));
    }
    function p() {
      const m = e.params.navigation;
      if (e.params.navigation = ye(e, e.originalParams.navigation, e.params.navigation, {
        nextEl: "swiper-button-next",
        prevEl: "swiper-button-prev"
      }), !(m.nextEl || m.prevEl))
        return;
      let w = n(m.nextEl), b = n(m.prevEl);
      Object.assign(e.navigation, {
        nextEl: w,
        prevEl: b
      }), w = k(w), b = k(b);
      const d = (u, v) => {
        u && u.addEventListener("click", v === "next" ? c : o), !e.enabled && u && u.classList.add(...m.lockClass.split(" "));
      };
      w.forEach((u) => d(u, "next")), b.forEach((u) => d(u, "prev"));
    }
    function f() {
      let {
        nextEl: m,
        prevEl: w
      } = e.navigation;
      m = k(m), w = k(w);
      const b = (d, u) => {
        d.removeEventListener("click", u === "next" ? c : o), d.classList.remove(...e.params.navigation.disabledClass.split(" "));
      };
      m.forEach((d) => b(d, "next")), w.forEach((d) => b(d, "prev"));
    }
    i("init", () => {
      e.params.navigation.enabled === !1 ? h() : (p(), a());
    }), i("toEdge fromEdge lock unlock", () => {
      a();
    }), i("destroy", () => {
      f();
    }), i("enable disable", () => {
      let {
        nextEl: m,
        prevEl: w
      } = e.navigation;
      if (m = k(m), w = k(w), e.enabled) {
        a();
        return;
      }
      [...m, ...w].filter((b) => !!b).forEach((b) => b.classList.add(e.params.navigation.lockClass));
    }), i("click", (m, w) => {
      let {
        nextEl: b,
        prevEl: d
      } = e.navigation;
      b = k(b), d = k(d);
      const u = w.target;
      if (e.params.navigation.hideOnClick && !d.includes(u) && !b.includes(u)) {
        if (e.pagination && e.params.pagination && e.params.pagination.clickable && (e.pagination.el === u || e.pagination.el.contains(u)))
          return;
        let v;
        b.length ? v = b[0].classList.contains(e.params.navigation.hiddenClass) : d.length && (v = d[0].classList.contains(e.params.navigation.hiddenClass)), r(v === !0 ? "navigationShow" : "navigationHide"), [...b, ...d].filter((x) => !!x).forEach((x) => x.classList.toggle(e.params.navigation.hiddenClass));
      }
    });
    const g = () => {
      e.el.classList.remove(...e.params.navigation.navigationDisabledClass.split(" ")), p(), a();
    }, h = () => {
      e.el.classList.add(...e.params.navigation.navigationDisabledClass.split(" ")), f();
    };
    Object.assign(e.navigation, {
      enable: g,
      disable: h,
      update: a,
      init: p,
      destroy: f
    });
  }
  function H(s) {
    return s === void 0 && (s = ""), `.${s.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}`;
  }
  function Xt(s) {
    let {
      swiper: e,
      extendParams: t,
      on: i,
      emit: r
    } = s;
    const n = "swiper-pagination";
    t({
      pagination: {
        el: null,
        bulletElement: "span",
        clickable: !1,
        hideOnClick: !1,
        renderBullet: null,
        renderProgressbar: null,
        renderFraction: null,
        renderCustom: null,
        progressbarOpposite: !1,
        type: "bullets",
        // 'bullets' or 'progressbar' or 'fraction' or 'custom'
        dynamicBullets: !1,
        dynamicMainBullets: 1,
        formatFractionCurrent: (d) => d,
        formatFractionTotal: (d) => d,
        bulletClass: `${n}-bullet`,
        bulletActiveClass: `${n}-bullet-active`,
        modifierClass: `${n}-`,
        currentClass: `${n}-current`,
        totalClass: `${n}-total`,
        hiddenClass: `${n}-hidden`,
        progressbarFillClass: `${n}-progressbar-fill`,
        progressbarOppositeClass: `${n}-progressbar-opposite`,
        clickableClass: `${n}-clickable`,
        lockClass: `${n}-lock`,
        horizontalClass: `${n}-horizontal`,
        verticalClass: `${n}-vertical`,
        paginationDisabledClass: `${n}-disabled`
      }
    }), e.pagination = {
      el: null,
      bullets: []
    };
    let l, a = 0;
    function o() {
      return !e.params.pagination.el || !e.pagination.el || Array.isArray(e.pagination.el) && e.pagination.el.length === 0;
    }
    function c(d, u) {
      const {
        bulletActiveClass: v
      } = e.params.pagination;
      d && (d = d[`${u === "prev" ? "previous" : "next"}ElementSibling`], d && (d.classList.add(`${v}-${u}`), d = d[`${u === "prev" ? "previous" : "next"}ElementSibling`], d && d.classList.add(`${v}-${u}-${u}`)));
    }
    function p(d) {
      const u = d.target.closest(H(e.params.pagination.bulletClass));
      if (!u)
        return;
      d.preventDefault();
      const v = U(u) * e.params.slidesPerGroup;
      if (e.params.loop) {
        if (e.realIndex === v)
          return;
        e.slideToLoop(v);
      } else
        e.slideTo(v);
    }
    function f() {
      const d = e.rtl, u = e.params.pagination;
      if (o())
        return;
      let v = e.pagination.el;
      v = k(v);
      let x, y;
      const M = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, D = e.params.loop ? Math.ceil(M / e.params.slidesPerGroup) : e.snapGrid.length;
      if (e.params.loop ? (y = e.previousRealIndex || 0, x = e.params.slidesPerGroup > 1 ? Math.floor(e.realIndex / e.params.slidesPerGroup) : e.realIndex) : typeof e.snapIndex < "u" ? (x = e.snapIndex, y = e.previousSnapIndex) : (y = e.previousIndex || 0, x = e.activeIndex || 0), u.type === "bullets" && e.pagination.bullets && e.pagination.bullets.length > 0) {
        const L = e.pagination.bullets;
        let A, S, E;
        if (u.dynamicBullets && (l = te(L[0], e.isHorizontal() ? "width" : "height", !0), v.forEach((C) => {
          C.style[e.isHorizontal() ? "width" : "height"] = `${l * (u.dynamicMainBullets + 4)}px`;
        }), u.dynamicMainBullets > 1 && y !== void 0 && (a += x - (y || 0), a > u.dynamicMainBullets - 1 ? a = u.dynamicMainBullets - 1 : a < 0 && (a = 0)), A = Math.max(x - a, 0), S = A + (Math.min(L.length, u.dynamicMainBullets) - 1), E = (S + A) / 2), L.forEach((C) => {
          const T = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((P) => `${u.bulletActiveClass}${P}`)].map((P) => typeof P == "string" && P.includes(" ") ? P.split(" ") : P).flat();
          C.classList.remove(...T);
        }), v.length > 1)
          L.forEach((C) => {
            const T = U(C);
            T === x ? C.classList.add(...u.bulletActiveClass.split(" ")) : e.isElement && C.setAttribute("part", "bullet"), u.dynamicBullets && (T >= A && T <= S && C.classList.add(...`${u.bulletActiveClass}-main`.split(" ")), T === A && c(C, "prev"), T === S && c(C, "next"));
          });
        else {
          const C = L[x];
          if (C && C.classList.add(...u.bulletActiveClass.split(" ")), e.isElement && L.forEach((T, P) => {
            T.setAttribute("part", P === x ? "bullet-active" : "bullet");
          }), u.dynamicBullets) {
            const T = L[A], P = L[S];
            for (let I = A; I <= S; I += 1)
              L[I] && L[I].classList.add(...`${u.bulletActiveClass}-main`.split(" "));
            c(T, "prev"), c(P, "next");
          }
        }
        if (u.dynamicBullets) {
          const C = Math.min(L.length, u.dynamicMainBullets + 4), T = (l * C - l) / 2 - E * l, P = d ? "right" : "left";
          L.forEach((I) => {
            I.style[e.isHorizontal() ? P : "top"] = `${T}px`;
          });
        }
      }
      v.forEach((L, A) => {
        if (u.type === "fraction" && (L.querySelectorAll(H(u.currentClass)).forEach((S) => {
          S.textContent = u.formatFractionCurrent(x + 1);
        }), L.querySelectorAll(H(u.totalClass)).forEach((S) => {
          S.textContent = u.formatFractionTotal(D);
        })), u.type === "progressbar") {
          let S;
          u.progressbarOpposite ? S = e.isHorizontal() ? "vertical" : "horizontal" : S = e.isHorizontal() ? "horizontal" : "vertical";
          const E = (x + 1) / D;
          let C = 1, T = 1;
          S === "horizontal" ? C = E : T = E, L.querySelectorAll(H(u.progressbarFillClass)).forEach((P) => {
            P.style.transform = `translate3d(0,0,0) scaleX(${C}) scaleY(${T})`, P.style.transitionDuration = `${e.params.speed}ms`;
          });
        }
        u.type === "custom" && u.renderCustom ? (L.innerHTML = u.renderCustom(e, x + 1, D), A === 0 && r("paginationRender", L)) : (A === 0 && r("paginationRender", L), r("paginationUpdate", L)), e.params.watchOverflow && e.enabled && L.classList[e.isLocked ? "add" : "remove"](u.lockClass);
      });
    }
    function g() {
      const d = e.params.pagination;
      if (o())
        return;
      const u = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.grid && e.params.grid.rows > 1 ? e.slides.length / Math.ceil(e.params.grid.rows) : e.slides.length;
      let v = e.pagination.el;
      v = k(v);
      let x = "";
      if (d.type === "bullets") {
        let y = e.params.loop ? Math.ceil(u / e.params.slidesPerGroup) : e.snapGrid.length;
        e.params.freeMode && e.params.freeMode.enabled && y > u && (y = u);
        for (let M = 0; M < y; M += 1)
          d.renderBullet ? x += d.renderBullet.call(e, M, d.bulletClass) : x += `<${d.bulletElement} ${e.isElement ? 'part="bullet"' : ""} class="${d.bulletClass}"></${d.bulletElement}>`;
      }
      d.type === "fraction" && (d.renderFraction ? x = d.renderFraction.call(e, d.currentClass, d.totalClass) : x = `<span class="${d.currentClass}"></span> / <span class="${d.totalClass}"></span>`), d.type === "progressbar" && (d.renderProgressbar ? x = d.renderProgressbar.call(e, d.progressbarFillClass) : x = `<span class="${d.progressbarFillClass}"></span>`), e.pagination.bullets = [], v.forEach((y) => {
        d.type !== "custom" && (y.innerHTML = x || ""), d.type === "bullets" && e.pagination.bullets.push(...y.querySelectorAll(H(d.bulletClass)));
      }), d.type !== "custom" && r("paginationRender", v[0]);
    }
    function h() {
      e.params.pagination = ye(e, e.originalParams.pagination, e.params.pagination, {
        el: "swiper-pagination"
      });
      const d = e.params.pagination;
      if (!d.el)
        return;
      let u;
      typeof d.el == "string" && e.isElement && (u = e.el.querySelector(d.el)), !u && typeof d.el == "string" && (u = [...document.querySelectorAll(d.el)]), u || (u = d.el), !(!u || u.length === 0) && (e.params.uniqueNavElements && typeof d.el == "string" && Array.isArray(u) && u.length > 1 && (u = [...e.el.querySelectorAll(d.el)], u.length > 1 && (u = u.filter((v) => fe(v, ".swiper")[0] === e.el)[0])), Array.isArray(u) && u.length === 1 && (u = u[0]), Object.assign(e.pagination, {
        el: u
      }), u = k(u), u.forEach((v) => {
        d.type === "bullets" && d.clickable && v.classList.add(...(d.clickableClass || "").split(" ")), v.classList.add(d.modifierClass + d.type), v.classList.add(e.isHorizontal() ? d.horizontalClass : d.verticalClass), d.type === "bullets" && d.dynamicBullets && (v.classList.add(`${d.modifierClass}${d.type}-dynamic`), a = 0, d.dynamicMainBullets < 1 && (d.dynamicMainBullets = 1)), d.type === "progressbar" && d.progressbarOpposite && v.classList.add(d.progressbarOppositeClass), d.clickable && v.addEventListener("click", p), e.enabled || v.classList.add(d.lockClass);
      }));
    }
    function m() {
      const d = e.params.pagination;
      if (o())
        return;
      let u = e.pagination.el;
      u && (u = k(u), u.forEach((v) => {
        v.classList.remove(d.hiddenClass), v.classList.remove(d.modifierClass + d.type), v.classList.remove(e.isHorizontal() ? d.horizontalClass : d.verticalClass), d.clickable && (v.classList.remove(...(d.clickableClass || "").split(" ")), v.removeEventListener("click", p));
      })), e.pagination.bullets && e.pagination.bullets.forEach((v) => v.classList.remove(...d.bulletActiveClass.split(" ")));
    }
    i("changeDirection", () => {
      if (!e.pagination || !e.pagination.el)
        return;
      const d = e.params.pagination;
      let {
        el: u
      } = e.pagination;
      u = k(u), u.forEach((v) => {
        v.classList.remove(d.horizontalClass, d.verticalClass), v.classList.add(e.isHorizontal() ? d.horizontalClass : d.verticalClass);
      });
    }), i("init", () => {
      e.params.pagination.enabled === !1 ? b() : (h(), g(), f());
    }), i("activeIndexChange", () => {
      typeof e.snapIndex > "u" && f();
    }), i("snapIndexChange", () => {
      f();
    }), i("snapGridLengthChange", () => {
      g(), f();
    }), i("destroy", () => {
      m();
    }), i("enable disable", () => {
      let {
        el: d
      } = e.pagination;
      d && (d = k(d), d.forEach((u) => u.classList[e.enabled ? "remove" : "add"](e.params.pagination.lockClass)));
    }), i("lock unlock", () => {
      f();
    }), i("click", (d, u) => {
      const v = u.target, x = k(e.pagination.el);
      if (e.params.pagination.el && e.params.pagination.hideOnClick && x && x.length > 0 && !v.classList.contains(e.params.pagination.bulletClass)) {
        if (e.navigation && (e.navigation.nextEl && v === e.navigation.nextEl || e.navigation.prevEl && v === e.navigation.prevEl))
          return;
        const y = x[0].classList.contains(e.params.pagination.hiddenClass);
        r(y === !0 ? "paginationShow" : "paginationHide"), x.forEach((M) => M.classList.toggle(e.params.pagination.hiddenClass));
      }
    });
    const w = () => {
      e.el.classList.remove(e.params.pagination.paginationDisabledClass);
      let {
        el: d
      } = e.pagination;
      d && (d = k(d), d.forEach((u) => u.classList.remove(e.params.pagination.paginationDisabledClass))), h(), g(), f();
    }, b = () => {
      e.el.classList.add(e.params.pagination.paginationDisabledClass);
      let {
        el: d
      } = e.pagination;
      d && (d = k(d), d.forEach((u) => u.classList.add(e.params.pagination.paginationDisabledClass))), m();
    };
    Object.assign(e.pagination, {
      enable: w,
      disable: b,
      render: g,
      update: f,
      init: h,
      destroy: m
    });
  }
  const Zt = {
    close: (
      /* HTML */
      `<svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path
      d="M13.0375 0.306086C12.6432 -0.088301 12.0061 -0.088301 11.6117 0.306086L6.66667 5.24099L1.72165 0.295974C1.32727 -0.0984138 0.690178 -0.0984138 0.295791 0.295974C-0.0985969 0.690361 -0.0985969 1.32745 0.295791 1.72184L5.2408 6.66685L0.295791 11.6119C-0.0985969 12.0062 -0.0985969 12.6433 0.295791 13.0377C0.690178 13.4321 1.32727 13.4321 1.72165 13.0377L6.66667 8.09271L11.6117 13.0377C12.0061 13.4321 12.6432 13.4321 13.0375 13.0377C13.4319 12.6433 13.4319 12.0062 13.0375 11.6119L8.09253 6.66685L13.0375 1.72184C13.4218 1.33756 13.4218 0.690362 13.0375 0.306086Z"
      fill="white"
    />
  </svg> `
    ),
    arrowPrev: (
      /* HTML */
      `<svg width="8" height="12" viewBox="0 0 8 12" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M7 11L2 6L7 1" stroke="#0373BD" stroke-width="2" />
  </svg> `
    ),
    arrowNext: (
      /* HTML */
      `<svg width="8" height="12" viewBox="0 0 8 12" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M1 1L6 6L1 11" stroke="#0373BD" stroke-width="2" />
  </svg> `
    ),
    quality: (
      /* HTML */
      `<svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path
      d="M15.8889 11.198L15.0004 9.35364L14.1119 11.198C14.0204 11.3878 13.8437 11.5193 13.6392 11.5497L11.6523 11.8455L13.0901 13.2811C13.238 13.4289 13.3055 13.6416 13.2706 13.8503L12.9312 15.8775L14.7083 14.9203C14.7997 14.8711 14.9001 14.8465 15.0004 14.8465C15.1007 14.8465 15.201 14.8711 15.2924 14.9203L17.0696 15.8775L16.7301 13.8503C16.6952 13.6417 16.7628 13.4289 16.9106 13.2811L18.3484 11.8455L16.3615 11.5497C16.1571 11.5193 15.9803 11.3878 15.8889 11.198Z"
      fill="#0373BD"
    />
    <path
      d="M24.0317 13.1859C23.9779 13.0165 23.9779 12.8373 24.0317 12.6678L24.5404 11.0643C24.8189 10.1863 24.5161 9.23191 23.7871 8.68924L22.4555 7.69815C22.3148 7.59341 22.212 7.44849 22.1582 7.279L21.6496 5.67541C21.371 4.7975 20.5785 4.20763 19.6774 4.20763H18.0314C17.8575 4.20763 17.6912 4.15227 17.5505 4.04753L16.2188 3.05644C15.4898 2.5139 14.5102 2.5139 13.7812 3.05644L12.4496 4.04753C12.3089 4.15227 12.1425 4.20763 11.9686 4.20763H10.3227C9.4216 4.20763 8.629 4.7975 8.35045 5.67548L7.8418 7.27913C7.78807 7.44855 7.68526 7.59348 7.54454 7.69822L6.21298 8.6893C5.48402 9.23191 5.18124 10.1863 5.45973 11.0643L5.96838 12.6679C6.02217 12.8373 6.02217 13.0165 5.96838 13.186L5.45973 14.7896C5.18124 15.6675 5.48402 16.622 6.21304 17.1646L7.54467 18.1558C7.68539 18.2605 7.78814 18.4054 7.84186 18.5749L8.35051 20.1785C8.62907 21.0564 9.4216 21.6463 10.3227 21.6463H11.9687C12.1426 21.6463 12.3089 21.7017 12.4497 21.8064L13.7813 22.7974C14.1459 23.0688 14.5729 23.2044 15.0001 23.2044C15.4272 23.2044 15.8545 23.0688 16.219 22.7975L17.5506 21.8064C17.6913 21.7017 17.8576 21.6463 18.0316 21.6463H19.6775C20.5786 21.6463 21.3712 21.0564 21.6497 20.1785L22.1584 18.5748C22.2121 18.4054 22.3148 18.2605 22.4556 18.1557L23.7872 17.1646C24.5162 16.622 24.8189 15.6675 24.5405 14.7895L24.0317 13.1859ZM20.1351 11.8571L18.023 13.9661L18.5216 16.9442C18.562 17.1853 18.4651 17.4292 18.2718 17.5731C18.1625 17.6545 18.0329 17.6959 17.9028 17.6959C17.8029 17.6959 17.7027 17.6715 17.6108 17.622L15.0001 16.2159L12.3893 17.622C12.1779 17.7358 11.9215 17.7169 11.7283 17.5731C11.535 17.4292 11.4382 17.1854 11.4785 16.9442L11.9772 13.9661L9.86504 11.8571C9.69394 11.6862 9.63243 11.4307 9.70624 11.1979C9.78012 10.9652 9.97651 10.7956 10.2129 10.7603L13.1318 10.3258L14.4372 7.61624C14.5429 7.39679 14.7611 7.25784 15.0001 7.25784C15.239 7.25784 15.4572 7.39679 15.5629 7.61624L16.8683 10.3258L19.7872 10.7603C20.0237 10.7955 20.2201 10.9652 20.2939 11.1979C20.3677 11.4307 20.3061 11.6862 20.1351 11.8571Z"
      fill="#0373BD"
    />
    <path
      d="M26.8162 21.5851L23.8512 18.547L23.2015 19.0299L22.7239 20.5351C22.2939 21.8918 21.0694 22.8029 19.6773 22.8029H18.1326L17.5244 23.2549L21.3556 27.179C21.4742 27.3005 21.6349 27.3673 21.7994 27.3673C21.842 27.3673 21.8853 27.3628 21.928 27.3532C22.1352 27.3088 22.3065 27.1603 22.3837 26.9584L23.57 23.8528L26.6009 22.6383C26.7986 22.5592 26.9436 22.3836 26.9869 22.1708C27.0302 21.9586 26.9662 21.7381 26.8162 21.5851Z"
      fill="#0373BD"
    />
    <path
      d="M11.8676 22.8029H10.3229C8.9308 22.8029 7.70625 21.8918 7.27631 20.5351L6.79866 19.0299L6.14904 18.547L3.18401 21.5851C3.034 21.7381 2.96998 21.9586 3.01329 22.1708C3.0566 22.3836 3.20158 22.5592 3.39929 22.6383L6.43023 23.8528L7.61649 26.9584C7.69369 27.1603 7.86504 27.3088 8.07217 27.3532C8.11485 27.3628 8.15816 27.3673 8.20084 27.3673C8.36528 27.3673 8.52596 27.3005 8.64459 27.179L12.4758 23.2549L11.8676 22.8029Z"
      fill="#0373BD"
    />
  </svg> `
    ),
    money: (
      /* HTML */
      `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path
      d="M10.114 4.22174C10.4575 3.75614 10.6542 3.18744 10.6542 2.59688V1.5626C10.6542 1.39073 10.5137 1.25012 10.3419 1.25012C9.66746 1.25012 9.31148 1.41886 8.99921 1.56883C8.7088 1.70946 8.459 1.82819 7.92816 1.82819C7.39732 1.82819 7.14751 1.70946 6.85713 1.56883C6.54486 1.41886 6.18888 1.25012 5.51441 1.25012C5.34264 1.25012 5.20215 1.39073 5.20215 1.5626V2.59688C5.20215 3.18744 5.39887 3.75615 5.74236 4.22174H10.114Z"
      fill="white"
    />
    <path
      d="M3.00037 12.5468L5.86909 13.3812C6.24407 12.878 6.84094 12.5655 7.48468 12.5655H9.74401C9.81277 12.5655 9.87839 12.5468 9.93776 12.5093L11.0534 11.7999C11.6221 11.4406 12.2783 11.2499 12.9502 11.2499H13.3721L13.1377 8.75311C12.9908 7.14375 12.1002 5.71252 10.7628 4.84692H5.09409C3.75662 5.71252 2.866 7.14375 2.71913 8.75311L2.36914 12.4749C2.58168 12.4622 2.79267 12.4867 3.00037 12.5468ZM8.21591 9.0031H7.64092C6.10033 8.95622 6.08158 6.725 7.61592 6.64688V6.32189C7.61592 6.14689 7.75654 6.0094 7.92841 6.0094C8.10028 6.0094 8.24091 6.1469 8.24091 6.32189V6.64688H9.08152C9.49402 6.65313 9.49402 7.26563 9.08152 7.27187H7.64092C6.91593 7.28438 6.91593 8.3656 7.64092 8.37811H8.2159C9.7565 8.42186 9.77838 10.6562 8.24091 10.7343V11.0624C8.24091 11.2343 8.10028 11.3749 7.92842 11.3749C7.75655 11.3749 7.61592 11.2343 7.61592 11.0624V10.7343H6.77844C6.36594 10.725 6.36594 10.1156 6.77844 10.1093H8.21591C8.94403 10.0968 8.94403 9.0156 8.21591 9.0031Z"
      fill="white"
    />
    <path
      d="M15.2309 12.1353C15.2371 12.0479 15.2496 11.9604 15.2684 11.876H12.9469C11.9915 11.8134 11.0339 12.5587 10.2693 13.0383C10.11 13.1383 9.92874 13.1914 9.74128 13.1914H7.48233C5.63751 13.2538 5.63576 15.9211 7.48236 15.9815C7.48233 15.9815 9.77564 15.9815 9.77564 15.9815C9.9482 15.9815 10.0881 16.1214 10.0881 16.294C10.0881 16.4665 9.9482 16.6064 9.77564 16.6064H7.48232C6.13326 16.6364 5.10949 15.2122 5.56709 13.9444C5.56707 13.9444 2.82069 13.1477 2.82069 13.1477C1.3852 12.7461 0.601082 14.7794 1.95213 15.4347C1.95209 15.4347 8.02599 18.3123 8.02599 18.3123C9.37545 18.9535 10.9598 18.8882 12.2533 18.1311L14.6654 16.7251C14.8405 16.6161 15.0756 16.6334 15.2715 16.6345C15.2072 16.6452 15.234 12.2631 15.2309 12.1353Z"
      fill="white"
    />
    <path
      d="M18.1211 11.2783H16.793C16.3961 11.2783 16.0555 11.5252 15.9211 11.8752C15.8836 11.9689 15.8617 12.0689 15.8555 12.1721V16.2908C15.8555 16.4126 15.8773 16.5283 15.9211 16.6345C16.0586 16.9814 16.3961 17.2282 16.793 17.2282H18.1211C18.4648 17.2282 18.746 16.947 18.746 16.6032V11.9033C18.746 11.5596 18.4648 11.2783 18.1211 11.2783ZM17.2992 13.2221C16.8898 13.2158 16.8898 12.6064 17.2992 12.5971C17.7117 12.6064 17.7086 13.2158 17.2992 13.2221Z"
      fill="white"
    />
  </svg> `
    ),
    percantage: (
      /* HTML */
      `<svg
    width="28"
    height="28"
    viewBox="0 0 28 28"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      d="M27.3929 11.6749L25.5368 4.25019C25.4904 4.08776 25.4324 3.93694 25.3628 3.79776L22.0796 7.08088C22.5089 7.99734 22.3581 9.1226 21.604 9.87669C20.6412 10.8395 19.0866 10.8396 18.1237 9.87669C17.1608 8.9138 17.1609 7.35919 18.1237 6.39635C18.8778 5.64226 20.003 5.49144 20.9195 5.92074L24.2026 2.63761C24.0634 2.56794 23.9126 2.51002 23.7502 2.46359L16.3255 0.607488C15.4903 0.39869 14.597 0.642269 13.9821 1.25712L0.722145 14.5171C-0.240688 15.4799 -0.240742 17.0345 0.722145 17.9974L10.003 27.2783C10.9659 28.2412 12.5205 28.2411 13.4833 27.2783L26.7433 14.0182C27.3582 13.4033 27.6017 12.5101 27.3929 11.6749ZM10.003 9.87669C10.9659 8.9138 12.5204 8.9138 13.4833 9.87669C14.4463 10.8396 14.4462 12.3941 13.4833 13.357C12.5205 14.3198 10.9659 14.3199 10.003 13.357C9.04005 12.3941 9.04016 10.8395 10.003 9.87669ZM14.6434 21.4777C13.6805 22.4405 12.126 22.4406 11.1631 21.4777C10.2002 20.5148 10.2003 18.9602 11.1631 17.9974C12.126 17.0345 13.6805 17.0345 14.6434 17.9974C15.6063 18.9603 15.6063 20.5148 14.6434 21.4777ZM17.6343 15.9128L7.19335 17.0729C6.93561 17.1007 6.69258 17.0073 6.52211 16.8367C6.39524 16.7099 6.30856 16.5405 6.28701 16.3479C6.23774 15.8976 6.56176 15.492 7.01206 15.4416L17.453 14.2815C17.9028 14.2339 18.3089 14.5562 18.3593 15.0065C18.4086 15.4569 18.0846 15.8624 17.6343 15.9128Z"
      fill="#0373BD"
    />
  </svg>`
    )
  }, {
    close: Te,
    arrowPrev: Ut,
    arrowNext: Kt,
    quality: Jt,
    money: Qt,
    percantage: es
  } = Zt;
  let N = null;
  document.querySelectorAll(".add-to-cart").forEach((s) => {
    s.addEventListener("click", async () => {
      N = null;
    });
  });
  const Ce = async () => {
    var s, e;
    try {
      if (N)
        return N;
      const i = await (await fetch("https://www.paintscratch.com/cgi-bin/shopping-cart.cgi")).text(), n = new DOMParser().parseFromString(i, "text/html"), l = n.querySelectorAll(".cart-row"), a = [];
      l && l.forEach((p, f) => {
        var b;
        const g = p.querySelector(".cart-pic img"), h = p.querySelector(".item-title a"), m = p.querySelector(".quantity .each-price"), w = {
          image: g.src || g.dataset.cfsrc,
          title: h.textContent,
          price: parseFloat(((b = m == null ? void 0 : m.textContent) == null ? void 0 : b.replace(/[$()@]/g, "")) || "0")
        };
        a.push(w);
      });
      const o = (e = (s = n.querySelector("#subtotals_and_shipping .right_side_text")) == null ? void 0 : s.textContent) == null ? void 0 : e.split("$")[1], c = parseFloat((o == null ? void 0 : o.replace(/[$()@]/g, "")) || "0");
      return N = { products: a, total: c }, N;
    } catch (t) {
      return console.error("Failed to get cart data:", t), { products: [], total: 0 };
    }
  }, V = (s, e, t, i = "") => {
    window.dataLayer = window.dataLayer || [], window.dataLayer.push({
      event: "event-to-ga4",
      event_name: s,
      event_desc: e,
      event_type: t,
      event_loc: i
    }), console.log(`Event: ${s} | ${e} | ${t} | ${i}`);
  }, J = (s, e, t, i, r = 3, n) => {
    let l = new IntersectionObserver(
      (o) => {
        o.forEach((c) => {
          c.isIntersecting && (l.unobserve(c.target), setTimeout(function() {
            a.observe(c.target);
          }, 1e3 * r));
        });
      },
      {
        threshold: 0.5
      }
    ), a = new IntersectionObserver((o) => {
      o.forEach((c) => {
        c.isIntersecting ? (V(
          e || `view_element_${c.target.id}`,
          t || `View element on screen (${r} sec or more)`,
          "view",
          i || c.target.id
        ), n && n(), l.unobserve(c.target)) : l.observe(c.target), a.unobserve(c.target);
      });
    });
    document.querySelectorAll(s).forEach((o) => {
      l.observe(o);
    });
  };
  function ts(s) {
    return new Promise((e) => {
      if (document.querySelector(s))
        return e(document.querySelector(s));
      const t = new MutationObserver(() => {
        document.querySelector(s) && (e(document.querySelector(s)), t.disconnect());
      });
      t.observe(document.documentElement, {
        childList: !0,
        subtree: !0,
        characterData: !0
      });
    });
  }
  const de = (s) => document.querySelector(s), ss = function(s) {
    s = s || {};
    let e, t, i, r, n = s.delay || 50;
    function l() {
      e = null, r = 0;
    }
    return l(), function() {
      return t = window.scrollY, e != null && (r = t - e), e = t, clearTimeout(i), i = setTimeout(l, n), r;
    };
  }();
  function R(s) {
    let e = {};
    return document.cookie.split(";").forEach(function(t) {
      let i = t.split("=");
      e[i[0].trim()] = i.slice(1).join("=");
    }), e[s];
  }
  const is = "https://conversionratestore.github.io/projects/paintscratch", Ee = "FIRSTORDER5";
  class ns {
    constructor() {
      this.popup = null, this.dataPopup = "off-purchase";
    }
    render(e = "body", t = "beforeend") {
      const i = (
        /* HTML */
        `
      <dialog class="os-border-none os-p-0 os-w-[335px] md:os-w-[460px]" data-popup="${this.dataPopup}">
        <div class="os-p-y-[20px] md:os-p-y-[30px] os-pb-[20px] md:os-pb-[30px]">
          <div class="os-relative os-bg-[#0373bd] os-py-[12px] ">
            <button
              data-popup-close="${this.dataPopup}"
              class="os-p-0 os-flex os-justify-center os-absolute os-top-[50%] os-right-[18px] -os-translate-y-2/4 os-bg-transparent os-border-none [&_svg]:os-w-full focus:os-outline-none focus-within:os-outline-none"
            >
              ${Te}
            </button>
            <h2 class="os-m-0 os-text-center os-text-[18px] md:os-text-[20px] os-font-bold os-text-white">Don’t leave just yet!</h2>
          </div>
          <div class="os-px-[20px] md:os-px-[30px]">
            <div class="os-flex os-justify-center"><img src="${is}/img/kits-deluxe-spray.png" alt="kits deluxe spray" /></div>
          </div>
          <div class="os-px-[20px] md:os-px-[30px] os-text-center os-text-[30px] md:os-text-[36px] os-font-bold os-text-[#333]">
            <span class="os-text-[#0373bd]">Get 5%</span> Off Your <br class="os-hidden md:os-block"> Purchase Now!
        </div>
        <div class="os-flex os-justify-center os-p-[10px]">
          <div class="os-w-[60px] os-h-[2px] os-bg-[#0373bd]"></div>
        </div>
        <div class="os-text-[#333] os-px-[20px] os-text-center os-font-bold os-text-[14px] md:os-text-[18px]">
        Secure Your Exclusive Discount on Professional-Grade Touch-Up Paint!
        </div>
        <div class="os-mt-[16px] os-px-[20px] md:os-px-[30px]">
        <button class="os-flex os-justify-center os-items-center os-cursor-pointer os-text-[#333] focus:os-text-[#333] hover:os-text-[#333] os-h-[50px] os-w-full os-font-bold os-text-[16px] md:os-text-[18px] os-bg-[linear-gradient(to_bottom,_#ffc842,_#f48818)] os-border-solid os-border-[2px] os-border-[#e68626] os-rounded-[4px]" data-button="select-products">Select products</button></div>
        <div class="os-mt-[12px] os-text-[#767676] os-text-[14px] os-text-center os-px-[20px] md:os-px-[30px] os-leading-[20px]">Click to secure your savings! Discount applies automatically at checkout. Act quickly — this offer expires soon!</div>
        </dialog>
    `
      );
      document.querySelector(e).insertAdjacentHTML(t, i), J(
        `[data-popup="${this.dataPopup}"]`,
        "exp_exitintent_section_01",
        "Section",
        "Exit intent pop-up empty cart Don’t leave just yet! Get 5% Off Your Purchase Now!",
        0
      ), this.popup = document.querySelector(`[data-popup="${this.dataPopup}"]`), this.popup.addEventListener("click", async (r) => {
        if (r.target.closest("[data-popup-close]") && (this.hide(), V(
          "exp_exitintent_button_02",
          "Close",
          "click",
          "Exit intent pop-up empty cart Don’t leave just yet! Get 5% Off Your Purchase Now!"
        )), r.target === this.popup && this.hide(), r.target.closest('[data-button="select-products"]')) {
          V(
            "exp_exitintent_button_01",
            "Select products",
            "click",
            "Exit intent pop-up empty cart Don’t leave just yet! Get 5% Off Your Purchase Now!"
          );
          const n = R("makeSelected"), l = R("yearSelected"), a = decodeURIComponent(R("modelSelected")), o = R("ColorNameSelectedLast"), c = R("ColorRgbSelectedLast");
          if (this.hide(), n && l && a && o && c) {
            console.log({ makeSelected: n, yearSelected: l, modelSelected: a, colorNameSelectedLast: o, colorRgbSelectedLast: c });
            const p = document.createElement("form");
            p.method = "POST", p.action = "https://www.paintscratch.com/cgi-bin/order-form.cgi?discount_code=FIRSTORDER5";
            const f = document.createElement("input");
            f.type = "hidden", f.name = "vehicle", f.value = `${l} ${n} ${a}`, p.appendChild(f);
            const g = document.createElement("input");
            g.type = "hidden", g.name = "make", g.value = n, p.appendChild(g);
            const h = document.createElement("input");
            h.type = "hidden", h.name = "model", h.value = a, p.appendChild(h);
            const m = document.createElement("input");
            m.type = "hidden", m.name = "year", m.value = l, p.appendChild(m);
            const w = document.createElement("input");
            w.type = "hidden", w.name = "paint", w.value = o, p.appendChild(w);
            const b = document.createElement("input");
            b.type = "hidden", b.name = "color", b.value = c, p.appendChild(b), document.body.appendChild(p), p.submit();
          } else
            document.location.href = "https://www.paintscratch.com/cgi-bin/order-form.cgi?discount_code=FIRSTORDER5";
        }
      });
    }
    show() {
      this.popup && this.popup.showModal();
    }
    hide() {
      this.popup && this.popup.close();
    }
  }
  class rs {
    constructor() {
      this.popup = null, this.dataPopup = "cart-purchase", this.total = 0;
    }
    render(e = "body", t = "beforeend") {
      const i = (
        /* HTML */
        `
      <dialog class="os-border-none os-p-0 os-w-[335px] md:os-w-[460px]" data-popup="${this.dataPopup}">
        <div class="os-pb-[20px] md:os-pb-[20px]">
          <div class="os-relative os-bg-[#0373bd] os-py-[12px] ">
            <button
              data-popup-close="${this.dataPopup}"
              class="os-p-0 os-flex os-justify-center os-absolute os-top-[50%] os-right-[18px] -os-translate-y-2/4 os-bg-transparent os-border-none [&_svg]:os-w-full focus:os-outline-none focus-within:os-outline-none"
            >
              ${Te}
            </button>
            <h2 class="os-m-0 os-text-center os-text-[18px] md:os-text-[20px] os-text-white os-font-bold">
              You're Almost There! <br /><span class="os-text-[14px] os-font-normal">Only one step left:</span>
            </h2>
          </div>

          <div class="os-px-[20px] md:os-px-[30px]">
            <div class="" data-swiper></div>

            <div class="os-mt-[16px]">
              <button
                data-button="complete-order"
                class="os-text-[#333] os-h-[50px] os-w-full os-font-bold os-text-[16px] md:os-text-[18px] os-bg-[linear-gradient(to_bottom,_#ffc842,_#f48818)] os-border-solid os-border-[2px] os-border-[#e68626] os-rounded-[4px]"
              >
                Complete my order
              </button>
            </div>
            <div
              class="os-mt-[12px] os-text-[#767676] os-text-[14px] os-text-center os-leading-[22px]"
              data-popup="subtext"
            ></div>
          </div>
        </div>
      </dialog>
    `
      );
      document.querySelector(e).insertAdjacentHTML(t, i), this.popup = document.querySelector(`[data-popup="${this.dataPopup}"]`), document.querySelector('[data-button="complete-order"]').addEventListener("click", () => {
        this.total >= 100 && V(
          "exp_exitintent_button_03",
          "Complete my order",
          "click",
          "Exit intent pop-up filled cart You're Almost There! More 100 dollars"
        ), this.total < 100 && V(
          "exp_exitintent_button_05",
          "Complete my order",
          "click",
          "Exit intent pop-up filled cart You're Almost There! Less 100 dollars"
        ), this.hide();
        const n = new URL("https://www.paintscratch.com/cgi-bin/shopping-cart.cgi");
        n.searchParams.set("discount_code", Ee), document.cookie = `discount_code=${Ee};path=/`, setTimeout(() => {
          window.location.href = n.toString();
        }, 500);
      }), this.popup.addEventListener("click", (n) => {
        n.target.closest("[data-popup-close]") && (this.total >= 100 && V(
          "exp_exitintent_button_04",
          "Close",
          "click",
          "Exit intent pop-up filled cart You're Almost There! More 100 dollars"
        ), this.total < 100 && V(
          "exp_exitintent_button_06",
          "Close",
          "click",
          "Exit intent pop-up filled cart You're Almost There! Less 100 dollars"
        ), this.hide());
      });
    }
    async cartProducts() {
      const e = await Ce();
      this.total = e.total;
      const t = (
        /* HTML */
        `
      <div class="os-w-full os-mt-[20px] os-pb-[16px]" style="border-bottom: 1px dashed #dddee9">
        <div class="swiper">
          <!-- Additional required wrapper -->
          <div class="swiper-wrapper">
            ${e.products && e.products.length > 0 ? e.products.map((i) => (
          /* HTML */
          `
                      <!-- Slides -->
                      <div class="swiper-slide os-w-[60%] os-overflow-hidden osborder">
                        <div class="os-flex os-flex-col os-justify-center os-items-center os-gap-[8px] os-px-[10px]">
                          <div class="os-w-[104px] os-h-[104px] os-flex os-justify-center os-items-center">
                            <img class="os-h-full" src="${i.image}" alt="${i.name}" />
                          </div>
                          <div class="os-text-[#253189] os-text-[16px] os-font-bold os-text-center">
                            ${i.title}
                          </div>
                          <div class="os-text-center os-text-[#555] ">
                            <span class="os-font-bold os-text-[12px]"
                              ><span class="os-text-[14px] os-line-through">$${i.price.toFixed(2)}</span
                              ><span class="os-text-[#900] os-text-[18px]">
                                $${(i.price * 0.95).toFixed(2)}</span
                              ></span
                            >
                            / Each
                          </div>
                        </div>
                      </div>
                    `
        )).join("") : ""}
          </div>
          <div class="os-w-full os-mt-[16px] os-flex os-justify-center os-items-center os-gap-[16px]">
            <div
              class="os-static swiper-button-prev os-w-[10px] os-h-[15px] after:os-text-[10px] os-m-0 os-hidden md:os-flex"
            >
              ${Ut}
            </div>
            <div class="swiper-pagination os-static !os-w-max"></div>
            <div
              class="os-static swiper-button-next os-w-[10px] os-h-[15px] after:os-text-[10px] os-m-0 os-hidden md:os-flex"
            >
              ${Kt}
            </div>
          </div>
        </div>
      </div>
      ${+e.total >= 100 ? (
          /* HTML */
          `<div
              data-cart="more"
              class="os-w-fit os-gap-[8px] md:os-w-full os-justify-between os-flex-col md:os-flex-row os-mt-[16px] os-flex os-border-t-[1px] os-border-[#dddee9]"
            >
              <div class="os-text-[#333] os-font-bold os-text-[18px] os-flex os-items-center">
                Total:&nbsp;
                ${e.products.length === 1 ? (
            /* HTML */
            `<span class="os-font-bold os-text-[12px]"
                      ><span class="os-text-[14px] os-line-through"> $${e.total.toFixed(2)}</span
                      ><span class="os-text-[#900] os-text-[18px]"> $${(e.total * 0.95).toFixed(2)}</span></span
                    >`
          ) : (
            /* HTML */
            `<span class="os-flex os-items-center">$${(e.total * 0.95).toFixed(2)}</span>`
          )}
              </div>
              <div
                class="os-flex os-items-center os-gap-[6px] os-bg-[#0373bd] os-rounded-[4px] os-text-white os-font-bold os-p-[8px]"
              >
                <span class="os-flex os-items-center">${Qt}</span>Your savings:
                <span>$${(e.total * 0.05).toFixed(2)}</span>
              </div>
            </div>
            <div
              class="os-flex os-items-center os-w-fit os-gap-[8px] os-mt-[16px] os-py-[8px] os-px-[12px] os-border-dashed os-border-[1px] os-border-[#dddee9]"
            >
              <div>${Jt}</div>
              <div class="os-text-[#333] os-text-left os-leading-[22px]">
                With every selection, you're securing top-quality product at a great price!
              </div>
            </div>`
        ) : (
          /* HTML */
          `<div
            data-cart="less"
            class="os-flex os-items-center  os-gap-[8px] os-mt-[16px] os-py-[8px] os-px-[12px] os-border-dashed os-border-[1px] os-border-[#dddee9]"
          >
            <div>${es}</div>
            <div class="os-text-[#333] os-text-left os-leading-[22px] os-text-[14px] md:os-text-[16px]">
              Complete your order now and enjoy<br class="os-hidden md:os-block" />
              a <span class="os-text-[#0373bd] os-font-bold">5% discount</span> on your entire order!
            </div>
          </div>`
        )}
    `
      );
      this.popup.querySelector("[data-swiper]").innerHTML = t, this.popup.querySelector('[data-popup="subtext"]').innerHTML = this.total > 100 ? "Don't miss out – finalize your purchase now to lock in this deal before it's gone. Your 5% discount applies automatically at checkout." : "Click the button to lock in your 5% savings automatically at checkout. Don't delay, offer ends soon!", J(
        '[data-cart="more"]',
        "exp_exitintent_section_02",
        "Section",
        "Exit intent pop-up filled cart You're Almost There! More 100 dollars",
        0
      ), J(
        '[data-cart="less"]',
        "exp_exitintent_section_03",
        "Section",
        "Exit intent pop-up filled cart You're Almost There! Less 100 dollars",
        0
      ), J(
        '[data-cart="more"]',
        "exp_exitintent_section_04",
        `${e.products.length}- section`,
        "Exit intent pop-up filled cart You're Almost There! More 100 dollars",
        0
      ), new $(".swiper", {
        modules: [Wt, Xt],
        direction: "horizontal",
        loop: !0,
        slidesPerView: 2,
        centeredSlides: e.products.length === 1,
        pagination: {
          el: ".swiper-pagination",
          clickable: !0
        },
        navigation: {
          enabled: e.products.length !== 1,
          nextEl: ".swiper-button-next",
          prevEl: ".swiper-button-prev"
        },
        scrollbar: {
          el: ".swiper-scrollbar"
        }
      });
    }
    show() {
      this.popup && (this.cartProducts(), this.popup.showModal());
    }
    hide() {
      this.popup && this.popup.close();
    }
  }
  console.log(
    "%c EXP: Exit Intent Popup (DEV: OS)",
    "background: #3498eb; color: #fccf3a; font-size: 20px; font-weight: bold;"
  );
  const os = setInterval(function() {
    typeof clarity == "function" && (clearInterval(os), clarity("set", "exp_exi_inte_popup", "variant_1"));
  }, 1e3), q = {
    mobile: "Mobile",
    desktop: "Desktop"
  };
  class as {
    constructor() {
      this.device = screen.width <= 768 ? q.mobile : q.desktop, this.cartPopup = new rs(), this.offPurchasePopup = new ns();
    }
    init() {
      this.cartPopup.render(), this.offPurchasePopup.render(), this.trigger(), this.mobilePromo();
    }
    mobilePromo() {
      location.href.includes("shopping-cart.cgi") && this.device === q.mobile && ts(".total_block").then(() => {
        const e = de('input[name="shippingTotal"]').value, t = de(".total_block .ship span span"), i = (
          /* HTML */
          ` <style>
            .total_block .discount {
              display: flex;
              justify-content: space-between;
              align-items: center;
              font-size: 16px !important;
              line-height: 24px !important;
              color: #333;
              font-weight: 700;
            }
          </style>
          <p class="discount">
            <span>5% Discount:</span
            ><span><span style="background-color: #ffffcc; padding: 10px 0px">${t.textContent}</span></span>
          </p>`
        );
        t.textContent = `$${e}`, de(".ship").insertAdjacentHTML("beforebegin", i);
      });
    }
    trigger() {
      if (location.pathname === "/")
        return;
      const e = async () => {
        const r = await Ce();
        if (r.products && r.products.length > 0) {
          if (sessionStorage.getItem("exit-intent-popup-1"))
            return;
          this.cartPopup.show(), sessionStorage.setItem("exit-intent-popup-1", "true");
        } else {
          if (sessionStorage.getItem("exit-intent-popup-2"))
            return;
          this.offPurchasePopup.show(), sessionStorage.setItem("exit-intent-popup-2", "true");
        }
      };
      this.device === q.desktop && document.addEventListener("mouseout", async (r) => {
        (r.clientY <= 0 || r.clientX <= 0 || r.clientX >= window.innerWidth || r.clientY >= window.innerHeight) && e();
      }), this.device === q.mobile && document.addEventListener("scroll", async (r) => {
        const n = ss();
        (n > 70 || n < -70) && e();
      }), window.addEventListener("focus", (r) => {
        e();
      });
      let t = setTimeout(async () => {
        e();
      }, 2e4);
      const i = () => {
        clearTimeout(t), t = setTimeout(async () => {
          e();
        }, 2e4);
      };
      document.addEventListener("mousemove", i), document.addEventListener("scroll", i), document.addEventListener("keydown", i), document.addEventListener("touchstart", i), document.addEventListener("click", i);
    }
  }
  new as().init();
})();
